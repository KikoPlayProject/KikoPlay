// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Service/pb/service.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_Service_2fpb_2fservice_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_Service_2fpb_2fservice_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021008 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_util.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_Service_2fpb_2fservice_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_Service_2fpb_2fservice_2eproto {
  static const uint32_t offsets[];
};
namespace kservice {
class AddDanmuSourceEvent;
struct AddDanmuSourceEventDefaultTypeInternal;
extern AddDanmuSourceEventDefaultTypeInternal _AddDanmuSourceEvent_default_instance_;
class AddDanmuSourceEvent_DanmuPoolSource;
struct AddDanmuSourceEvent_DanmuPoolSourceDefaultTypeInternal;
extern AddDanmuSourceEvent_DanmuPoolSourceDefaultTypeInternal _AddDanmuSourceEvent_DanmuPoolSource_default_instance_;
class CommonEvent;
struct CommonEventDefaultTypeInternal;
extern CommonEventDefaultTypeInternal _CommonEvent_default_instance_;
class DanmuComment;
struct DanmuCommentDefaultTypeInternal;
extern DanmuCommentDefaultTypeInternal _DanmuComment_default_instance_;
class DanmuSource;
struct DanmuSourceDefaultTypeInternal;
extern DanmuSourceDefaultTypeInternal _DanmuSource_default_instance_;
class EventHeader;
struct EventHeaderDefaultTypeInternal;
extern EventHeaderDefaultTypeInternal _EventHeader_default_instance_;
class InfoSource;
struct InfoSourceDefaultTypeInternal;
extern InfoSourceDefaultTypeInternal _InfoSource_default_instance_;
class KFileInfo;
struct KFileInfoDefaultTypeInternal;
extern KFileInfoDefaultTypeInternal _KFileInfo_default_instance_;
class KikoDanmuRequest;
struct KikoDanmuRequestDefaultTypeInternal;
extern KikoDanmuRequestDefaultTypeInternal _KikoDanmuRequest_default_instance_;
class KikoDanmuResponse;
struct KikoDanmuResponseDefaultTypeInternal;
extern KikoDanmuResponseDefaultTypeInternal _KikoDanmuResponse_default_instance_;
class KikoDanmuResponse_DanmuSourceComments;
struct KikoDanmuResponse_DanmuSourceCommentsDefaultTypeInternal;
extern KikoDanmuResponse_DanmuSourceCommentsDefaultTypeInternal _KikoDanmuResponse_DanmuSourceComments_default_instance_;
class LaunchRequest;
struct LaunchRequestDefaultTypeInternal;
extern LaunchRequestDefaultTypeInternal _LaunchRequest_default_instance_;
class LaunchResponse;
struct LaunchResponseDefaultTypeInternal;
extern LaunchResponseDefaultTypeInternal _LaunchResponse_default_instance_;
class LoginRequest;
struct LoginRequestDefaultTypeInternal;
extern LoginRequestDefaultTypeInternal _LoginRequest_default_instance_;
class LoginResponse;
struct LoginResponseDefaultTypeInternal;
extern LoginResponseDefaultTypeInternal _LoginResponse_default_instance_;
class MatchEvent;
struct MatchEventDefaultTypeInternal;
extern MatchEventDefaultTypeInternal _MatchEvent_default_instance_;
class MatchEvent_Match;
struct MatchEvent_MatchDefaultTypeInternal;
extern MatchEvent_MatchDefaultTypeInternal _MatchEvent_Match_default_instance_;
class Pool;
struct PoolDefaultTypeInternal;
extern PoolDefaultTypeInternal _Pool_default_instance_;
class RecoRequest;
struct RecoRequestDefaultTypeInternal;
extern RecoRequestDefaultTypeInternal _RecoRequest_default_instance_;
class RecoResponse;
struct RecoResponseDefaultTypeInternal;
extern RecoResponseDefaultTypeInternal _RecoResponse_default_instance_;
class RefreshRequest;
struct RefreshRequestDefaultTypeInternal;
extern RefreshRequestDefaultTypeInternal _RefreshRequest_default_instance_;
class RefreshResponse;
struct RefreshResponseDefaultTypeInternal;
extern RefreshResponseDefaultTypeInternal _RefreshResponse_default_instance_;
class RegisterRequest;
struct RegisterRequestDefaultTypeInternal;
extern RegisterRequestDefaultTypeInternal _RegisterRequest_default_instance_;
class RegisterResponse;
struct RegisterResponseDefaultTypeInternal;
extern RegisterResponseDefaultTypeInternal _RegisterResponse_default_instance_;
class ResponseHeader;
struct ResponseHeaderDefaultTypeInternal;
extern ResponseHeaderDefaultTypeInternal _ResponseHeader_default_instance_;
class SendVerificationRequest;
struct SendVerificationRequestDefaultTypeInternal;
extern SendVerificationRequestDefaultTypeInternal _SendVerificationRequest_default_instance_;
class SendVerificationResponse;
struct SendVerificationResponseDefaultTypeInternal;
extern SendVerificationResponseDefaultTypeInternal _SendVerificationResponse_default_instance_;
class UVEvent;
struct UVEventDefaultTypeInternal;
extern UVEventDefaultTypeInternal _UVEvent_default_instance_;
class UVEventResponse;
struct UVEventResponseDefaultTypeInternal;
extern UVEventResponseDefaultTypeInternal _UVEventResponse_default_instance_;
class UVEventResponse_LatestVersion;
struct UVEventResponse_LatestVersionDefaultTypeInternal;
extern UVEventResponse_LatestVersionDefaultTypeInternal _UVEventResponse_LatestVersion_default_instance_;
class UVEvent_StepTime;
struct UVEvent_StepTimeDefaultTypeInternal;
extern UVEvent_StepTimeDefaultTypeInternal _UVEvent_StepTime_default_instance_;
}  // namespace kservice
PROTOBUF_NAMESPACE_OPEN
template<> ::kservice::AddDanmuSourceEvent* Arena::CreateMaybeMessage<::kservice::AddDanmuSourceEvent>(Arena*);
template<> ::kservice::AddDanmuSourceEvent_DanmuPoolSource* Arena::CreateMaybeMessage<::kservice::AddDanmuSourceEvent_DanmuPoolSource>(Arena*);
template<> ::kservice::CommonEvent* Arena::CreateMaybeMessage<::kservice::CommonEvent>(Arena*);
template<> ::kservice::DanmuComment* Arena::CreateMaybeMessage<::kservice::DanmuComment>(Arena*);
template<> ::kservice::DanmuSource* Arena::CreateMaybeMessage<::kservice::DanmuSource>(Arena*);
template<> ::kservice::EventHeader* Arena::CreateMaybeMessage<::kservice::EventHeader>(Arena*);
template<> ::kservice::InfoSource* Arena::CreateMaybeMessage<::kservice::InfoSource>(Arena*);
template<> ::kservice::KFileInfo* Arena::CreateMaybeMessage<::kservice::KFileInfo>(Arena*);
template<> ::kservice::KikoDanmuRequest* Arena::CreateMaybeMessage<::kservice::KikoDanmuRequest>(Arena*);
template<> ::kservice::KikoDanmuResponse* Arena::CreateMaybeMessage<::kservice::KikoDanmuResponse>(Arena*);
template<> ::kservice::KikoDanmuResponse_DanmuSourceComments* Arena::CreateMaybeMessage<::kservice::KikoDanmuResponse_DanmuSourceComments>(Arena*);
template<> ::kservice::LaunchRequest* Arena::CreateMaybeMessage<::kservice::LaunchRequest>(Arena*);
template<> ::kservice::LaunchResponse* Arena::CreateMaybeMessage<::kservice::LaunchResponse>(Arena*);
template<> ::kservice::LoginRequest* Arena::CreateMaybeMessage<::kservice::LoginRequest>(Arena*);
template<> ::kservice::LoginResponse* Arena::CreateMaybeMessage<::kservice::LoginResponse>(Arena*);
template<> ::kservice::MatchEvent* Arena::CreateMaybeMessage<::kservice::MatchEvent>(Arena*);
template<> ::kservice::MatchEvent_Match* Arena::CreateMaybeMessage<::kservice::MatchEvent_Match>(Arena*);
template<> ::kservice::Pool* Arena::CreateMaybeMessage<::kservice::Pool>(Arena*);
template<> ::kservice::RecoRequest* Arena::CreateMaybeMessage<::kservice::RecoRequest>(Arena*);
template<> ::kservice::RecoResponse* Arena::CreateMaybeMessage<::kservice::RecoResponse>(Arena*);
template<> ::kservice::RefreshRequest* Arena::CreateMaybeMessage<::kservice::RefreshRequest>(Arena*);
template<> ::kservice::RefreshResponse* Arena::CreateMaybeMessage<::kservice::RefreshResponse>(Arena*);
template<> ::kservice::RegisterRequest* Arena::CreateMaybeMessage<::kservice::RegisterRequest>(Arena*);
template<> ::kservice::RegisterResponse* Arena::CreateMaybeMessage<::kservice::RegisterResponse>(Arena*);
template<> ::kservice::ResponseHeader* Arena::CreateMaybeMessage<::kservice::ResponseHeader>(Arena*);
template<> ::kservice::SendVerificationRequest* Arena::CreateMaybeMessage<::kservice::SendVerificationRequest>(Arena*);
template<> ::kservice::SendVerificationResponse* Arena::CreateMaybeMessage<::kservice::SendVerificationResponse>(Arena*);
template<> ::kservice::UVEvent* Arena::CreateMaybeMessage<::kservice::UVEvent>(Arena*);
template<> ::kservice::UVEventResponse* Arena::CreateMaybeMessage<::kservice::UVEventResponse>(Arena*);
template<> ::kservice::UVEventResponse_LatestVersion* Arena::CreateMaybeMessage<::kservice::UVEventResponse_LatestVersion>(Arena*);
template<> ::kservice::UVEvent_StepTime* Arena::CreateMaybeMessage<::kservice::UVEvent_StepTime>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace kservice {

enum EpType : int {
  UNKNOWN_EP = 0,
  EP = 1,
  SP = 2,
  OP = 3,
  ED = 4,
  Trailer = 5,
  MAD = 6,
  Other = 7,
  EpType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  EpType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool EpType_IsValid(int value);
constexpr EpType EpType_MIN = UNKNOWN_EP;
constexpr EpType EpType_MAX = Other;
constexpr int EpType_ARRAYSIZE = EpType_MAX + 1;

const std::string& EpType_Name(EpType value);
template<typename T>
inline const std::string& EpType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, EpType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function EpType_Name.");
  return EpType_Name(static_cast<EpType>(enum_t_value));
}
bool EpType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, EpType* value);
enum DanmuSourceType : int {
  UNKNOWN_DM_SRC = 0,
  KIKO = 1,
  BILIBILI = 2,
  GAMER = 3,
  IQIYI = 4,
  TENCENT = 5,
  YOUKU = 6,
  MGTV = 7,
  TUCAO = 8,
  ACFUN = 9,
  YSJ = 10,
  DanmuSourceType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  DanmuSourceType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool DanmuSourceType_IsValid(int value);
constexpr DanmuSourceType DanmuSourceType_MIN = UNKNOWN_DM_SRC;
constexpr DanmuSourceType DanmuSourceType_MAX = YSJ;
constexpr int DanmuSourceType_ARRAYSIZE = DanmuSourceType_MAX + 1;

const std::string& DanmuSourceType_Name(DanmuSourceType value);
template<typename T>
inline const std::string& DanmuSourceType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, DanmuSourceType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function DanmuSourceType_Name.");
  return DanmuSourceType_Name(static_cast<DanmuSourceType>(enum_t_value));
}
bool DanmuSourceType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, DanmuSourceType* value);
enum InfoSourceType : int {
  UNKNOWN_INFO_SRC = 0,
  BGM = 1,
  DOUBAN = 2,
  InfoSourceType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  InfoSourceType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool InfoSourceType_IsValid(int value);
constexpr InfoSourceType InfoSourceType_MIN = UNKNOWN_INFO_SRC;
constexpr InfoSourceType InfoSourceType_MAX = DOUBAN;
constexpr int InfoSourceType_ARRAYSIZE = InfoSourceType_MAX + 1;

const std::string& InfoSourceType_Name(InfoSourceType value);
template<typename T>
inline const std::string& InfoSourceType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, InfoSourceType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function InfoSourceType_Name.");
  return InfoSourceType_Name(static_cast<InfoSourceType>(enum_t_value));
}
bool InfoSourceType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, InfoSourceType* value);
// ===================================================================

class EventHeader final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:kservice.EventHeader) */ {
 public:
  inline EventHeader() : EventHeader(nullptr) {}
  ~EventHeader() override;
  explicit PROTOBUF_CONSTEXPR EventHeader(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EventHeader(const EventHeader& from);
  EventHeader(EventHeader&& from) noexcept
    : EventHeader() {
    *this = ::std::move(from);
  }

  inline EventHeader& operator=(const EventHeader& from) {
    CopyFrom(from);
    return *this;
  }
  inline EventHeader& operator=(EventHeader&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const EventHeader& default_instance() {
    return *internal_default_instance();
  }
  static inline const EventHeader* internal_default_instance() {
    return reinterpret_cast<const EventHeader*>(
               &_EventHeader_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(EventHeader& a, EventHeader& b) {
    a.Swap(&b);
  }
  inline void Swap(EventHeader* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EventHeader* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EventHeader* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EventHeader>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const EventHeader& from);
  void MergeFrom(const EventHeader& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(EventHeader* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "kservice.EventHeader";
  }
  protected:
  explicit EventHeader(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEventFieldNumber = 2,
    kOsFieldNumber = 3,
    kDidFieldNumber = 5,
    kUidFieldNumber = 6,
    kTimestampFieldNumber = 1,
    kVersionFieldNumber = 4,
  };
  // string event = 2;
  void clear_event();
  const std::string& event() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_event(ArgT0&& arg0, ArgT... args);
  std::string* mutable_event();
  PROTOBUF_NODISCARD std::string* release_event();
  void set_allocated_event(std::string* event);
  private:
  const std::string& _internal_event() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_event(const std::string& value);
  std::string* _internal_mutable_event();
  public:

  // string os = 3;
  void clear_os();
  const std::string& os() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_os(ArgT0&& arg0, ArgT... args);
  std::string* mutable_os();
  PROTOBUF_NODISCARD std::string* release_os();
  void set_allocated_os(std::string* os);
  private:
  const std::string& _internal_os() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_os(const std::string& value);
  std::string* _internal_mutable_os();
  public:

  // string did = 5;
  void clear_did();
  const std::string& did() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_did(ArgT0&& arg0, ArgT... args);
  std::string* mutable_did();
  PROTOBUF_NODISCARD std::string* release_did();
  void set_allocated_did(std::string* did);
  private:
  const std::string& _internal_did() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_did(const std::string& value);
  std::string* _internal_mutable_did();
  public:

  // string uid = 6;
  void clear_uid();
  const std::string& uid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_uid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_uid();
  PROTOBUF_NODISCARD std::string* release_uid();
  void set_allocated_uid(std::string* uid);
  private:
  const std::string& _internal_uid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_uid(const std::string& value);
  std::string* _internal_mutable_uid();
  public:

  // int64 timestamp = 1;
  void clear_timestamp();
  int64_t timestamp() const;
  void set_timestamp(int64_t value);
  private:
  int64_t _internal_timestamp() const;
  void _internal_set_timestamp(int64_t value);
  public:

  // int32 version = 4;
  void clear_version();
  int32_t version() const;
  void set_version(int32_t value);
  private:
  int32_t _internal_version() const;
  void _internal_set_version(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:kservice.EventHeader)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr event_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr os_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr did_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr uid_;
    int64_t timestamp_;
    int32_t version_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Service_2fpb_2fservice_2eproto;
};
// -------------------------------------------------------------------

class CommonEvent final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:kservice.CommonEvent) */ {
 public:
  inline CommonEvent() : CommonEvent(nullptr) {}
  ~CommonEvent() override;
  explicit PROTOBUF_CONSTEXPR CommonEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CommonEvent(const CommonEvent& from);
  CommonEvent(CommonEvent&& from) noexcept
    : CommonEvent() {
    *this = ::std::move(from);
  }

  inline CommonEvent& operator=(const CommonEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline CommonEvent& operator=(CommonEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const CommonEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const CommonEvent* internal_default_instance() {
    return reinterpret_cast<const CommonEvent*>(
               &_CommonEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(CommonEvent& a, CommonEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(CommonEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CommonEvent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CommonEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CommonEvent>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const CommonEvent& from);
  void MergeFrom(const CommonEvent& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CommonEvent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "kservice.CommonEvent";
  }
  protected:
  explicit CommonEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kExtraFieldNumber = 2,
    kHeaderFieldNumber = 1,
  };
  // string extra = 2;
  void clear_extra();
  const std::string& extra() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_extra(ArgT0&& arg0, ArgT... args);
  std::string* mutable_extra();
  PROTOBUF_NODISCARD std::string* release_extra();
  void set_allocated_extra(std::string* extra);
  private:
  const std::string& _internal_extra() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_extra(const std::string& value);
  std::string* _internal_mutable_extra();
  public:

  // .kservice.EventHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::kservice::EventHeader& header() const;
  PROTOBUF_NODISCARD ::kservice::EventHeader* release_header();
  ::kservice::EventHeader* mutable_header();
  void set_allocated_header(::kservice::EventHeader* header);
  private:
  const ::kservice::EventHeader& _internal_header() const;
  ::kservice::EventHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::kservice::EventHeader* header);
  ::kservice::EventHeader* unsafe_arena_release_header();

  // @@protoc_insertion_point(class_scope:kservice.CommonEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr extra_;
    ::kservice::EventHeader* header_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Service_2fpb_2fservice_2eproto;
};
// -------------------------------------------------------------------

class ResponseHeader final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:kservice.ResponseHeader) */ {
 public:
  inline ResponseHeader() : ResponseHeader(nullptr) {}
  ~ResponseHeader() override;
  explicit PROTOBUF_CONSTEXPR ResponseHeader(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ResponseHeader(const ResponseHeader& from);
  ResponseHeader(ResponseHeader&& from) noexcept
    : ResponseHeader() {
    *this = ::std::move(from);
  }

  inline ResponseHeader& operator=(const ResponseHeader& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResponseHeader& operator=(ResponseHeader&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ResponseHeader& default_instance() {
    return *internal_default_instance();
  }
  static inline const ResponseHeader* internal_default_instance() {
    return reinterpret_cast<const ResponseHeader*>(
               &_ResponseHeader_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(ResponseHeader& a, ResponseHeader& b) {
    a.Swap(&b);
  }
  inline void Swap(ResponseHeader* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ResponseHeader* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ResponseHeader* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ResponseHeader>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const ResponseHeader& from);
  void MergeFrom(const ResponseHeader& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ResponseHeader* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "kservice.ResponseHeader";
  }
  protected:
  explicit ResponseHeader(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kErrMsgFieldNumber = 2,
    kStatusFieldNumber = 1,
  };
  // string err_msg = 2;
  void clear_err_msg();
  const std::string& err_msg() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_err_msg(ArgT0&& arg0, ArgT... args);
  std::string* mutable_err_msg();
  PROTOBUF_NODISCARD std::string* release_err_msg();
  void set_allocated_err_msg(std::string* err_msg);
  private:
  const std::string& _internal_err_msg() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_err_msg(const std::string& value);
  std::string* _internal_mutable_err_msg();
  public:

  // int32 status = 1;
  void clear_status();
  int32_t status() const;
  void set_status(int32_t value);
  private:
  int32_t _internal_status() const;
  void _internal_set_status(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:kservice.ResponseHeader)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr err_msg_;
    int32_t status_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Service_2fpb_2fservice_2eproto;
};
// -------------------------------------------------------------------

class RegisterRequest final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:kservice.RegisterRequest) */ {
 public:
  inline RegisterRequest() : RegisterRequest(nullptr) {}
  ~RegisterRequest() override;
  explicit PROTOBUF_CONSTEXPR RegisterRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RegisterRequest(const RegisterRequest& from);
  RegisterRequest(RegisterRequest&& from) noexcept
    : RegisterRequest() {
    *this = ::std::move(from);
  }

  inline RegisterRequest& operator=(const RegisterRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline RegisterRequest& operator=(RegisterRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const RegisterRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const RegisterRequest* internal_default_instance() {
    return reinterpret_cast<const RegisterRequest*>(
               &_RegisterRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(RegisterRequest& a, RegisterRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(RegisterRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RegisterRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RegisterRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RegisterRequest>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const RegisterRequest& from);
  void MergeFrom(const RegisterRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RegisterRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "kservice.RegisterRequest";
  }
  protected:
  explicit RegisterRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUsernameFieldNumber = 2,
    kPasswordFieldNumber = 3,
    kEmailFieldNumber = 4,
    kVerificationCodeFieldNumber = 5,
    kHeaderFieldNumber = 1,
  };
  // string username = 2;
  void clear_username();
  const std::string& username() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_username(ArgT0&& arg0, ArgT... args);
  std::string* mutable_username();
  PROTOBUF_NODISCARD std::string* release_username();
  void set_allocated_username(std::string* username);
  private:
  const std::string& _internal_username() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_username(const std::string& value);
  std::string* _internal_mutable_username();
  public:

  // string password = 3;
  void clear_password();
  const std::string& password() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_password(ArgT0&& arg0, ArgT... args);
  std::string* mutable_password();
  PROTOBUF_NODISCARD std::string* release_password();
  void set_allocated_password(std::string* password);
  private:
  const std::string& _internal_password() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_password(const std::string& value);
  std::string* _internal_mutable_password();
  public:

  // string email = 4;
  void clear_email();
  const std::string& email() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_email(ArgT0&& arg0, ArgT... args);
  std::string* mutable_email();
  PROTOBUF_NODISCARD std::string* release_email();
  void set_allocated_email(std::string* email);
  private:
  const std::string& _internal_email() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_email(const std::string& value);
  std::string* _internal_mutable_email();
  public:

  // string verification_code = 5;
  void clear_verification_code();
  const std::string& verification_code() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_verification_code(ArgT0&& arg0, ArgT... args);
  std::string* mutable_verification_code();
  PROTOBUF_NODISCARD std::string* release_verification_code();
  void set_allocated_verification_code(std::string* verification_code);
  private:
  const std::string& _internal_verification_code() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_verification_code(const std::string& value);
  std::string* _internal_mutable_verification_code();
  public:

  // .kservice.EventHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::kservice::EventHeader& header() const;
  PROTOBUF_NODISCARD ::kservice::EventHeader* release_header();
  ::kservice::EventHeader* mutable_header();
  void set_allocated_header(::kservice::EventHeader* header);
  private:
  const ::kservice::EventHeader& _internal_header() const;
  ::kservice::EventHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::kservice::EventHeader* header);
  ::kservice::EventHeader* unsafe_arena_release_header();

  // @@protoc_insertion_point(class_scope:kservice.RegisterRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr username_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr password_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr email_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr verification_code_;
    ::kservice::EventHeader* header_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Service_2fpb_2fservice_2eproto;
};
// -------------------------------------------------------------------

class RegisterResponse final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:kservice.RegisterResponse) */ {
 public:
  inline RegisterResponse() : RegisterResponse(nullptr) {}
  ~RegisterResponse() override;
  explicit PROTOBUF_CONSTEXPR RegisterResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RegisterResponse(const RegisterResponse& from);
  RegisterResponse(RegisterResponse&& from) noexcept
    : RegisterResponse() {
    *this = ::std::move(from);
  }

  inline RegisterResponse& operator=(const RegisterResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline RegisterResponse& operator=(RegisterResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const RegisterResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const RegisterResponse* internal_default_instance() {
    return reinterpret_cast<const RegisterResponse*>(
               &_RegisterResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(RegisterResponse& a, RegisterResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(RegisterResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RegisterResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RegisterResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RegisterResponse>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const RegisterResponse& from);
  void MergeFrom(const RegisterResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RegisterResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "kservice.RegisterResponse";
  }
  protected:
  explicit RegisterResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUidFieldNumber = 2,
    kUsernameFieldNumber = 3,
    kEmailFieldNumber = 4,
    kHeaderFieldNumber = 1,
  };
  // string uid = 2;
  void clear_uid();
  const std::string& uid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_uid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_uid();
  PROTOBUF_NODISCARD std::string* release_uid();
  void set_allocated_uid(std::string* uid);
  private:
  const std::string& _internal_uid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_uid(const std::string& value);
  std::string* _internal_mutable_uid();
  public:

  // string username = 3;
  void clear_username();
  const std::string& username() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_username(ArgT0&& arg0, ArgT... args);
  std::string* mutable_username();
  PROTOBUF_NODISCARD std::string* release_username();
  void set_allocated_username(std::string* username);
  private:
  const std::string& _internal_username() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_username(const std::string& value);
  std::string* _internal_mutable_username();
  public:

  // string email = 4;
  void clear_email();
  const std::string& email() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_email(ArgT0&& arg0, ArgT... args);
  std::string* mutable_email();
  PROTOBUF_NODISCARD std::string* release_email();
  void set_allocated_email(std::string* email);
  private:
  const std::string& _internal_email() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_email(const std::string& value);
  std::string* _internal_mutable_email();
  public:

  // .kservice.ResponseHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::kservice::ResponseHeader& header() const;
  PROTOBUF_NODISCARD ::kservice::ResponseHeader* release_header();
  ::kservice::ResponseHeader* mutable_header();
  void set_allocated_header(::kservice::ResponseHeader* header);
  private:
  const ::kservice::ResponseHeader& _internal_header() const;
  ::kservice::ResponseHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::kservice::ResponseHeader* header);
  ::kservice::ResponseHeader* unsafe_arena_release_header();

  // @@protoc_insertion_point(class_scope:kservice.RegisterResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr uid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr username_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr email_;
    ::kservice::ResponseHeader* header_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Service_2fpb_2fservice_2eproto;
};
// -------------------------------------------------------------------

class LoginRequest final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:kservice.LoginRequest) */ {
 public:
  inline LoginRequest() : LoginRequest(nullptr) {}
  ~LoginRequest() override;
  explicit PROTOBUF_CONSTEXPR LoginRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LoginRequest(const LoginRequest& from);
  LoginRequest(LoginRequest&& from) noexcept
    : LoginRequest() {
    *this = ::std::move(from);
  }

  inline LoginRequest& operator=(const LoginRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline LoginRequest& operator=(LoginRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const LoginRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const LoginRequest* internal_default_instance() {
    return reinterpret_cast<const LoginRequest*>(
               &_LoginRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(LoginRequest& a, LoginRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(LoginRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LoginRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LoginRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LoginRequest>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const LoginRequest& from);
  void MergeFrom(const LoginRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(LoginRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "kservice.LoginRequest";
  }
  protected:
  explicit LoginRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEmailFieldNumber = 2,
    kPasswordFieldNumber = 3,
    kHeaderFieldNumber = 1,
  };
  // string email = 2;
  void clear_email();
  const std::string& email() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_email(ArgT0&& arg0, ArgT... args);
  std::string* mutable_email();
  PROTOBUF_NODISCARD std::string* release_email();
  void set_allocated_email(std::string* email);
  private:
  const std::string& _internal_email() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_email(const std::string& value);
  std::string* _internal_mutable_email();
  public:

  // string password = 3;
  void clear_password();
  const std::string& password() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_password(ArgT0&& arg0, ArgT... args);
  std::string* mutable_password();
  PROTOBUF_NODISCARD std::string* release_password();
  void set_allocated_password(std::string* password);
  private:
  const std::string& _internal_password() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_password(const std::string& value);
  std::string* _internal_mutable_password();
  public:

  // .kservice.EventHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::kservice::EventHeader& header() const;
  PROTOBUF_NODISCARD ::kservice::EventHeader* release_header();
  ::kservice::EventHeader* mutable_header();
  void set_allocated_header(::kservice::EventHeader* header);
  private:
  const ::kservice::EventHeader& _internal_header() const;
  ::kservice::EventHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::kservice::EventHeader* header);
  ::kservice::EventHeader* unsafe_arena_release_header();

  // @@protoc_insertion_point(class_scope:kservice.LoginRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr email_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr password_;
    ::kservice::EventHeader* header_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Service_2fpb_2fservice_2eproto;
};
// -------------------------------------------------------------------

class LoginResponse final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:kservice.LoginResponse) */ {
 public:
  inline LoginResponse() : LoginResponse(nullptr) {}
  ~LoginResponse() override;
  explicit PROTOBUF_CONSTEXPR LoginResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LoginResponse(const LoginResponse& from);
  LoginResponse(LoginResponse&& from) noexcept
    : LoginResponse() {
    *this = ::std::move(from);
  }

  inline LoginResponse& operator=(const LoginResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline LoginResponse& operator=(LoginResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const LoginResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const LoginResponse* internal_default_instance() {
    return reinterpret_cast<const LoginResponse*>(
               &_LoginResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(LoginResponse& a, LoginResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(LoginResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LoginResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LoginResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LoginResponse>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const LoginResponse& from);
  void MergeFrom(const LoginResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(LoginResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "kservice.LoginResponse";
  }
  protected:
  explicit LoginResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUidFieldNumber = 2,
    kUsernameFieldNumber = 3,
    kEmailFieldNumber = 4,
    kAccessTokenFieldNumber = 5,
    kRefreshTokenFieldNumber = 6,
    kHeaderFieldNumber = 1,
  };
  // string uid = 2;
  void clear_uid();
  const std::string& uid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_uid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_uid();
  PROTOBUF_NODISCARD std::string* release_uid();
  void set_allocated_uid(std::string* uid);
  private:
  const std::string& _internal_uid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_uid(const std::string& value);
  std::string* _internal_mutable_uid();
  public:

  // string username = 3;
  void clear_username();
  const std::string& username() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_username(ArgT0&& arg0, ArgT... args);
  std::string* mutable_username();
  PROTOBUF_NODISCARD std::string* release_username();
  void set_allocated_username(std::string* username);
  private:
  const std::string& _internal_username() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_username(const std::string& value);
  std::string* _internal_mutable_username();
  public:

  // string email = 4;
  void clear_email();
  const std::string& email() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_email(ArgT0&& arg0, ArgT... args);
  std::string* mutable_email();
  PROTOBUF_NODISCARD std::string* release_email();
  void set_allocated_email(std::string* email);
  private:
  const std::string& _internal_email() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_email(const std::string& value);
  std::string* _internal_mutable_email();
  public:

  // string access_token = 5;
  void clear_access_token();
  const std::string& access_token() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_access_token(ArgT0&& arg0, ArgT... args);
  std::string* mutable_access_token();
  PROTOBUF_NODISCARD std::string* release_access_token();
  void set_allocated_access_token(std::string* access_token);
  private:
  const std::string& _internal_access_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_access_token(const std::string& value);
  std::string* _internal_mutable_access_token();
  public:

  // string refresh_token = 6;
  void clear_refresh_token();
  const std::string& refresh_token() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_refresh_token(ArgT0&& arg0, ArgT... args);
  std::string* mutable_refresh_token();
  PROTOBUF_NODISCARD std::string* release_refresh_token();
  void set_allocated_refresh_token(std::string* refresh_token);
  private:
  const std::string& _internal_refresh_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_refresh_token(const std::string& value);
  std::string* _internal_mutable_refresh_token();
  public:

  // .kservice.ResponseHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::kservice::ResponseHeader& header() const;
  PROTOBUF_NODISCARD ::kservice::ResponseHeader* release_header();
  ::kservice::ResponseHeader* mutable_header();
  void set_allocated_header(::kservice::ResponseHeader* header);
  private:
  const ::kservice::ResponseHeader& _internal_header() const;
  ::kservice::ResponseHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::kservice::ResponseHeader* header);
  ::kservice::ResponseHeader* unsafe_arena_release_header();

  // @@protoc_insertion_point(class_scope:kservice.LoginResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr uid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr username_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr email_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr access_token_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr refresh_token_;
    ::kservice::ResponseHeader* header_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Service_2fpb_2fservice_2eproto;
};
// -------------------------------------------------------------------

class RefreshRequest final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:kservice.RefreshRequest) */ {
 public:
  inline RefreshRequest() : RefreshRequest(nullptr) {}
  ~RefreshRequest() override;
  explicit PROTOBUF_CONSTEXPR RefreshRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RefreshRequest(const RefreshRequest& from);
  RefreshRequest(RefreshRequest&& from) noexcept
    : RefreshRequest() {
    *this = ::std::move(from);
  }

  inline RefreshRequest& operator=(const RefreshRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline RefreshRequest& operator=(RefreshRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const RefreshRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const RefreshRequest* internal_default_instance() {
    return reinterpret_cast<const RefreshRequest*>(
               &_RefreshRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(RefreshRequest& a, RefreshRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(RefreshRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RefreshRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RefreshRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RefreshRequest>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const RefreshRequest& from);
  void MergeFrom(const RefreshRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RefreshRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "kservice.RefreshRequest";
  }
  protected:
  explicit RefreshRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
  };
  // .kservice.EventHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::kservice::EventHeader& header() const;
  PROTOBUF_NODISCARD ::kservice::EventHeader* release_header();
  ::kservice::EventHeader* mutable_header();
  void set_allocated_header(::kservice::EventHeader* header);
  private:
  const ::kservice::EventHeader& _internal_header() const;
  ::kservice::EventHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::kservice::EventHeader* header);
  ::kservice::EventHeader* unsafe_arena_release_header();

  // @@protoc_insertion_point(class_scope:kservice.RefreshRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::kservice::EventHeader* header_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Service_2fpb_2fservice_2eproto;
};
// -------------------------------------------------------------------

class RefreshResponse final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:kservice.RefreshResponse) */ {
 public:
  inline RefreshResponse() : RefreshResponse(nullptr) {}
  ~RefreshResponse() override;
  explicit PROTOBUF_CONSTEXPR RefreshResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RefreshResponse(const RefreshResponse& from);
  RefreshResponse(RefreshResponse&& from) noexcept
    : RefreshResponse() {
    *this = ::std::move(from);
  }

  inline RefreshResponse& operator=(const RefreshResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline RefreshResponse& operator=(RefreshResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const RefreshResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const RefreshResponse* internal_default_instance() {
    return reinterpret_cast<const RefreshResponse*>(
               &_RefreshResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(RefreshResponse& a, RefreshResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(RefreshResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RefreshResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RefreshResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RefreshResponse>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const RefreshResponse& from);
  void MergeFrom(const RefreshResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RefreshResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "kservice.RefreshResponse";
  }
  protected:
  explicit RefreshResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUidFieldNumber = 2,
    kAccessTokenFieldNumber = 3,
    kHeaderFieldNumber = 1,
  };
  // string uid = 2;
  void clear_uid();
  const std::string& uid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_uid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_uid();
  PROTOBUF_NODISCARD std::string* release_uid();
  void set_allocated_uid(std::string* uid);
  private:
  const std::string& _internal_uid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_uid(const std::string& value);
  std::string* _internal_mutable_uid();
  public:

  // string access_token = 3;
  void clear_access_token();
  const std::string& access_token() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_access_token(ArgT0&& arg0, ArgT... args);
  std::string* mutable_access_token();
  PROTOBUF_NODISCARD std::string* release_access_token();
  void set_allocated_access_token(std::string* access_token);
  private:
  const std::string& _internal_access_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_access_token(const std::string& value);
  std::string* _internal_mutable_access_token();
  public:

  // .kservice.ResponseHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::kservice::ResponseHeader& header() const;
  PROTOBUF_NODISCARD ::kservice::ResponseHeader* release_header();
  ::kservice::ResponseHeader* mutable_header();
  void set_allocated_header(::kservice::ResponseHeader* header);
  private:
  const ::kservice::ResponseHeader& _internal_header() const;
  ::kservice::ResponseHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::kservice::ResponseHeader* header);
  ::kservice::ResponseHeader* unsafe_arena_release_header();

  // @@protoc_insertion_point(class_scope:kservice.RefreshResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr uid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr access_token_;
    ::kservice::ResponseHeader* header_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Service_2fpb_2fservice_2eproto;
};
// -------------------------------------------------------------------

class SendVerificationRequest final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:kservice.SendVerificationRequest) */ {
 public:
  inline SendVerificationRequest() : SendVerificationRequest(nullptr) {}
  ~SendVerificationRequest() override;
  explicit PROTOBUF_CONSTEXPR SendVerificationRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SendVerificationRequest(const SendVerificationRequest& from);
  SendVerificationRequest(SendVerificationRequest&& from) noexcept
    : SendVerificationRequest() {
    *this = ::std::move(from);
  }

  inline SendVerificationRequest& operator=(const SendVerificationRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SendVerificationRequest& operator=(SendVerificationRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const SendVerificationRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SendVerificationRequest* internal_default_instance() {
    return reinterpret_cast<const SendVerificationRequest*>(
               &_SendVerificationRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(SendVerificationRequest& a, SendVerificationRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SendVerificationRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SendVerificationRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SendVerificationRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SendVerificationRequest>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const SendVerificationRequest& from);
  void MergeFrom(const SendVerificationRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SendVerificationRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "kservice.SendVerificationRequest";
  }
  protected:
  explicit SendVerificationRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEmailFieldNumber = 2,
    kHeaderFieldNumber = 1,
  };
  // string email = 2;
  void clear_email();
  const std::string& email() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_email(ArgT0&& arg0, ArgT... args);
  std::string* mutable_email();
  PROTOBUF_NODISCARD std::string* release_email();
  void set_allocated_email(std::string* email);
  private:
  const std::string& _internal_email() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_email(const std::string& value);
  std::string* _internal_mutable_email();
  public:

  // .kservice.EventHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::kservice::EventHeader& header() const;
  PROTOBUF_NODISCARD ::kservice::EventHeader* release_header();
  ::kservice::EventHeader* mutable_header();
  void set_allocated_header(::kservice::EventHeader* header);
  private:
  const ::kservice::EventHeader& _internal_header() const;
  ::kservice::EventHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::kservice::EventHeader* header);
  ::kservice::EventHeader* unsafe_arena_release_header();

  // @@protoc_insertion_point(class_scope:kservice.SendVerificationRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr email_;
    ::kservice::EventHeader* header_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Service_2fpb_2fservice_2eproto;
};
// -------------------------------------------------------------------

class SendVerificationResponse final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:kservice.SendVerificationResponse) */ {
 public:
  inline SendVerificationResponse() : SendVerificationResponse(nullptr) {}
  ~SendVerificationResponse() override;
  explicit PROTOBUF_CONSTEXPR SendVerificationResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SendVerificationResponse(const SendVerificationResponse& from);
  SendVerificationResponse(SendVerificationResponse&& from) noexcept
    : SendVerificationResponse() {
    *this = ::std::move(from);
  }

  inline SendVerificationResponse& operator=(const SendVerificationResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline SendVerificationResponse& operator=(SendVerificationResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const SendVerificationResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const SendVerificationResponse* internal_default_instance() {
    return reinterpret_cast<const SendVerificationResponse*>(
               &_SendVerificationResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(SendVerificationResponse& a, SendVerificationResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(SendVerificationResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SendVerificationResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SendVerificationResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SendVerificationResponse>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const SendVerificationResponse& from);
  void MergeFrom(const SendVerificationResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SendVerificationResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "kservice.SendVerificationResponse";
  }
  protected:
  explicit SendVerificationResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
  };
  // .kservice.ResponseHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::kservice::ResponseHeader& header() const;
  PROTOBUF_NODISCARD ::kservice::ResponseHeader* release_header();
  ::kservice::ResponseHeader* mutable_header();
  void set_allocated_header(::kservice::ResponseHeader* header);
  private:
  const ::kservice::ResponseHeader& _internal_header() const;
  ::kservice::ResponseHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::kservice::ResponseHeader* header);
  ::kservice::ResponseHeader* unsafe_arena_release_header();

  // @@protoc_insertion_point(class_scope:kservice.SendVerificationResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::kservice::ResponseHeader* header_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Service_2fpb_2fservice_2eproto;
};
// -------------------------------------------------------------------

class UVEvent_StepTime final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:kservice.UVEvent.StepTime) */ {
 public:
  inline UVEvent_StepTime() : UVEvent_StepTime(nullptr) {}
  ~UVEvent_StepTime() override;
  explicit PROTOBUF_CONSTEXPR UVEvent_StepTime(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UVEvent_StepTime(const UVEvent_StepTime& from);
  UVEvent_StepTime(UVEvent_StepTime&& from) noexcept
    : UVEvent_StepTime() {
    *this = ::std::move(from);
  }

  inline UVEvent_StepTime& operator=(const UVEvent_StepTime& from) {
    CopyFrom(from);
    return *this;
  }
  inline UVEvent_StepTime& operator=(UVEvent_StepTime&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const UVEvent_StepTime& default_instance() {
    return *internal_default_instance();
  }
  static inline const UVEvent_StepTime* internal_default_instance() {
    return reinterpret_cast<const UVEvent_StepTime*>(
               &_UVEvent_StepTime_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(UVEvent_StepTime& a, UVEvent_StepTime& b) {
    a.Swap(&b);
  }
  inline void Swap(UVEvent_StepTime* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UVEvent_StepTime* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UVEvent_StepTime* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UVEvent_StepTime>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const UVEvent_StepTime& from);
  void MergeFrom(const UVEvent_StepTime& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(UVEvent_StepTime* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "kservice.UVEvent.StepTime";
  }
  protected:
  explicit UVEvent_StepTime(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStepFieldNumber = 1,
    kTimeFieldNumber = 2,
  };
  // string step = 1;
  void clear_step();
  const std::string& step() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_step(ArgT0&& arg0, ArgT... args);
  std::string* mutable_step();
  PROTOBUF_NODISCARD std::string* release_step();
  void set_allocated_step(std::string* step);
  private:
  const std::string& _internal_step() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_step(const std::string& value);
  std::string* _internal_mutable_step();
  public:

  // int64 time = 2;
  void clear_time();
  int64_t time() const;
  void set_time(int64_t value);
  private:
  int64_t _internal_time() const;
  void _internal_set_time(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:kservice.UVEvent.StepTime)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr step_;
    int64_t time_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Service_2fpb_2fservice_2eproto;
};
// -------------------------------------------------------------------

class UVEvent final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:kservice.UVEvent) */ {
 public:
  inline UVEvent() : UVEvent(nullptr) {}
  ~UVEvent() override;
  explicit PROTOBUF_CONSTEXPR UVEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UVEvent(const UVEvent& from);
  UVEvent(UVEvent&& from) noexcept
    : UVEvent() {
    *this = ::std::move(from);
  }

  inline UVEvent& operator=(const UVEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline UVEvent& operator=(UVEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const UVEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const UVEvent* internal_default_instance() {
    return reinterpret_cast<const UVEvent*>(
               &_UVEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(UVEvent& a, UVEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(UVEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UVEvent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UVEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UVEvent>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const UVEvent& from);
  void MergeFrom(const UVEvent& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(UVEvent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "kservice.UVEvent";
  }
  protected:
  explicit UVEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef UVEvent_StepTime StepTime;

  // accessors -------------------------------------------------------

  enum : int {
    kStepTimesFieldNumber = 4,
    kHeaderFieldNumber = 1,
    kStartupTsFieldNumber = 3,
    kIsStartupFieldNumber = 2,
  };
  // repeated .kservice.UVEvent.StepTime stepTimes = 4;
  int steptimes_size() const;
  private:
  int _internal_steptimes_size() const;
  public:
  void clear_steptimes();
  ::kservice::UVEvent_StepTime* mutable_steptimes(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::kservice::UVEvent_StepTime >*
      mutable_steptimes();
  private:
  const ::kservice::UVEvent_StepTime& _internal_steptimes(int index) const;
  ::kservice::UVEvent_StepTime* _internal_add_steptimes();
  public:
  const ::kservice::UVEvent_StepTime& steptimes(int index) const;
  ::kservice::UVEvent_StepTime* add_steptimes();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::kservice::UVEvent_StepTime >&
      steptimes() const;

  // .kservice.EventHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::kservice::EventHeader& header() const;
  PROTOBUF_NODISCARD ::kservice::EventHeader* release_header();
  ::kservice::EventHeader* mutable_header();
  void set_allocated_header(::kservice::EventHeader* header);
  private:
  const ::kservice::EventHeader& _internal_header() const;
  ::kservice::EventHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::kservice::EventHeader* header);
  ::kservice::EventHeader* unsafe_arena_release_header();

  // int64 startupTs = 3;
  void clear_startupts();
  int64_t startupts() const;
  void set_startupts(int64_t value);
  private:
  int64_t _internal_startupts() const;
  void _internal_set_startupts(int64_t value);
  public:

  // bool isStartup = 2;
  void clear_isstartup();
  bool isstartup() const;
  void set_isstartup(bool value);
  private:
  bool _internal_isstartup() const;
  void _internal_set_isstartup(bool value);
  public:

  // @@protoc_insertion_point(class_scope:kservice.UVEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::kservice::UVEvent_StepTime > steptimes_;
    ::kservice::EventHeader* header_;
    int64_t startupts_;
    bool isstartup_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Service_2fpb_2fservice_2eproto;
};
// -------------------------------------------------------------------

class UVEventResponse_LatestVersion final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:kservice.UVEventResponse.LatestVersion) */ {
 public:
  inline UVEventResponse_LatestVersion() : UVEventResponse_LatestVersion(nullptr) {}
  ~UVEventResponse_LatestVersion() override;
  explicit PROTOBUF_CONSTEXPR UVEventResponse_LatestVersion(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UVEventResponse_LatestVersion(const UVEventResponse_LatestVersion& from);
  UVEventResponse_LatestVersion(UVEventResponse_LatestVersion&& from) noexcept
    : UVEventResponse_LatestVersion() {
    *this = ::std::move(from);
  }

  inline UVEventResponse_LatestVersion& operator=(const UVEventResponse_LatestVersion& from) {
    CopyFrom(from);
    return *this;
  }
  inline UVEventResponse_LatestVersion& operator=(UVEventResponse_LatestVersion&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const UVEventResponse_LatestVersion& default_instance() {
    return *internal_default_instance();
  }
  static inline const UVEventResponse_LatestVersion* internal_default_instance() {
    return reinterpret_cast<const UVEventResponse_LatestVersion*>(
               &_UVEventResponse_LatestVersion_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(UVEventResponse_LatestVersion& a, UVEventResponse_LatestVersion& b) {
    a.Swap(&b);
  }
  inline void Swap(UVEventResponse_LatestVersion* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UVEventResponse_LatestVersion* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UVEventResponse_LatestVersion* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UVEventResponse_LatestVersion>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const UVEventResponse_LatestVersion& from);
  void MergeFrom(const UVEventResponse_LatestVersion& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(UVEventResponse_LatestVersion* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "kservice.UVEventResponse.LatestVersion";
  }
  protected:
  explicit UVEventResponse_LatestVersion(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUrlFieldNumber = 2,
    kInfoFieldNumber = 3,
    kVersionFieldNumber = 1,
  };
  // string url = 2;
  void clear_url();
  const std::string& url() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_url(ArgT0&& arg0, ArgT... args);
  std::string* mutable_url();
  PROTOBUF_NODISCARD std::string* release_url();
  void set_allocated_url(std::string* url);
  private:
  const std::string& _internal_url() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_url(const std::string& value);
  std::string* _internal_mutable_url();
  public:

  // string info = 3;
  void clear_info();
  const std::string& info() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_info(ArgT0&& arg0, ArgT... args);
  std::string* mutable_info();
  PROTOBUF_NODISCARD std::string* release_info();
  void set_allocated_info(std::string* info);
  private:
  const std::string& _internal_info() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_info(const std::string& value);
  std::string* _internal_mutable_info();
  public:

  // int32 version = 1;
  void clear_version();
  int32_t version() const;
  void set_version(int32_t value);
  private:
  int32_t _internal_version() const;
  void _internal_set_version(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:kservice.UVEventResponse.LatestVersion)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr url_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr info_;
    int32_t version_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Service_2fpb_2fservice_2eproto;
};
// -------------------------------------------------------------------

class UVEventResponse final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:kservice.UVEventResponse) */ {
 public:
  inline UVEventResponse() : UVEventResponse(nullptr) {}
  ~UVEventResponse() override;
  explicit PROTOBUF_CONSTEXPR UVEventResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UVEventResponse(const UVEventResponse& from);
  UVEventResponse(UVEventResponse&& from) noexcept
    : UVEventResponse() {
    *this = ::std::move(from);
  }

  inline UVEventResponse& operator=(const UVEventResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline UVEventResponse& operator=(UVEventResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const UVEventResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const UVEventResponse* internal_default_instance() {
    return reinterpret_cast<const UVEventResponse*>(
               &_UVEventResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(UVEventResponse& a, UVEventResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(UVEventResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UVEventResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UVEventResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UVEventResponse>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const UVEventResponse& from);
  void MergeFrom(const UVEventResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(UVEventResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "kservice.UVEventResponse";
  }
  protected:
  explicit UVEventResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef UVEventResponse_LatestVersion LatestVersion;

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
    kLatestVersionInfoFieldNumber = 2,
  };
  // .kservice.ResponseHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::kservice::ResponseHeader& header() const;
  PROTOBUF_NODISCARD ::kservice::ResponseHeader* release_header();
  ::kservice::ResponseHeader* mutable_header();
  void set_allocated_header(::kservice::ResponseHeader* header);
  private:
  const ::kservice::ResponseHeader& _internal_header() const;
  ::kservice::ResponseHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::kservice::ResponseHeader* header);
  ::kservice::ResponseHeader* unsafe_arena_release_header();

  // .kservice.UVEventResponse.LatestVersion latestVersionInfo = 2;
  bool has_latestversioninfo() const;
  private:
  bool _internal_has_latestversioninfo() const;
  public:
  void clear_latestversioninfo();
  const ::kservice::UVEventResponse_LatestVersion& latestversioninfo() const;
  PROTOBUF_NODISCARD ::kservice::UVEventResponse_LatestVersion* release_latestversioninfo();
  ::kservice::UVEventResponse_LatestVersion* mutable_latestversioninfo();
  void set_allocated_latestversioninfo(::kservice::UVEventResponse_LatestVersion* latestversioninfo);
  private:
  const ::kservice::UVEventResponse_LatestVersion& _internal_latestversioninfo() const;
  ::kservice::UVEventResponse_LatestVersion* _internal_mutable_latestversioninfo();
  public:
  void unsafe_arena_set_allocated_latestversioninfo(
      ::kservice::UVEventResponse_LatestVersion* latestversioninfo);
  ::kservice::UVEventResponse_LatestVersion* unsafe_arena_release_latestversioninfo();

  // @@protoc_insertion_point(class_scope:kservice.UVEventResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::kservice::ResponseHeader* header_;
    ::kservice::UVEventResponse_LatestVersion* latestversioninfo_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Service_2fpb_2fservice_2eproto;
};
// -------------------------------------------------------------------

class KFileInfo final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:kservice.KFileInfo) */ {
 public:
  inline KFileInfo() : KFileInfo(nullptr) {}
  ~KFileInfo() override;
  explicit PROTOBUF_CONSTEXPR KFileInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  KFileInfo(const KFileInfo& from);
  KFileInfo(KFileInfo&& from) noexcept
    : KFileInfo() {
    *this = ::std::move(from);
  }

  inline KFileInfo& operator=(const KFileInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline KFileInfo& operator=(KFileInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const KFileInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const KFileInfo* internal_default_instance() {
    return reinterpret_cast<const KFileInfo*>(
               &_KFileInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(KFileInfo& a, KFileInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(KFileInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(KFileInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  KFileInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<KFileInfo>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const KFileInfo& from);
  void MergeFrom(const KFileInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(KFileInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "kservice.KFileInfo";
  }
  protected:
  explicit KFileInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFileNameFieldNumber = 1,
    kFullPathFieldNumber = 2,
    kHash32FieldNumber = 3,
    kTorrentHashFieldNumber = 4,
    kUrlFieldNumber = 5,
    kDurationMsFieldNumber = 6,
    kFileSizeFieldNumber = 7,
    kIsLocalFieldNumber = 8,
  };
  // string fileName = 1;
  void clear_filename();
  const std::string& filename() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_filename(ArgT0&& arg0, ArgT... args);
  std::string* mutable_filename();
  PROTOBUF_NODISCARD std::string* release_filename();
  void set_allocated_filename(std::string* filename);
  private:
  const std::string& _internal_filename() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_filename(const std::string& value);
  std::string* _internal_mutable_filename();
  public:

  // string fullPath = 2;
  void clear_fullpath();
  const std::string& fullpath() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_fullpath(ArgT0&& arg0, ArgT... args);
  std::string* mutable_fullpath();
  PROTOBUF_NODISCARD std::string* release_fullpath();
  void set_allocated_fullpath(std::string* fullpath);
  private:
  const std::string& _internal_fullpath() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_fullpath(const std::string& value);
  std::string* _internal_mutable_fullpath();
  public:

  // string hash32 = 3;
  void clear_hash32();
  const std::string& hash32() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_hash32(ArgT0&& arg0, ArgT... args);
  std::string* mutable_hash32();
  PROTOBUF_NODISCARD std::string* release_hash32();
  void set_allocated_hash32(std::string* hash32);
  private:
  const std::string& _internal_hash32() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_hash32(const std::string& value);
  std::string* _internal_mutable_hash32();
  public:

  // string torrentHash = 4;
  void clear_torrenthash();
  const std::string& torrenthash() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_torrenthash(ArgT0&& arg0, ArgT... args);
  std::string* mutable_torrenthash();
  PROTOBUF_NODISCARD std::string* release_torrenthash();
  void set_allocated_torrenthash(std::string* torrenthash);
  private:
  const std::string& _internal_torrenthash() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_torrenthash(const std::string& value);
  std::string* _internal_mutable_torrenthash();
  public:

  // string url = 5;
  void clear_url();
  const std::string& url() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_url(ArgT0&& arg0, ArgT... args);
  std::string* mutable_url();
  PROTOBUF_NODISCARD std::string* release_url();
  void set_allocated_url(std::string* url);
  private:
  const std::string& _internal_url() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_url(const std::string& value);
  std::string* _internal_mutable_url();
  public:

  // int64 durationMs = 6;
  void clear_durationms();
  int64_t durationms() const;
  void set_durationms(int64_t value);
  private:
  int64_t _internal_durationms() const;
  void _internal_set_durationms(int64_t value);
  public:

  // int64 fileSize = 7;
  void clear_filesize();
  int64_t filesize() const;
  void set_filesize(int64_t value);
  private:
  int64_t _internal_filesize() const;
  void _internal_set_filesize(int64_t value);
  public:

  // bool isLocal = 8;
  void clear_islocal();
  bool islocal() const;
  void set_islocal(bool value);
  private:
  bool _internal_islocal() const;
  void _internal_set_islocal(bool value);
  public:

  // @@protoc_insertion_point(class_scope:kservice.KFileInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr filename_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr fullpath_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr hash32_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr torrenthash_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr url_;
    int64_t durationms_;
    int64_t filesize_;
    bool islocal_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Service_2fpb_2fservice_2eproto;
};
// -------------------------------------------------------------------

class RecoRequest final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:kservice.RecoRequest) */ {
 public:
  inline RecoRequest() : RecoRequest(nullptr) {}
  ~RecoRequest() override;
  explicit PROTOBUF_CONSTEXPR RecoRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RecoRequest(const RecoRequest& from);
  RecoRequest(RecoRequest&& from) noexcept
    : RecoRequest() {
    *this = ::std::move(from);
  }

  inline RecoRequest& operator=(const RecoRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline RecoRequest& operator=(RecoRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const RecoRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const RecoRequest* internal_default_instance() {
    return reinterpret_cast<const RecoRequest*>(
               &_RecoRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(RecoRequest& a, RecoRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(RecoRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RecoRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RecoRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RecoRequest>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const RecoRequest& from);
  void MergeFrom(const RecoRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RecoRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "kservice.RecoRequest";
  }
  protected:
  explicit RecoRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
    kFileInfoFieldNumber = 2,
  };
  // .kservice.EventHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::kservice::EventHeader& header() const;
  PROTOBUF_NODISCARD ::kservice::EventHeader* release_header();
  ::kservice::EventHeader* mutable_header();
  void set_allocated_header(::kservice::EventHeader* header);
  private:
  const ::kservice::EventHeader& _internal_header() const;
  ::kservice::EventHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::kservice::EventHeader* header);
  ::kservice::EventHeader* unsafe_arena_release_header();

  // .kservice.KFileInfo fileInfo = 2;
  bool has_fileinfo() const;
  private:
  bool _internal_has_fileinfo() const;
  public:
  void clear_fileinfo();
  const ::kservice::KFileInfo& fileinfo() const;
  PROTOBUF_NODISCARD ::kservice::KFileInfo* release_fileinfo();
  ::kservice::KFileInfo* mutable_fileinfo();
  void set_allocated_fileinfo(::kservice::KFileInfo* fileinfo);
  private:
  const ::kservice::KFileInfo& _internal_fileinfo() const;
  ::kservice::KFileInfo* _internal_mutable_fileinfo();
  public:
  void unsafe_arena_set_allocated_fileinfo(
      ::kservice::KFileInfo* fileinfo);
  ::kservice::KFileInfo* unsafe_arena_release_fileinfo();

  // @@protoc_insertion_point(class_scope:kservice.RecoRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::kservice::EventHeader* header_;
    ::kservice::KFileInfo* fileinfo_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Service_2fpb_2fservice_2eproto;
};
// -------------------------------------------------------------------

class DanmuSource final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:kservice.DanmuSource) */ {
 public:
  inline DanmuSource() : DanmuSource(nullptr) {}
  ~DanmuSource() override;
  explicit PROTOBUF_CONSTEXPR DanmuSource(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DanmuSource(const DanmuSource& from);
  DanmuSource(DanmuSource&& from) noexcept
    : DanmuSource() {
    *this = ::std::move(from);
  }

  inline DanmuSource& operator=(const DanmuSource& from) {
    CopyFrom(from);
    return *this;
  }
  inline DanmuSource& operator=(DanmuSource&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const DanmuSource& default_instance() {
    return *internal_default_instance();
  }
  static inline const DanmuSource* internal_default_instance() {
    return reinterpret_cast<const DanmuSource*>(
               &_DanmuSource_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(DanmuSource& a, DanmuSource& b) {
    a.Swap(&b);
  }
  inline void Swap(DanmuSource* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DanmuSource* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DanmuSource* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DanmuSource>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const DanmuSource& from);
  void MergeFrom(const DanmuSource& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DanmuSource* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "kservice.DanmuSource";
  }
  protected:
  explicit DanmuSource(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTitleFieldNumber = 2,
    kScriptIdFieldNumber = 3,
    kScriptDataFieldNumber = 4,
    kTypeFieldNumber = 1,
    kDurationSecondsFieldNumber = 5,
  };
  // string title = 2;
  void clear_title();
  const std::string& title() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_title(ArgT0&& arg0, ArgT... args);
  std::string* mutable_title();
  PROTOBUF_NODISCARD std::string* release_title();
  void set_allocated_title(std::string* title);
  private:
  const std::string& _internal_title() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_title(const std::string& value);
  std::string* _internal_mutable_title();
  public:

  // string scriptId = 3;
  void clear_scriptid();
  const std::string& scriptid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_scriptid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_scriptid();
  PROTOBUF_NODISCARD std::string* release_scriptid();
  void set_allocated_scriptid(std::string* scriptid);
  private:
  const std::string& _internal_scriptid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_scriptid(const std::string& value);
  std::string* _internal_mutable_scriptid();
  public:

  // string scriptData = 4;
  void clear_scriptdata();
  const std::string& scriptdata() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_scriptdata(ArgT0&& arg0, ArgT... args);
  std::string* mutable_scriptdata();
  PROTOBUF_NODISCARD std::string* release_scriptdata();
  void set_allocated_scriptdata(std::string* scriptdata);
  private:
  const std::string& _internal_scriptdata() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_scriptdata(const std::string& value);
  std::string* _internal_mutable_scriptdata();
  public:

  // .kservice.DanmuSourceType type = 1;
  void clear_type();
  ::kservice::DanmuSourceType type() const;
  void set_type(::kservice::DanmuSourceType value);
  private:
  ::kservice::DanmuSourceType _internal_type() const;
  void _internal_set_type(::kservice::DanmuSourceType value);
  public:

  // int32 durationSeconds = 5;
  void clear_durationseconds();
  int32_t durationseconds() const;
  void set_durationseconds(int32_t value);
  private:
  int32_t _internal_durationseconds() const;
  void _internal_set_durationseconds(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:kservice.DanmuSource)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr title_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr scriptid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr scriptdata_;
    int type_;
    int32_t durationseconds_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Service_2fpb_2fservice_2eproto;
};
// -------------------------------------------------------------------

class InfoSource final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:kservice.InfoSource) */ {
 public:
  inline InfoSource() : InfoSource(nullptr) {}
  ~InfoSource() override;
  explicit PROTOBUF_CONSTEXPR InfoSource(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  InfoSource(const InfoSource& from);
  InfoSource(InfoSource&& from) noexcept
    : InfoSource() {
    *this = ::std::move(from);
  }

  inline InfoSource& operator=(const InfoSource& from) {
    CopyFrom(from);
    return *this;
  }
  inline InfoSource& operator=(InfoSource&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const InfoSource& default_instance() {
    return *internal_default_instance();
  }
  static inline const InfoSource* internal_default_instance() {
    return reinterpret_cast<const InfoSource*>(
               &_InfoSource_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(InfoSource& a, InfoSource& b) {
    a.Swap(&b);
  }
  inline void Swap(InfoSource* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InfoSource* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InfoSource* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<InfoSource>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const InfoSource& from);
  void MergeFrom(const InfoSource& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(InfoSource* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "kservice.InfoSource";
  }
  protected:
  explicit InfoSource(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kScriptIdFieldNumber = 2,
    kScriptDataFieldNumber = 3,
    kTypeFieldNumber = 1,
  };
  // string scriptId = 2;
  void clear_scriptid();
  const std::string& scriptid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_scriptid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_scriptid();
  PROTOBUF_NODISCARD std::string* release_scriptid();
  void set_allocated_scriptid(std::string* scriptid);
  private:
  const std::string& _internal_scriptid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_scriptid(const std::string& value);
  std::string* _internal_mutable_scriptid();
  public:

  // string scriptData = 3;
  void clear_scriptdata();
  const std::string& scriptdata() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_scriptdata(ArgT0&& arg0, ArgT... args);
  std::string* mutable_scriptdata();
  PROTOBUF_NODISCARD std::string* release_scriptdata();
  void set_allocated_scriptdata(std::string* scriptdata);
  private:
  const std::string& _internal_scriptdata() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_scriptdata(const std::string& value);
  std::string* _internal_mutable_scriptdata();
  public:

  // .kservice.InfoSourceType type = 1;
  void clear_type();
  ::kservice::InfoSourceType type() const;
  void set_type(::kservice::InfoSourceType value);
  private:
  ::kservice::InfoSourceType _internal_type() const;
  void _internal_set_type(::kservice::InfoSourceType value);
  public:

  // @@protoc_insertion_point(class_scope:kservice.InfoSource)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr scriptid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr scriptdata_;
    int type_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Service_2fpb_2fservice_2eproto;
};
// -------------------------------------------------------------------

class Pool final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:kservice.Pool) */ {
 public:
  inline Pool() : Pool(nullptr) {}
  ~Pool() override;
  explicit PROTOBUF_CONSTEXPR Pool(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Pool(const Pool& from);
  Pool(Pool&& from) noexcept
    : Pool() {
    *this = ::std::move(from);
  }

  inline Pool& operator=(const Pool& from) {
    CopyFrom(from);
    return *this;
  }
  inline Pool& operator=(Pool&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const Pool& default_instance() {
    return *internal_default_instance();
  }
  static inline const Pool* internal_default_instance() {
    return reinterpret_cast<const Pool*>(
               &_Pool_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(Pool& a, Pool& b) {
    a.Swap(&b);
  }
  inline void Swap(Pool* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Pool* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Pool* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Pool>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const Pool& from);
  void MergeFrom(const Pool& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Pool* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "kservice.Pool";
  }
  protected:
  explicit Pool(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kEpNameFieldNumber = 3,
    kPoolidFieldNumber = 5,
    kEpIndexFieldNumber = 4,
    kEpTypeFieldNumber = 2,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string epName = 3;
  void clear_epname();
  const std::string& epname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_epname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_epname();
  PROTOBUF_NODISCARD std::string* release_epname();
  void set_allocated_epname(std::string* epname);
  private:
  const std::string& _internal_epname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_epname(const std::string& value);
  std::string* _internal_mutable_epname();
  public:

  // string poolid = 5;
  void clear_poolid();
  const std::string& poolid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_poolid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_poolid();
  PROTOBUF_NODISCARD std::string* release_poolid();
  void set_allocated_poolid(std::string* poolid);
  private:
  const std::string& _internal_poolid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_poolid(const std::string& value);
  std::string* _internal_mutable_poolid();
  public:

  // double epIndex = 4;
  void clear_epindex();
  double epindex() const;
  void set_epindex(double value);
  private:
  double _internal_epindex() const;
  void _internal_set_epindex(double value);
  public:

  // .kservice.EpType epType = 2;
  void clear_eptype();
  ::kservice::EpType eptype() const;
  void set_eptype(::kservice::EpType value);
  private:
  ::kservice::EpType _internal_eptype() const;
  void _internal_set_eptype(::kservice::EpType value);
  public:

  // @@protoc_insertion_point(class_scope:kservice.Pool)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr epname_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr poolid_;
    double epindex_;
    int eptype_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Service_2fpb_2fservice_2eproto;
};
// -------------------------------------------------------------------

class RecoResponse final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:kservice.RecoResponse) */ {
 public:
  inline RecoResponse() : RecoResponse(nullptr) {}
  ~RecoResponse() override;
  explicit PROTOBUF_CONSTEXPR RecoResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RecoResponse(const RecoResponse& from);
  RecoResponse(RecoResponse&& from) noexcept
    : RecoResponse() {
    *this = ::std::move(from);
  }

  inline RecoResponse& operator=(const RecoResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline RecoResponse& operator=(RecoResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const RecoResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const RecoResponse* internal_default_instance() {
    return reinterpret_cast<const RecoResponse*>(
               &_RecoResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(RecoResponse& a, RecoResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(RecoResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RecoResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RecoResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RecoResponse>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const RecoResponse& from);
  void MergeFrom(const RecoResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RecoResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "kservice.RecoResponse";
  }
  protected:
  explicit RecoResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInfoSourcesFieldNumber = 3,
    kDanmuSourcesFieldNumber = 4,
    kHeaderFieldNumber = 1,
    kMatchResultFieldNumber = 2,
  };
  // repeated .kservice.InfoSource infoSources = 3;
  int infosources_size() const;
  private:
  int _internal_infosources_size() const;
  public:
  void clear_infosources();
  ::kservice::InfoSource* mutable_infosources(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::kservice::InfoSource >*
      mutable_infosources();
  private:
  const ::kservice::InfoSource& _internal_infosources(int index) const;
  ::kservice::InfoSource* _internal_add_infosources();
  public:
  const ::kservice::InfoSource& infosources(int index) const;
  ::kservice::InfoSource* add_infosources();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::kservice::InfoSource >&
      infosources() const;

  // repeated .kservice.DanmuSource danmuSources = 4;
  int danmusources_size() const;
  private:
  int _internal_danmusources_size() const;
  public:
  void clear_danmusources();
  ::kservice::DanmuSource* mutable_danmusources(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::kservice::DanmuSource >*
      mutable_danmusources();
  private:
  const ::kservice::DanmuSource& _internal_danmusources(int index) const;
  ::kservice::DanmuSource* _internal_add_danmusources();
  public:
  const ::kservice::DanmuSource& danmusources(int index) const;
  ::kservice::DanmuSource* add_danmusources();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::kservice::DanmuSource >&
      danmusources() const;

  // .kservice.ResponseHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::kservice::ResponseHeader& header() const;
  PROTOBUF_NODISCARD ::kservice::ResponseHeader* release_header();
  ::kservice::ResponseHeader* mutable_header();
  void set_allocated_header(::kservice::ResponseHeader* header);
  private:
  const ::kservice::ResponseHeader& _internal_header() const;
  ::kservice::ResponseHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::kservice::ResponseHeader* header);
  ::kservice::ResponseHeader* unsafe_arena_release_header();

  // .kservice.Pool matchResult = 2;
  bool has_matchresult() const;
  private:
  bool _internal_has_matchresult() const;
  public:
  void clear_matchresult();
  const ::kservice::Pool& matchresult() const;
  PROTOBUF_NODISCARD ::kservice::Pool* release_matchresult();
  ::kservice::Pool* mutable_matchresult();
  void set_allocated_matchresult(::kservice::Pool* matchresult);
  private:
  const ::kservice::Pool& _internal_matchresult() const;
  ::kservice::Pool* _internal_mutable_matchresult();
  public:
  void unsafe_arena_set_allocated_matchresult(
      ::kservice::Pool* matchresult);
  ::kservice::Pool* unsafe_arena_release_matchresult();

  // @@protoc_insertion_point(class_scope:kservice.RecoResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::kservice::InfoSource > infosources_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::kservice::DanmuSource > danmusources_;
    ::kservice::ResponseHeader* header_;
    ::kservice::Pool* matchresult_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Service_2fpb_2fservice_2eproto;
};
// -------------------------------------------------------------------

class MatchEvent_Match final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:kservice.MatchEvent.Match) */ {
 public:
  inline MatchEvent_Match() : MatchEvent_Match(nullptr) {}
  ~MatchEvent_Match() override;
  explicit PROTOBUF_CONSTEXPR MatchEvent_Match(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MatchEvent_Match(const MatchEvent_Match& from);
  MatchEvent_Match(MatchEvent_Match&& from) noexcept
    : MatchEvent_Match() {
    *this = ::std::move(from);
  }

  inline MatchEvent_Match& operator=(const MatchEvent_Match& from) {
    CopyFrom(from);
    return *this;
  }
  inline MatchEvent_Match& operator=(MatchEvent_Match&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const MatchEvent_Match& default_instance() {
    return *internal_default_instance();
  }
  static inline const MatchEvent_Match* internal_default_instance() {
    return reinterpret_cast<const MatchEvent_Match*>(
               &_MatchEvent_Match_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(MatchEvent_Match& a, MatchEvent_Match& b) {
    a.Swap(&b);
  }
  inline void Swap(MatchEvent_Match* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MatchEvent_Match* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MatchEvent_Match* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MatchEvent_Match>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const MatchEvent_Match& from);
  void MergeFrom(const MatchEvent_Match& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(MatchEvent_Match* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "kservice.MatchEvent.Match";
  }
  protected:
  explicit MatchEvent_Match(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInfoSourcesFieldNumber = 3,
    kFileInfoFieldNumber = 1,
    kPoolInfoFieldNumber = 2,
  };
  // repeated .kservice.InfoSource infoSources = 3;
  int infosources_size() const;
  private:
  int _internal_infosources_size() const;
  public:
  void clear_infosources();
  ::kservice::InfoSource* mutable_infosources(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::kservice::InfoSource >*
      mutable_infosources();
  private:
  const ::kservice::InfoSource& _internal_infosources(int index) const;
  ::kservice::InfoSource* _internal_add_infosources();
  public:
  const ::kservice::InfoSource& infosources(int index) const;
  ::kservice::InfoSource* add_infosources();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::kservice::InfoSource >&
      infosources() const;

  // .kservice.KFileInfo fileInfo = 1;
  bool has_fileinfo() const;
  private:
  bool _internal_has_fileinfo() const;
  public:
  void clear_fileinfo();
  const ::kservice::KFileInfo& fileinfo() const;
  PROTOBUF_NODISCARD ::kservice::KFileInfo* release_fileinfo();
  ::kservice::KFileInfo* mutable_fileinfo();
  void set_allocated_fileinfo(::kservice::KFileInfo* fileinfo);
  private:
  const ::kservice::KFileInfo& _internal_fileinfo() const;
  ::kservice::KFileInfo* _internal_mutable_fileinfo();
  public:
  void unsafe_arena_set_allocated_fileinfo(
      ::kservice::KFileInfo* fileinfo);
  ::kservice::KFileInfo* unsafe_arena_release_fileinfo();

  // .kservice.Pool poolInfo = 2;
  bool has_poolinfo() const;
  private:
  bool _internal_has_poolinfo() const;
  public:
  void clear_poolinfo();
  const ::kservice::Pool& poolinfo() const;
  PROTOBUF_NODISCARD ::kservice::Pool* release_poolinfo();
  ::kservice::Pool* mutable_poolinfo();
  void set_allocated_poolinfo(::kservice::Pool* poolinfo);
  private:
  const ::kservice::Pool& _internal_poolinfo() const;
  ::kservice::Pool* _internal_mutable_poolinfo();
  public:
  void unsafe_arena_set_allocated_poolinfo(
      ::kservice::Pool* poolinfo);
  ::kservice::Pool* unsafe_arena_release_poolinfo();

  // @@protoc_insertion_point(class_scope:kservice.MatchEvent.Match)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::kservice::InfoSource > infosources_;
    ::kservice::KFileInfo* fileinfo_;
    ::kservice::Pool* poolinfo_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Service_2fpb_2fservice_2eproto;
};
// -------------------------------------------------------------------

class MatchEvent final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:kservice.MatchEvent) */ {
 public:
  inline MatchEvent() : MatchEvent(nullptr) {}
  ~MatchEvent() override;
  explicit PROTOBUF_CONSTEXPR MatchEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MatchEvent(const MatchEvent& from);
  MatchEvent(MatchEvent&& from) noexcept
    : MatchEvent() {
    *this = ::std::move(from);
  }

  inline MatchEvent& operator=(const MatchEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline MatchEvent& operator=(MatchEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const MatchEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const MatchEvent* internal_default_instance() {
    return reinterpret_cast<const MatchEvent*>(
               &_MatchEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(MatchEvent& a, MatchEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(MatchEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MatchEvent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MatchEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MatchEvent>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const MatchEvent& from);
  void MergeFrom(const MatchEvent& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(MatchEvent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "kservice.MatchEvent";
  }
  protected:
  explicit MatchEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef MatchEvent_Match Match;

  // accessors -------------------------------------------------------

  enum : int {
    kMatchesFieldNumber = 2,
    kHeaderFieldNumber = 1,
  };
  // repeated .kservice.MatchEvent.Match matches = 2;
  int matches_size() const;
  private:
  int _internal_matches_size() const;
  public:
  void clear_matches();
  ::kservice::MatchEvent_Match* mutable_matches(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::kservice::MatchEvent_Match >*
      mutable_matches();
  private:
  const ::kservice::MatchEvent_Match& _internal_matches(int index) const;
  ::kservice::MatchEvent_Match* _internal_add_matches();
  public:
  const ::kservice::MatchEvent_Match& matches(int index) const;
  ::kservice::MatchEvent_Match* add_matches();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::kservice::MatchEvent_Match >&
      matches() const;

  // .kservice.EventHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::kservice::EventHeader& header() const;
  PROTOBUF_NODISCARD ::kservice::EventHeader* release_header();
  ::kservice::EventHeader* mutable_header();
  void set_allocated_header(::kservice::EventHeader* header);
  private:
  const ::kservice::EventHeader& _internal_header() const;
  ::kservice::EventHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::kservice::EventHeader* header);
  ::kservice::EventHeader* unsafe_arena_release_header();

  // @@protoc_insertion_point(class_scope:kservice.MatchEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::kservice::MatchEvent_Match > matches_;
    ::kservice::EventHeader* header_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Service_2fpb_2fservice_2eproto;
};
// -------------------------------------------------------------------

class AddDanmuSourceEvent_DanmuPoolSource final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:kservice.AddDanmuSourceEvent.DanmuPoolSource) */ {
 public:
  inline AddDanmuSourceEvent_DanmuPoolSource() : AddDanmuSourceEvent_DanmuPoolSource(nullptr) {}
  ~AddDanmuSourceEvent_DanmuPoolSource() override;
  explicit PROTOBUF_CONSTEXPR AddDanmuSourceEvent_DanmuPoolSource(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AddDanmuSourceEvent_DanmuPoolSource(const AddDanmuSourceEvent_DanmuPoolSource& from);
  AddDanmuSourceEvent_DanmuPoolSource(AddDanmuSourceEvent_DanmuPoolSource&& from) noexcept
    : AddDanmuSourceEvent_DanmuPoolSource() {
    *this = ::std::move(from);
  }

  inline AddDanmuSourceEvent_DanmuPoolSource& operator=(const AddDanmuSourceEvent_DanmuPoolSource& from) {
    CopyFrom(from);
    return *this;
  }
  inline AddDanmuSourceEvent_DanmuPoolSource& operator=(AddDanmuSourceEvent_DanmuPoolSource&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const AddDanmuSourceEvent_DanmuPoolSource& default_instance() {
    return *internal_default_instance();
  }
  static inline const AddDanmuSourceEvent_DanmuPoolSource* internal_default_instance() {
    return reinterpret_cast<const AddDanmuSourceEvent_DanmuPoolSource*>(
               &_AddDanmuSourceEvent_DanmuPoolSource_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(AddDanmuSourceEvent_DanmuPoolSource& a, AddDanmuSourceEvent_DanmuPoolSource& b) {
    a.Swap(&b);
  }
  inline void Swap(AddDanmuSourceEvent_DanmuPoolSource* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AddDanmuSourceEvent_DanmuPoolSource* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AddDanmuSourceEvent_DanmuPoolSource* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AddDanmuSourceEvent_DanmuPoolSource>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const AddDanmuSourceEvent_DanmuPoolSource& from);
  void MergeFrom(const AddDanmuSourceEvent_DanmuPoolSource& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(AddDanmuSourceEvent_DanmuPoolSource* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "kservice.AddDanmuSourceEvent.DanmuPoolSource";
  }
  protected:
  explicit AddDanmuSourceEvent_DanmuPoolSource(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDanmuSourcesFieldNumber = 2,
    kPoolInfoFieldNumber = 1,
  };
  // repeated .kservice.DanmuSource danmuSources = 2;
  int danmusources_size() const;
  private:
  int _internal_danmusources_size() const;
  public:
  void clear_danmusources();
  ::kservice::DanmuSource* mutable_danmusources(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::kservice::DanmuSource >*
      mutable_danmusources();
  private:
  const ::kservice::DanmuSource& _internal_danmusources(int index) const;
  ::kservice::DanmuSource* _internal_add_danmusources();
  public:
  const ::kservice::DanmuSource& danmusources(int index) const;
  ::kservice::DanmuSource* add_danmusources();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::kservice::DanmuSource >&
      danmusources() const;

  // .kservice.Pool poolInfo = 1;
  bool has_poolinfo() const;
  private:
  bool _internal_has_poolinfo() const;
  public:
  void clear_poolinfo();
  const ::kservice::Pool& poolinfo() const;
  PROTOBUF_NODISCARD ::kservice::Pool* release_poolinfo();
  ::kservice::Pool* mutable_poolinfo();
  void set_allocated_poolinfo(::kservice::Pool* poolinfo);
  private:
  const ::kservice::Pool& _internal_poolinfo() const;
  ::kservice::Pool* _internal_mutable_poolinfo();
  public:
  void unsafe_arena_set_allocated_poolinfo(
      ::kservice::Pool* poolinfo);
  ::kservice::Pool* unsafe_arena_release_poolinfo();

  // @@protoc_insertion_point(class_scope:kservice.AddDanmuSourceEvent.DanmuPoolSource)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::kservice::DanmuSource > danmusources_;
    ::kservice::Pool* poolinfo_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Service_2fpb_2fservice_2eproto;
};
// -------------------------------------------------------------------

class AddDanmuSourceEvent final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:kservice.AddDanmuSourceEvent) */ {
 public:
  inline AddDanmuSourceEvent() : AddDanmuSourceEvent(nullptr) {}
  ~AddDanmuSourceEvent() override;
  explicit PROTOBUF_CONSTEXPR AddDanmuSourceEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AddDanmuSourceEvent(const AddDanmuSourceEvent& from);
  AddDanmuSourceEvent(AddDanmuSourceEvent&& from) noexcept
    : AddDanmuSourceEvent() {
    *this = ::std::move(from);
  }

  inline AddDanmuSourceEvent& operator=(const AddDanmuSourceEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline AddDanmuSourceEvent& operator=(AddDanmuSourceEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const AddDanmuSourceEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const AddDanmuSourceEvent* internal_default_instance() {
    return reinterpret_cast<const AddDanmuSourceEvent*>(
               &_AddDanmuSourceEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(AddDanmuSourceEvent& a, AddDanmuSourceEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(AddDanmuSourceEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AddDanmuSourceEvent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AddDanmuSourceEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AddDanmuSourceEvent>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const AddDanmuSourceEvent& from);
  void MergeFrom(const AddDanmuSourceEvent& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(AddDanmuSourceEvent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "kservice.AddDanmuSourceEvent";
  }
  protected:
  explicit AddDanmuSourceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef AddDanmuSourceEvent_DanmuPoolSource DanmuPoolSource;

  // accessors -------------------------------------------------------

  enum : int {
    kDanmuPoolSourcesFieldNumber = 2,
    kHeaderFieldNumber = 1,
  };
  // repeated .kservice.AddDanmuSourceEvent.DanmuPoolSource danmuPoolSources = 2;
  int danmupoolsources_size() const;
  private:
  int _internal_danmupoolsources_size() const;
  public:
  void clear_danmupoolsources();
  ::kservice::AddDanmuSourceEvent_DanmuPoolSource* mutable_danmupoolsources(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::kservice::AddDanmuSourceEvent_DanmuPoolSource >*
      mutable_danmupoolsources();
  private:
  const ::kservice::AddDanmuSourceEvent_DanmuPoolSource& _internal_danmupoolsources(int index) const;
  ::kservice::AddDanmuSourceEvent_DanmuPoolSource* _internal_add_danmupoolsources();
  public:
  const ::kservice::AddDanmuSourceEvent_DanmuPoolSource& danmupoolsources(int index) const;
  ::kservice::AddDanmuSourceEvent_DanmuPoolSource* add_danmupoolsources();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::kservice::AddDanmuSourceEvent_DanmuPoolSource >&
      danmupoolsources() const;

  // .kservice.EventHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::kservice::EventHeader& header() const;
  PROTOBUF_NODISCARD ::kservice::EventHeader* release_header();
  ::kservice::EventHeader* mutable_header();
  void set_allocated_header(::kservice::EventHeader* header);
  private:
  const ::kservice::EventHeader& _internal_header() const;
  ::kservice::EventHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::kservice::EventHeader* header);
  ::kservice::EventHeader* unsafe_arena_release_header();

  // @@protoc_insertion_point(class_scope:kservice.AddDanmuSourceEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::kservice::AddDanmuSourceEvent_DanmuPoolSource > danmupoolsources_;
    ::kservice::EventHeader* header_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Service_2fpb_2fservice_2eproto;
};
// -------------------------------------------------------------------

class DanmuComment final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:kservice.DanmuComment) */ {
 public:
  inline DanmuComment() : DanmuComment(nullptr) {}
  ~DanmuComment() override;
  explicit PROTOBUF_CONSTEXPR DanmuComment(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DanmuComment(const DanmuComment& from);
  DanmuComment(DanmuComment&& from) noexcept
    : DanmuComment() {
    *this = ::std::move(from);
  }

  inline DanmuComment& operator=(const DanmuComment& from) {
    CopyFrom(from);
    return *this;
  }
  inline DanmuComment& operator=(DanmuComment&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const DanmuComment& default_instance() {
    return *internal_default_instance();
  }
  static inline const DanmuComment* internal_default_instance() {
    return reinterpret_cast<const DanmuComment*>(
               &_DanmuComment_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(DanmuComment& a, DanmuComment& b) {
    a.Swap(&b);
  }
  inline void Swap(DanmuComment* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DanmuComment* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DanmuComment* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DanmuComment>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const DanmuComment& from);
  void MergeFrom(const DanmuComment& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DanmuComment* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "kservice.DanmuComment";
  }
  protected:
  explicit DanmuComment(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSenderIdFieldNumber = 1,
    kTextFieldNumber = 2,
    kColorFieldNumber = 3,
    kTimeFieldNumber = 4,
    kModeFieldNumber = 5,
    kSizeFieldNumber = 6,
    kTimestampFieldNumber = 7,
  };
  // string senderId = 1;
  void clear_senderid();
  const std::string& senderid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_senderid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_senderid();
  PROTOBUF_NODISCARD std::string* release_senderid();
  void set_allocated_senderid(std::string* senderid);
  private:
  const std::string& _internal_senderid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_senderid(const std::string& value);
  std::string* _internal_mutable_senderid();
  public:

  // string text = 2;
  void clear_text();
  const std::string& text() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_text(ArgT0&& arg0, ArgT... args);
  std::string* mutable_text();
  PROTOBUF_NODISCARD std::string* release_text();
  void set_allocated_text(std::string* text);
  private:
  const std::string& _internal_text() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_text(const std::string& value);
  std::string* _internal_mutable_text();
  public:

  // int32 color = 3;
  void clear_color();
  int32_t color() const;
  void set_color(int32_t value);
  private:
  int32_t _internal_color() const;
  void _internal_set_color(int32_t value);
  public:

  // int32 time = 4;
  void clear_time();
  int32_t time() const;
  void set_time(int32_t value);
  private:
  int32_t _internal_time() const;
  void _internal_set_time(int32_t value);
  public:

  // int32 mode = 5;
  void clear_mode();
  int32_t mode() const;
  void set_mode(int32_t value);
  private:
  int32_t _internal_mode() const;
  void _internal_set_mode(int32_t value);
  public:

  // int32 size = 6;
  void clear_size();
  int32_t size() const;
  void set_size(int32_t value);
  private:
  int32_t _internal_size() const;
  void _internal_set_size(int32_t value);
  public:

  // int64 timestamp = 7;
  void clear_timestamp();
  int64_t timestamp() const;
  void set_timestamp(int64_t value);
  private:
  int64_t _internal_timestamp() const;
  void _internal_set_timestamp(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:kservice.DanmuComment)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr senderid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr text_;
    int32_t color_;
    int32_t time_;
    int32_t mode_;
    int32_t size_;
    int64_t timestamp_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Service_2fpb_2fservice_2eproto;
};
// -------------------------------------------------------------------

class LaunchRequest final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:kservice.LaunchRequest) */ {
 public:
  inline LaunchRequest() : LaunchRequest(nullptr) {}
  ~LaunchRequest() override;
  explicit PROTOBUF_CONSTEXPR LaunchRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LaunchRequest(const LaunchRequest& from);
  LaunchRequest(LaunchRequest&& from) noexcept
    : LaunchRequest() {
    *this = ::std::move(from);
  }

  inline LaunchRequest& operator=(const LaunchRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline LaunchRequest& operator=(LaunchRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const LaunchRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const LaunchRequest* internal_default_instance() {
    return reinterpret_cast<const LaunchRequest*>(
               &_LaunchRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(LaunchRequest& a, LaunchRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(LaunchRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LaunchRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LaunchRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LaunchRequest>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const LaunchRequest& from);
  void MergeFrom(const LaunchRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(LaunchRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "kservice.LaunchRequest";
  }
  protected:
  explicit LaunchRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
    kPoolInfoFieldNumber = 2,
    kFileInfoFieldNumber = 3,
    kCommentFieldNumber = 4,
  };
  // .kservice.EventHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::kservice::EventHeader& header() const;
  PROTOBUF_NODISCARD ::kservice::EventHeader* release_header();
  ::kservice::EventHeader* mutable_header();
  void set_allocated_header(::kservice::EventHeader* header);
  private:
  const ::kservice::EventHeader& _internal_header() const;
  ::kservice::EventHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::kservice::EventHeader* header);
  ::kservice::EventHeader* unsafe_arena_release_header();

  // .kservice.Pool poolInfo = 2;
  bool has_poolinfo() const;
  private:
  bool _internal_has_poolinfo() const;
  public:
  void clear_poolinfo();
  const ::kservice::Pool& poolinfo() const;
  PROTOBUF_NODISCARD ::kservice::Pool* release_poolinfo();
  ::kservice::Pool* mutable_poolinfo();
  void set_allocated_poolinfo(::kservice::Pool* poolinfo);
  private:
  const ::kservice::Pool& _internal_poolinfo() const;
  ::kservice::Pool* _internal_mutable_poolinfo();
  public:
  void unsafe_arena_set_allocated_poolinfo(
      ::kservice::Pool* poolinfo);
  ::kservice::Pool* unsafe_arena_release_poolinfo();

  // .kservice.KFileInfo fileInfo = 3;
  bool has_fileinfo() const;
  private:
  bool _internal_has_fileinfo() const;
  public:
  void clear_fileinfo();
  const ::kservice::KFileInfo& fileinfo() const;
  PROTOBUF_NODISCARD ::kservice::KFileInfo* release_fileinfo();
  ::kservice::KFileInfo* mutable_fileinfo();
  void set_allocated_fileinfo(::kservice::KFileInfo* fileinfo);
  private:
  const ::kservice::KFileInfo& _internal_fileinfo() const;
  ::kservice::KFileInfo* _internal_mutable_fileinfo();
  public:
  void unsafe_arena_set_allocated_fileinfo(
      ::kservice::KFileInfo* fileinfo);
  ::kservice::KFileInfo* unsafe_arena_release_fileinfo();

  // .kservice.DanmuComment comment = 4;
  bool has_comment() const;
  private:
  bool _internal_has_comment() const;
  public:
  void clear_comment();
  const ::kservice::DanmuComment& comment() const;
  PROTOBUF_NODISCARD ::kservice::DanmuComment* release_comment();
  ::kservice::DanmuComment* mutable_comment();
  void set_allocated_comment(::kservice::DanmuComment* comment);
  private:
  const ::kservice::DanmuComment& _internal_comment() const;
  ::kservice::DanmuComment* _internal_mutable_comment();
  public:
  void unsafe_arena_set_allocated_comment(
      ::kservice::DanmuComment* comment);
  ::kservice::DanmuComment* unsafe_arena_release_comment();

  // @@protoc_insertion_point(class_scope:kservice.LaunchRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::kservice::EventHeader* header_;
    ::kservice::Pool* poolinfo_;
    ::kservice::KFileInfo* fileinfo_;
    ::kservice::DanmuComment* comment_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Service_2fpb_2fservice_2eproto;
};
// -------------------------------------------------------------------

class LaunchResponse final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:kservice.LaunchResponse) */ {
 public:
  inline LaunchResponse() : LaunchResponse(nullptr) {}
  ~LaunchResponse() override;
  explicit PROTOBUF_CONSTEXPR LaunchResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LaunchResponse(const LaunchResponse& from);
  LaunchResponse(LaunchResponse&& from) noexcept
    : LaunchResponse() {
    *this = ::std::move(from);
  }

  inline LaunchResponse& operator=(const LaunchResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline LaunchResponse& operator=(LaunchResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const LaunchResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const LaunchResponse* internal_default_instance() {
    return reinterpret_cast<const LaunchResponse*>(
               &_LaunchResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(LaunchResponse& a, LaunchResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(LaunchResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LaunchResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LaunchResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LaunchResponse>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const LaunchResponse& from);
  void MergeFrom(const LaunchResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(LaunchResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "kservice.LaunchResponse";
  }
  protected:
  explicit LaunchResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPoolIdFieldNumber = 2,
    kHeaderFieldNumber = 1,
    kDanmuSourceFieldNumber = 3,
    kCommentFieldNumber = 4,
  };
  // string poolId = 2;
  void clear_poolid();
  const std::string& poolid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_poolid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_poolid();
  PROTOBUF_NODISCARD std::string* release_poolid();
  void set_allocated_poolid(std::string* poolid);
  private:
  const std::string& _internal_poolid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_poolid(const std::string& value);
  std::string* _internal_mutable_poolid();
  public:

  // .kservice.ResponseHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::kservice::ResponseHeader& header() const;
  PROTOBUF_NODISCARD ::kservice::ResponseHeader* release_header();
  ::kservice::ResponseHeader* mutable_header();
  void set_allocated_header(::kservice::ResponseHeader* header);
  private:
  const ::kservice::ResponseHeader& _internal_header() const;
  ::kservice::ResponseHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::kservice::ResponseHeader* header);
  ::kservice::ResponseHeader* unsafe_arena_release_header();

  // .kservice.DanmuSource danmuSource = 3;
  bool has_danmusource() const;
  private:
  bool _internal_has_danmusource() const;
  public:
  void clear_danmusource();
  const ::kservice::DanmuSource& danmusource() const;
  PROTOBUF_NODISCARD ::kservice::DanmuSource* release_danmusource();
  ::kservice::DanmuSource* mutable_danmusource();
  void set_allocated_danmusource(::kservice::DanmuSource* danmusource);
  private:
  const ::kservice::DanmuSource& _internal_danmusource() const;
  ::kservice::DanmuSource* _internal_mutable_danmusource();
  public:
  void unsafe_arena_set_allocated_danmusource(
      ::kservice::DanmuSource* danmusource);
  ::kservice::DanmuSource* unsafe_arena_release_danmusource();

  // .kservice.DanmuComment comment = 4;
  bool has_comment() const;
  private:
  bool _internal_has_comment() const;
  public:
  void clear_comment();
  const ::kservice::DanmuComment& comment() const;
  PROTOBUF_NODISCARD ::kservice::DanmuComment* release_comment();
  ::kservice::DanmuComment* mutable_comment();
  void set_allocated_comment(::kservice::DanmuComment* comment);
  private:
  const ::kservice::DanmuComment& _internal_comment() const;
  ::kservice::DanmuComment* _internal_mutable_comment();
  public:
  void unsafe_arena_set_allocated_comment(
      ::kservice::DanmuComment* comment);
  ::kservice::DanmuComment* unsafe_arena_release_comment();

  // @@protoc_insertion_point(class_scope:kservice.LaunchResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr poolid_;
    ::kservice::ResponseHeader* header_;
    ::kservice::DanmuSource* danmusource_;
    ::kservice::DanmuComment* comment_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Service_2fpb_2fservice_2eproto;
};
// -------------------------------------------------------------------

class KikoDanmuRequest final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:kservice.KikoDanmuRequest) */ {
 public:
  inline KikoDanmuRequest() : KikoDanmuRequest(nullptr) {}
  ~KikoDanmuRequest() override;
  explicit PROTOBUF_CONSTEXPR KikoDanmuRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  KikoDanmuRequest(const KikoDanmuRequest& from);
  KikoDanmuRequest(KikoDanmuRequest&& from) noexcept
    : KikoDanmuRequest() {
    *this = ::std::move(from);
  }

  inline KikoDanmuRequest& operator=(const KikoDanmuRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline KikoDanmuRequest& operator=(KikoDanmuRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const KikoDanmuRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const KikoDanmuRequest* internal_default_instance() {
    return reinterpret_cast<const KikoDanmuRequest*>(
               &_KikoDanmuRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  friend void swap(KikoDanmuRequest& a, KikoDanmuRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(KikoDanmuRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(KikoDanmuRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  KikoDanmuRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<KikoDanmuRequest>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const KikoDanmuRequest& from);
  void MergeFrom(const KikoDanmuRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(KikoDanmuRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "kservice.KikoDanmuRequest";
  }
  protected:
  explicit KikoDanmuRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
    kPoolInfoFieldNumber = 2,
    kDurationFieldNumber = 3,
  };
  // .kservice.EventHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::kservice::EventHeader& header() const;
  PROTOBUF_NODISCARD ::kservice::EventHeader* release_header();
  ::kservice::EventHeader* mutable_header();
  void set_allocated_header(::kservice::EventHeader* header);
  private:
  const ::kservice::EventHeader& _internal_header() const;
  ::kservice::EventHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::kservice::EventHeader* header);
  ::kservice::EventHeader* unsafe_arena_release_header();

  // .kservice.Pool poolInfo = 2;
  bool has_poolinfo() const;
  private:
  bool _internal_has_poolinfo() const;
  public:
  void clear_poolinfo();
  const ::kservice::Pool& poolinfo() const;
  PROTOBUF_NODISCARD ::kservice::Pool* release_poolinfo();
  ::kservice::Pool* mutable_poolinfo();
  void set_allocated_poolinfo(::kservice::Pool* poolinfo);
  private:
  const ::kservice::Pool& _internal_poolinfo() const;
  ::kservice::Pool* _internal_mutable_poolinfo();
  public:
  void unsafe_arena_set_allocated_poolinfo(
      ::kservice::Pool* poolinfo);
  ::kservice::Pool* unsafe_arena_release_poolinfo();

  // int32 duration = 3;
  void clear_duration();
  int32_t duration() const;
  void set_duration(int32_t value);
  private:
  int32_t _internal_duration() const;
  void _internal_set_duration(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:kservice.KikoDanmuRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::kservice::EventHeader* header_;
    ::kservice::Pool* poolinfo_;
    int32_t duration_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Service_2fpb_2fservice_2eproto;
};
// -------------------------------------------------------------------

class KikoDanmuResponse_DanmuSourceComments final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:kservice.KikoDanmuResponse.DanmuSourceComments) */ {
 public:
  inline KikoDanmuResponse_DanmuSourceComments() : KikoDanmuResponse_DanmuSourceComments(nullptr) {}
  ~KikoDanmuResponse_DanmuSourceComments() override;
  explicit PROTOBUF_CONSTEXPR KikoDanmuResponse_DanmuSourceComments(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  KikoDanmuResponse_DanmuSourceComments(const KikoDanmuResponse_DanmuSourceComments& from);
  KikoDanmuResponse_DanmuSourceComments(KikoDanmuResponse_DanmuSourceComments&& from) noexcept
    : KikoDanmuResponse_DanmuSourceComments() {
    *this = ::std::move(from);
  }

  inline KikoDanmuResponse_DanmuSourceComments& operator=(const KikoDanmuResponse_DanmuSourceComments& from) {
    CopyFrom(from);
    return *this;
  }
  inline KikoDanmuResponse_DanmuSourceComments& operator=(KikoDanmuResponse_DanmuSourceComments&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const KikoDanmuResponse_DanmuSourceComments& default_instance() {
    return *internal_default_instance();
  }
  static inline const KikoDanmuResponse_DanmuSourceComments* internal_default_instance() {
    return reinterpret_cast<const KikoDanmuResponse_DanmuSourceComments*>(
               &_KikoDanmuResponse_DanmuSourceComments_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  friend void swap(KikoDanmuResponse_DanmuSourceComments& a, KikoDanmuResponse_DanmuSourceComments& b) {
    a.Swap(&b);
  }
  inline void Swap(KikoDanmuResponse_DanmuSourceComments* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(KikoDanmuResponse_DanmuSourceComments* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  KikoDanmuResponse_DanmuSourceComments* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<KikoDanmuResponse_DanmuSourceComments>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const KikoDanmuResponse_DanmuSourceComments& from);
  void MergeFrom(const KikoDanmuResponse_DanmuSourceComments& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(KikoDanmuResponse_DanmuSourceComments* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "kservice.KikoDanmuResponse.DanmuSourceComments";
  }
  protected:
  explicit KikoDanmuResponse_DanmuSourceComments(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDanmuCommentsFieldNumber = 2,
    kSourceFieldNumber = 1,
  };
  // repeated .kservice.DanmuComment danmuComments = 2;
  int danmucomments_size() const;
  private:
  int _internal_danmucomments_size() const;
  public:
  void clear_danmucomments();
  ::kservice::DanmuComment* mutable_danmucomments(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::kservice::DanmuComment >*
      mutable_danmucomments();
  private:
  const ::kservice::DanmuComment& _internal_danmucomments(int index) const;
  ::kservice::DanmuComment* _internal_add_danmucomments();
  public:
  const ::kservice::DanmuComment& danmucomments(int index) const;
  ::kservice::DanmuComment* add_danmucomments();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::kservice::DanmuComment >&
      danmucomments() const;

  // .kservice.DanmuSource source = 1;
  bool has_source() const;
  private:
  bool _internal_has_source() const;
  public:
  void clear_source();
  const ::kservice::DanmuSource& source() const;
  PROTOBUF_NODISCARD ::kservice::DanmuSource* release_source();
  ::kservice::DanmuSource* mutable_source();
  void set_allocated_source(::kservice::DanmuSource* source);
  private:
  const ::kservice::DanmuSource& _internal_source() const;
  ::kservice::DanmuSource* _internal_mutable_source();
  public:
  void unsafe_arena_set_allocated_source(
      ::kservice::DanmuSource* source);
  ::kservice::DanmuSource* unsafe_arena_release_source();

  // @@protoc_insertion_point(class_scope:kservice.KikoDanmuResponse.DanmuSourceComments)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::kservice::DanmuComment > danmucomments_;
    ::kservice::DanmuSource* source_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Service_2fpb_2fservice_2eproto;
};
// -------------------------------------------------------------------

class KikoDanmuResponse final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:kservice.KikoDanmuResponse) */ {
 public:
  inline KikoDanmuResponse() : KikoDanmuResponse(nullptr) {}
  ~KikoDanmuResponse() override;
  explicit PROTOBUF_CONSTEXPR KikoDanmuResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  KikoDanmuResponse(const KikoDanmuResponse& from);
  KikoDanmuResponse(KikoDanmuResponse&& from) noexcept
    : KikoDanmuResponse() {
    *this = ::std::move(from);
  }

  inline KikoDanmuResponse& operator=(const KikoDanmuResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline KikoDanmuResponse& operator=(KikoDanmuResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const KikoDanmuResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const KikoDanmuResponse* internal_default_instance() {
    return reinterpret_cast<const KikoDanmuResponse*>(
               &_KikoDanmuResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  friend void swap(KikoDanmuResponse& a, KikoDanmuResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(KikoDanmuResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(KikoDanmuResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  KikoDanmuResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<KikoDanmuResponse>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const KikoDanmuResponse& from);
  void MergeFrom(const KikoDanmuResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(KikoDanmuResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "kservice.KikoDanmuResponse";
  }
  protected:
  explicit KikoDanmuResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef KikoDanmuResponse_DanmuSourceComments DanmuSourceComments;

  // accessors -------------------------------------------------------

  enum : int {
    kDanmuSourcesFieldNumber = 3,
    kHeaderFieldNumber = 1,
    kPoolInfoFieldNumber = 2,
  };
  // repeated .kservice.KikoDanmuResponse.DanmuSourceComments danmuSources = 3;
  int danmusources_size() const;
  private:
  int _internal_danmusources_size() const;
  public:
  void clear_danmusources();
  ::kservice::KikoDanmuResponse_DanmuSourceComments* mutable_danmusources(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::kservice::KikoDanmuResponse_DanmuSourceComments >*
      mutable_danmusources();
  private:
  const ::kservice::KikoDanmuResponse_DanmuSourceComments& _internal_danmusources(int index) const;
  ::kservice::KikoDanmuResponse_DanmuSourceComments* _internal_add_danmusources();
  public:
  const ::kservice::KikoDanmuResponse_DanmuSourceComments& danmusources(int index) const;
  ::kservice::KikoDanmuResponse_DanmuSourceComments* add_danmusources();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::kservice::KikoDanmuResponse_DanmuSourceComments >&
      danmusources() const;

  // .kservice.ResponseHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::kservice::ResponseHeader& header() const;
  PROTOBUF_NODISCARD ::kservice::ResponseHeader* release_header();
  ::kservice::ResponseHeader* mutable_header();
  void set_allocated_header(::kservice::ResponseHeader* header);
  private:
  const ::kservice::ResponseHeader& _internal_header() const;
  ::kservice::ResponseHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::kservice::ResponseHeader* header);
  ::kservice::ResponseHeader* unsafe_arena_release_header();

  // .kservice.Pool poolInfo = 2;
  bool has_poolinfo() const;
  private:
  bool _internal_has_poolinfo() const;
  public:
  void clear_poolinfo();
  const ::kservice::Pool& poolinfo() const;
  PROTOBUF_NODISCARD ::kservice::Pool* release_poolinfo();
  ::kservice::Pool* mutable_poolinfo();
  void set_allocated_poolinfo(::kservice::Pool* poolinfo);
  private:
  const ::kservice::Pool& _internal_poolinfo() const;
  ::kservice::Pool* _internal_mutable_poolinfo();
  public:
  void unsafe_arena_set_allocated_poolinfo(
      ::kservice::Pool* poolinfo);
  ::kservice::Pool* unsafe_arena_release_poolinfo();

  // @@protoc_insertion_point(class_scope:kservice.KikoDanmuResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::kservice::KikoDanmuResponse_DanmuSourceComments > danmusources_;
    ::kservice::ResponseHeader* header_;
    ::kservice::Pool* poolinfo_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Service_2fpb_2fservice_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// EventHeader

// int64 timestamp = 1;
inline void EventHeader::clear_timestamp() {
  _impl_.timestamp_ = int64_t{0};
}
inline int64_t EventHeader::_internal_timestamp() const {
  return _impl_.timestamp_;
}
inline int64_t EventHeader::timestamp() const {
  // @@protoc_insertion_point(field_get:kservice.EventHeader.timestamp)
  return _internal_timestamp();
}
inline void EventHeader::_internal_set_timestamp(int64_t value) {
  
  _impl_.timestamp_ = value;
}
inline void EventHeader::set_timestamp(int64_t value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:kservice.EventHeader.timestamp)
}

// string event = 2;
inline void EventHeader::clear_event() {
  _impl_.event_.ClearToEmpty();
}
inline const std::string& EventHeader::event() const {
  // @@protoc_insertion_point(field_get:kservice.EventHeader.event)
  return _internal_event();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void EventHeader::set_event(ArgT0&& arg0, ArgT... args) {
 
 _impl_.event_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:kservice.EventHeader.event)
}
inline std::string* EventHeader::mutable_event() {
  std::string* _s = _internal_mutable_event();
  // @@protoc_insertion_point(field_mutable:kservice.EventHeader.event)
  return _s;
}
inline const std::string& EventHeader::_internal_event() const {
  return _impl_.event_.Get();
}
inline void EventHeader::_internal_set_event(const std::string& value) {
  
  _impl_.event_.Set(value, GetArenaForAllocation());
}
inline std::string* EventHeader::_internal_mutable_event() {
  
  return _impl_.event_.Mutable(GetArenaForAllocation());
}
inline std::string* EventHeader::release_event() {
  // @@protoc_insertion_point(field_release:kservice.EventHeader.event)
  return _impl_.event_.Release();
}
inline void EventHeader::set_allocated_event(std::string* event) {
  if (event != nullptr) {
    
  } else {
    
  }
  _impl_.event_.SetAllocated(event, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.event_.IsDefault()) {
    _impl_.event_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:kservice.EventHeader.event)
}

// string os = 3;
inline void EventHeader::clear_os() {
  _impl_.os_.ClearToEmpty();
}
inline const std::string& EventHeader::os() const {
  // @@protoc_insertion_point(field_get:kservice.EventHeader.os)
  return _internal_os();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void EventHeader::set_os(ArgT0&& arg0, ArgT... args) {
 
 _impl_.os_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:kservice.EventHeader.os)
}
inline std::string* EventHeader::mutable_os() {
  std::string* _s = _internal_mutable_os();
  // @@protoc_insertion_point(field_mutable:kservice.EventHeader.os)
  return _s;
}
inline const std::string& EventHeader::_internal_os() const {
  return _impl_.os_.Get();
}
inline void EventHeader::_internal_set_os(const std::string& value) {
  
  _impl_.os_.Set(value, GetArenaForAllocation());
}
inline std::string* EventHeader::_internal_mutable_os() {
  
  return _impl_.os_.Mutable(GetArenaForAllocation());
}
inline std::string* EventHeader::release_os() {
  // @@protoc_insertion_point(field_release:kservice.EventHeader.os)
  return _impl_.os_.Release();
}
inline void EventHeader::set_allocated_os(std::string* os) {
  if (os != nullptr) {
    
  } else {
    
  }
  _impl_.os_.SetAllocated(os, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.os_.IsDefault()) {
    _impl_.os_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:kservice.EventHeader.os)
}

// int32 version = 4;
inline void EventHeader::clear_version() {
  _impl_.version_ = 0;
}
inline int32_t EventHeader::_internal_version() const {
  return _impl_.version_;
}
inline int32_t EventHeader::version() const {
  // @@protoc_insertion_point(field_get:kservice.EventHeader.version)
  return _internal_version();
}
inline void EventHeader::_internal_set_version(int32_t value) {
  
  _impl_.version_ = value;
}
inline void EventHeader::set_version(int32_t value) {
  _internal_set_version(value);
  // @@protoc_insertion_point(field_set:kservice.EventHeader.version)
}

// string did = 5;
inline void EventHeader::clear_did() {
  _impl_.did_.ClearToEmpty();
}
inline const std::string& EventHeader::did() const {
  // @@protoc_insertion_point(field_get:kservice.EventHeader.did)
  return _internal_did();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void EventHeader::set_did(ArgT0&& arg0, ArgT... args) {
 
 _impl_.did_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:kservice.EventHeader.did)
}
inline std::string* EventHeader::mutable_did() {
  std::string* _s = _internal_mutable_did();
  // @@protoc_insertion_point(field_mutable:kservice.EventHeader.did)
  return _s;
}
inline const std::string& EventHeader::_internal_did() const {
  return _impl_.did_.Get();
}
inline void EventHeader::_internal_set_did(const std::string& value) {
  
  _impl_.did_.Set(value, GetArenaForAllocation());
}
inline std::string* EventHeader::_internal_mutable_did() {
  
  return _impl_.did_.Mutable(GetArenaForAllocation());
}
inline std::string* EventHeader::release_did() {
  // @@protoc_insertion_point(field_release:kservice.EventHeader.did)
  return _impl_.did_.Release();
}
inline void EventHeader::set_allocated_did(std::string* did) {
  if (did != nullptr) {
    
  } else {
    
  }
  _impl_.did_.SetAllocated(did, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.did_.IsDefault()) {
    _impl_.did_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:kservice.EventHeader.did)
}

// string uid = 6;
inline void EventHeader::clear_uid() {
  _impl_.uid_.ClearToEmpty();
}
inline const std::string& EventHeader::uid() const {
  // @@protoc_insertion_point(field_get:kservice.EventHeader.uid)
  return _internal_uid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void EventHeader::set_uid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.uid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:kservice.EventHeader.uid)
}
inline std::string* EventHeader::mutable_uid() {
  std::string* _s = _internal_mutable_uid();
  // @@protoc_insertion_point(field_mutable:kservice.EventHeader.uid)
  return _s;
}
inline const std::string& EventHeader::_internal_uid() const {
  return _impl_.uid_.Get();
}
inline void EventHeader::_internal_set_uid(const std::string& value) {
  
  _impl_.uid_.Set(value, GetArenaForAllocation());
}
inline std::string* EventHeader::_internal_mutable_uid() {
  
  return _impl_.uid_.Mutable(GetArenaForAllocation());
}
inline std::string* EventHeader::release_uid() {
  // @@protoc_insertion_point(field_release:kservice.EventHeader.uid)
  return _impl_.uid_.Release();
}
inline void EventHeader::set_allocated_uid(std::string* uid) {
  if (uid != nullptr) {
    
  } else {
    
  }
  _impl_.uid_.SetAllocated(uid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.uid_.IsDefault()) {
    _impl_.uid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:kservice.EventHeader.uid)
}

// -------------------------------------------------------------------

// CommonEvent

// .kservice.EventHeader header = 1;
inline bool CommonEvent::_internal_has_header() const {
  return this != internal_default_instance() && _impl_.header_ != nullptr;
}
inline bool CommonEvent::has_header() const {
  return _internal_has_header();
}
inline void CommonEvent::clear_header() {
  if (GetArenaForAllocation() == nullptr && _impl_.header_ != nullptr) {
    delete _impl_.header_;
  }
  _impl_.header_ = nullptr;
}
inline const ::kservice::EventHeader& CommonEvent::_internal_header() const {
  const ::kservice::EventHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::kservice::EventHeader&>(
      ::kservice::_EventHeader_default_instance_);
}
inline const ::kservice::EventHeader& CommonEvent::header() const {
  // @@protoc_insertion_point(field_get:kservice.CommonEvent.header)
  return _internal_header();
}
inline void CommonEvent::unsafe_arena_set_allocated_header(
    ::kservice::EventHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kservice.CommonEvent.header)
}
inline ::kservice::EventHeader* CommonEvent::release_header() {
  
  ::kservice::EventHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::kservice::EventHeader* CommonEvent::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:kservice.CommonEvent.header)
  
  ::kservice::EventHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::kservice::EventHeader* CommonEvent::_internal_mutable_header() {
  
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::kservice::EventHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::kservice::EventHeader* CommonEvent::mutable_header() {
  ::kservice::EventHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:kservice.CommonEvent.header)
  return _msg;
}
inline void CommonEvent::set_allocated_header(::kservice::EventHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.header_;
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(header);
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:kservice.CommonEvent.header)
}

// string extra = 2;
inline void CommonEvent::clear_extra() {
  _impl_.extra_.ClearToEmpty();
}
inline const std::string& CommonEvent::extra() const {
  // @@protoc_insertion_point(field_get:kservice.CommonEvent.extra)
  return _internal_extra();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CommonEvent::set_extra(ArgT0&& arg0, ArgT... args) {
 
 _impl_.extra_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:kservice.CommonEvent.extra)
}
inline std::string* CommonEvent::mutable_extra() {
  std::string* _s = _internal_mutable_extra();
  // @@protoc_insertion_point(field_mutable:kservice.CommonEvent.extra)
  return _s;
}
inline const std::string& CommonEvent::_internal_extra() const {
  return _impl_.extra_.Get();
}
inline void CommonEvent::_internal_set_extra(const std::string& value) {
  
  _impl_.extra_.Set(value, GetArenaForAllocation());
}
inline std::string* CommonEvent::_internal_mutable_extra() {
  
  return _impl_.extra_.Mutable(GetArenaForAllocation());
}
inline std::string* CommonEvent::release_extra() {
  // @@protoc_insertion_point(field_release:kservice.CommonEvent.extra)
  return _impl_.extra_.Release();
}
inline void CommonEvent::set_allocated_extra(std::string* extra) {
  if (extra != nullptr) {
    
  } else {
    
  }
  _impl_.extra_.SetAllocated(extra, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.extra_.IsDefault()) {
    _impl_.extra_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:kservice.CommonEvent.extra)
}

// -------------------------------------------------------------------

// ResponseHeader

// int32 status = 1;
inline void ResponseHeader::clear_status() {
  _impl_.status_ = 0;
}
inline int32_t ResponseHeader::_internal_status() const {
  return _impl_.status_;
}
inline int32_t ResponseHeader::status() const {
  // @@protoc_insertion_point(field_get:kservice.ResponseHeader.status)
  return _internal_status();
}
inline void ResponseHeader::_internal_set_status(int32_t value) {
  
  _impl_.status_ = value;
}
inline void ResponseHeader::set_status(int32_t value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:kservice.ResponseHeader.status)
}

// string err_msg = 2;
inline void ResponseHeader::clear_err_msg() {
  _impl_.err_msg_.ClearToEmpty();
}
inline const std::string& ResponseHeader::err_msg() const {
  // @@protoc_insertion_point(field_get:kservice.ResponseHeader.err_msg)
  return _internal_err_msg();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ResponseHeader::set_err_msg(ArgT0&& arg0, ArgT... args) {
 
 _impl_.err_msg_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:kservice.ResponseHeader.err_msg)
}
inline std::string* ResponseHeader::mutable_err_msg() {
  std::string* _s = _internal_mutable_err_msg();
  // @@protoc_insertion_point(field_mutable:kservice.ResponseHeader.err_msg)
  return _s;
}
inline const std::string& ResponseHeader::_internal_err_msg() const {
  return _impl_.err_msg_.Get();
}
inline void ResponseHeader::_internal_set_err_msg(const std::string& value) {
  
  _impl_.err_msg_.Set(value, GetArenaForAllocation());
}
inline std::string* ResponseHeader::_internal_mutable_err_msg() {
  
  return _impl_.err_msg_.Mutable(GetArenaForAllocation());
}
inline std::string* ResponseHeader::release_err_msg() {
  // @@protoc_insertion_point(field_release:kservice.ResponseHeader.err_msg)
  return _impl_.err_msg_.Release();
}
inline void ResponseHeader::set_allocated_err_msg(std::string* err_msg) {
  if (err_msg != nullptr) {
    
  } else {
    
  }
  _impl_.err_msg_.SetAllocated(err_msg, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.err_msg_.IsDefault()) {
    _impl_.err_msg_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:kservice.ResponseHeader.err_msg)
}

// -------------------------------------------------------------------

// RegisterRequest

// .kservice.EventHeader header = 1;
inline bool RegisterRequest::_internal_has_header() const {
  return this != internal_default_instance() && _impl_.header_ != nullptr;
}
inline bool RegisterRequest::has_header() const {
  return _internal_has_header();
}
inline void RegisterRequest::clear_header() {
  if (GetArenaForAllocation() == nullptr && _impl_.header_ != nullptr) {
    delete _impl_.header_;
  }
  _impl_.header_ = nullptr;
}
inline const ::kservice::EventHeader& RegisterRequest::_internal_header() const {
  const ::kservice::EventHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::kservice::EventHeader&>(
      ::kservice::_EventHeader_default_instance_);
}
inline const ::kservice::EventHeader& RegisterRequest::header() const {
  // @@protoc_insertion_point(field_get:kservice.RegisterRequest.header)
  return _internal_header();
}
inline void RegisterRequest::unsafe_arena_set_allocated_header(
    ::kservice::EventHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kservice.RegisterRequest.header)
}
inline ::kservice::EventHeader* RegisterRequest::release_header() {
  
  ::kservice::EventHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::kservice::EventHeader* RegisterRequest::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:kservice.RegisterRequest.header)
  
  ::kservice::EventHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::kservice::EventHeader* RegisterRequest::_internal_mutable_header() {
  
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::kservice::EventHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::kservice::EventHeader* RegisterRequest::mutable_header() {
  ::kservice::EventHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:kservice.RegisterRequest.header)
  return _msg;
}
inline void RegisterRequest::set_allocated_header(::kservice::EventHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.header_;
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(header);
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:kservice.RegisterRequest.header)
}

// string username = 2;
inline void RegisterRequest::clear_username() {
  _impl_.username_.ClearToEmpty();
}
inline const std::string& RegisterRequest::username() const {
  // @@protoc_insertion_point(field_get:kservice.RegisterRequest.username)
  return _internal_username();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RegisterRequest::set_username(ArgT0&& arg0, ArgT... args) {
 
 _impl_.username_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:kservice.RegisterRequest.username)
}
inline std::string* RegisterRequest::mutable_username() {
  std::string* _s = _internal_mutable_username();
  // @@protoc_insertion_point(field_mutable:kservice.RegisterRequest.username)
  return _s;
}
inline const std::string& RegisterRequest::_internal_username() const {
  return _impl_.username_.Get();
}
inline void RegisterRequest::_internal_set_username(const std::string& value) {
  
  _impl_.username_.Set(value, GetArenaForAllocation());
}
inline std::string* RegisterRequest::_internal_mutable_username() {
  
  return _impl_.username_.Mutable(GetArenaForAllocation());
}
inline std::string* RegisterRequest::release_username() {
  // @@protoc_insertion_point(field_release:kservice.RegisterRequest.username)
  return _impl_.username_.Release();
}
inline void RegisterRequest::set_allocated_username(std::string* username) {
  if (username != nullptr) {
    
  } else {
    
  }
  _impl_.username_.SetAllocated(username, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.username_.IsDefault()) {
    _impl_.username_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:kservice.RegisterRequest.username)
}

// string password = 3;
inline void RegisterRequest::clear_password() {
  _impl_.password_.ClearToEmpty();
}
inline const std::string& RegisterRequest::password() const {
  // @@protoc_insertion_point(field_get:kservice.RegisterRequest.password)
  return _internal_password();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RegisterRequest::set_password(ArgT0&& arg0, ArgT... args) {
 
 _impl_.password_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:kservice.RegisterRequest.password)
}
inline std::string* RegisterRequest::mutable_password() {
  std::string* _s = _internal_mutable_password();
  // @@protoc_insertion_point(field_mutable:kservice.RegisterRequest.password)
  return _s;
}
inline const std::string& RegisterRequest::_internal_password() const {
  return _impl_.password_.Get();
}
inline void RegisterRequest::_internal_set_password(const std::string& value) {
  
  _impl_.password_.Set(value, GetArenaForAllocation());
}
inline std::string* RegisterRequest::_internal_mutable_password() {
  
  return _impl_.password_.Mutable(GetArenaForAllocation());
}
inline std::string* RegisterRequest::release_password() {
  // @@protoc_insertion_point(field_release:kservice.RegisterRequest.password)
  return _impl_.password_.Release();
}
inline void RegisterRequest::set_allocated_password(std::string* password) {
  if (password != nullptr) {
    
  } else {
    
  }
  _impl_.password_.SetAllocated(password, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.password_.IsDefault()) {
    _impl_.password_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:kservice.RegisterRequest.password)
}

// string email = 4;
inline void RegisterRequest::clear_email() {
  _impl_.email_.ClearToEmpty();
}
inline const std::string& RegisterRequest::email() const {
  // @@protoc_insertion_point(field_get:kservice.RegisterRequest.email)
  return _internal_email();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RegisterRequest::set_email(ArgT0&& arg0, ArgT... args) {
 
 _impl_.email_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:kservice.RegisterRequest.email)
}
inline std::string* RegisterRequest::mutable_email() {
  std::string* _s = _internal_mutable_email();
  // @@protoc_insertion_point(field_mutable:kservice.RegisterRequest.email)
  return _s;
}
inline const std::string& RegisterRequest::_internal_email() const {
  return _impl_.email_.Get();
}
inline void RegisterRequest::_internal_set_email(const std::string& value) {
  
  _impl_.email_.Set(value, GetArenaForAllocation());
}
inline std::string* RegisterRequest::_internal_mutable_email() {
  
  return _impl_.email_.Mutable(GetArenaForAllocation());
}
inline std::string* RegisterRequest::release_email() {
  // @@protoc_insertion_point(field_release:kservice.RegisterRequest.email)
  return _impl_.email_.Release();
}
inline void RegisterRequest::set_allocated_email(std::string* email) {
  if (email != nullptr) {
    
  } else {
    
  }
  _impl_.email_.SetAllocated(email, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.email_.IsDefault()) {
    _impl_.email_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:kservice.RegisterRequest.email)
}

// string verification_code = 5;
inline void RegisterRequest::clear_verification_code() {
  _impl_.verification_code_.ClearToEmpty();
}
inline const std::string& RegisterRequest::verification_code() const {
  // @@protoc_insertion_point(field_get:kservice.RegisterRequest.verification_code)
  return _internal_verification_code();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RegisterRequest::set_verification_code(ArgT0&& arg0, ArgT... args) {
 
 _impl_.verification_code_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:kservice.RegisterRequest.verification_code)
}
inline std::string* RegisterRequest::mutable_verification_code() {
  std::string* _s = _internal_mutable_verification_code();
  // @@protoc_insertion_point(field_mutable:kservice.RegisterRequest.verification_code)
  return _s;
}
inline const std::string& RegisterRequest::_internal_verification_code() const {
  return _impl_.verification_code_.Get();
}
inline void RegisterRequest::_internal_set_verification_code(const std::string& value) {
  
  _impl_.verification_code_.Set(value, GetArenaForAllocation());
}
inline std::string* RegisterRequest::_internal_mutable_verification_code() {
  
  return _impl_.verification_code_.Mutable(GetArenaForAllocation());
}
inline std::string* RegisterRequest::release_verification_code() {
  // @@protoc_insertion_point(field_release:kservice.RegisterRequest.verification_code)
  return _impl_.verification_code_.Release();
}
inline void RegisterRequest::set_allocated_verification_code(std::string* verification_code) {
  if (verification_code != nullptr) {
    
  } else {
    
  }
  _impl_.verification_code_.SetAllocated(verification_code, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.verification_code_.IsDefault()) {
    _impl_.verification_code_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:kservice.RegisterRequest.verification_code)
}

// -------------------------------------------------------------------

// RegisterResponse

// .kservice.ResponseHeader header = 1;
inline bool RegisterResponse::_internal_has_header() const {
  return this != internal_default_instance() && _impl_.header_ != nullptr;
}
inline bool RegisterResponse::has_header() const {
  return _internal_has_header();
}
inline void RegisterResponse::clear_header() {
  if (GetArenaForAllocation() == nullptr && _impl_.header_ != nullptr) {
    delete _impl_.header_;
  }
  _impl_.header_ = nullptr;
}
inline const ::kservice::ResponseHeader& RegisterResponse::_internal_header() const {
  const ::kservice::ResponseHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::kservice::ResponseHeader&>(
      ::kservice::_ResponseHeader_default_instance_);
}
inline const ::kservice::ResponseHeader& RegisterResponse::header() const {
  // @@protoc_insertion_point(field_get:kservice.RegisterResponse.header)
  return _internal_header();
}
inline void RegisterResponse::unsafe_arena_set_allocated_header(
    ::kservice::ResponseHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kservice.RegisterResponse.header)
}
inline ::kservice::ResponseHeader* RegisterResponse::release_header() {
  
  ::kservice::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::kservice::ResponseHeader* RegisterResponse::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:kservice.RegisterResponse.header)
  
  ::kservice::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::kservice::ResponseHeader* RegisterResponse::_internal_mutable_header() {
  
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::kservice::ResponseHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::kservice::ResponseHeader* RegisterResponse::mutable_header() {
  ::kservice::ResponseHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:kservice.RegisterResponse.header)
  return _msg;
}
inline void RegisterResponse::set_allocated_header(::kservice::ResponseHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.header_;
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(header);
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:kservice.RegisterResponse.header)
}

// string uid = 2;
inline void RegisterResponse::clear_uid() {
  _impl_.uid_.ClearToEmpty();
}
inline const std::string& RegisterResponse::uid() const {
  // @@protoc_insertion_point(field_get:kservice.RegisterResponse.uid)
  return _internal_uid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RegisterResponse::set_uid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.uid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:kservice.RegisterResponse.uid)
}
inline std::string* RegisterResponse::mutable_uid() {
  std::string* _s = _internal_mutable_uid();
  // @@protoc_insertion_point(field_mutable:kservice.RegisterResponse.uid)
  return _s;
}
inline const std::string& RegisterResponse::_internal_uid() const {
  return _impl_.uid_.Get();
}
inline void RegisterResponse::_internal_set_uid(const std::string& value) {
  
  _impl_.uid_.Set(value, GetArenaForAllocation());
}
inline std::string* RegisterResponse::_internal_mutable_uid() {
  
  return _impl_.uid_.Mutable(GetArenaForAllocation());
}
inline std::string* RegisterResponse::release_uid() {
  // @@protoc_insertion_point(field_release:kservice.RegisterResponse.uid)
  return _impl_.uid_.Release();
}
inline void RegisterResponse::set_allocated_uid(std::string* uid) {
  if (uid != nullptr) {
    
  } else {
    
  }
  _impl_.uid_.SetAllocated(uid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.uid_.IsDefault()) {
    _impl_.uid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:kservice.RegisterResponse.uid)
}

// string username = 3;
inline void RegisterResponse::clear_username() {
  _impl_.username_.ClearToEmpty();
}
inline const std::string& RegisterResponse::username() const {
  // @@protoc_insertion_point(field_get:kservice.RegisterResponse.username)
  return _internal_username();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RegisterResponse::set_username(ArgT0&& arg0, ArgT... args) {
 
 _impl_.username_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:kservice.RegisterResponse.username)
}
inline std::string* RegisterResponse::mutable_username() {
  std::string* _s = _internal_mutable_username();
  // @@protoc_insertion_point(field_mutable:kservice.RegisterResponse.username)
  return _s;
}
inline const std::string& RegisterResponse::_internal_username() const {
  return _impl_.username_.Get();
}
inline void RegisterResponse::_internal_set_username(const std::string& value) {
  
  _impl_.username_.Set(value, GetArenaForAllocation());
}
inline std::string* RegisterResponse::_internal_mutable_username() {
  
  return _impl_.username_.Mutable(GetArenaForAllocation());
}
inline std::string* RegisterResponse::release_username() {
  // @@protoc_insertion_point(field_release:kservice.RegisterResponse.username)
  return _impl_.username_.Release();
}
inline void RegisterResponse::set_allocated_username(std::string* username) {
  if (username != nullptr) {
    
  } else {
    
  }
  _impl_.username_.SetAllocated(username, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.username_.IsDefault()) {
    _impl_.username_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:kservice.RegisterResponse.username)
}

// string email = 4;
inline void RegisterResponse::clear_email() {
  _impl_.email_.ClearToEmpty();
}
inline const std::string& RegisterResponse::email() const {
  // @@protoc_insertion_point(field_get:kservice.RegisterResponse.email)
  return _internal_email();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RegisterResponse::set_email(ArgT0&& arg0, ArgT... args) {
 
 _impl_.email_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:kservice.RegisterResponse.email)
}
inline std::string* RegisterResponse::mutable_email() {
  std::string* _s = _internal_mutable_email();
  // @@protoc_insertion_point(field_mutable:kservice.RegisterResponse.email)
  return _s;
}
inline const std::string& RegisterResponse::_internal_email() const {
  return _impl_.email_.Get();
}
inline void RegisterResponse::_internal_set_email(const std::string& value) {
  
  _impl_.email_.Set(value, GetArenaForAllocation());
}
inline std::string* RegisterResponse::_internal_mutable_email() {
  
  return _impl_.email_.Mutable(GetArenaForAllocation());
}
inline std::string* RegisterResponse::release_email() {
  // @@protoc_insertion_point(field_release:kservice.RegisterResponse.email)
  return _impl_.email_.Release();
}
inline void RegisterResponse::set_allocated_email(std::string* email) {
  if (email != nullptr) {
    
  } else {
    
  }
  _impl_.email_.SetAllocated(email, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.email_.IsDefault()) {
    _impl_.email_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:kservice.RegisterResponse.email)
}

// -------------------------------------------------------------------

// LoginRequest

// .kservice.EventHeader header = 1;
inline bool LoginRequest::_internal_has_header() const {
  return this != internal_default_instance() && _impl_.header_ != nullptr;
}
inline bool LoginRequest::has_header() const {
  return _internal_has_header();
}
inline void LoginRequest::clear_header() {
  if (GetArenaForAllocation() == nullptr && _impl_.header_ != nullptr) {
    delete _impl_.header_;
  }
  _impl_.header_ = nullptr;
}
inline const ::kservice::EventHeader& LoginRequest::_internal_header() const {
  const ::kservice::EventHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::kservice::EventHeader&>(
      ::kservice::_EventHeader_default_instance_);
}
inline const ::kservice::EventHeader& LoginRequest::header() const {
  // @@protoc_insertion_point(field_get:kservice.LoginRequest.header)
  return _internal_header();
}
inline void LoginRequest::unsafe_arena_set_allocated_header(
    ::kservice::EventHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kservice.LoginRequest.header)
}
inline ::kservice::EventHeader* LoginRequest::release_header() {
  
  ::kservice::EventHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::kservice::EventHeader* LoginRequest::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:kservice.LoginRequest.header)
  
  ::kservice::EventHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::kservice::EventHeader* LoginRequest::_internal_mutable_header() {
  
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::kservice::EventHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::kservice::EventHeader* LoginRequest::mutable_header() {
  ::kservice::EventHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:kservice.LoginRequest.header)
  return _msg;
}
inline void LoginRequest::set_allocated_header(::kservice::EventHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.header_;
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(header);
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:kservice.LoginRequest.header)
}

// string email = 2;
inline void LoginRequest::clear_email() {
  _impl_.email_.ClearToEmpty();
}
inline const std::string& LoginRequest::email() const {
  // @@protoc_insertion_point(field_get:kservice.LoginRequest.email)
  return _internal_email();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LoginRequest::set_email(ArgT0&& arg0, ArgT... args) {
 
 _impl_.email_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:kservice.LoginRequest.email)
}
inline std::string* LoginRequest::mutable_email() {
  std::string* _s = _internal_mutable_email();
  // @@protoc_insertion_point(field_mutable:kservice.LoginRequest.email)
  return _s;
}
inline const std::string& LoginRequest::_internal_email() const {
  return _impl_.email_.Get();
}
inline void LoginRequest::_internal_set_email(const std::string& value) {
  
  _impl_.email_.Set(value, GetArenaForAllocation());
}
inline std::string* LoginRequest::_internal_mutable_email() {
  
  return _impl_.email_.Mutable(GetArenaForAllocation());
}
inline std::string* LoginRequest::release_email() {
  // @@protoc_insertion_point(field_release:kservice.LoginRequest.email)
  return _impl_.email_.Release();
}
inline void LoginRequest::set_allocated_email(std::string* email) {
  if (email != nullptr) {
    
  } else {
    
  }
  _impl_.email_.SetAllocated(email, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.email_.IsDefault()) {
    _impl_.email_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:kservice.LoginRequest.email)
}

// string password = 3;
inline void LoginRequest::clear_password() {
  _impl_.password_.ClearToEmpty();
}
inline const std::string& LoginRequest::password() const {
  // @@protoc_insertion_point(field_get:kservice.LoginRequest.password)
  return _internal_password();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LoginRequest::set_password(ArgT0&& arg0, ArgT... args) {
 
 _impl_.password_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:kservice.LoginRequest.password)
}
inline std::string* LoginRequest::mutable_password() {
  std::string* _s = _internal_mutable_password();
  // @@protoc_insertion_point(field_mutable:kservice.LoginRequest.password)
  return _s;
}
inline const std::string& LoginRequest::_internal_password() const {
  return _impl_.password_.Get();
}
inline void LoginRequest::_internal_set_password(const std::string& value) {
  
  _impl_.password_.Set(value, GetArenaForAllocation());
}
inline std::string* LoginRequest::_internal_mutable_password() {
  
  return _impl_.password_.Mutable(GetArenaForAllocation());
}
inline std::string* LoginRequest::release_password() {
  // @@protoc_insertion_point(field_release:kservice.LoginRequest.password)
  return _impl_.password_.Release();
}
inline void LoginRequest::set_allocated_password(std::string* password) {
  if (password != nullptr) {
    
  } else {
    
  }
  _impl_.password_.SetAllocated(password, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.password_.IsDefault()) {
    _impl_.password_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:kservice.LoginRequest.password)
}

// -------------------------------------------------------------------

// LoginResponse

// .kservice.ResponseHeader header = 1;
inline bool LoginResponse::_internal_has_header() const {
  return this != internal_default_instance() && _impl_.header_ != nullptr;
}
inline bool LoginResponse::has_header() const {
  return _internal_has_header();
}
inline void LoginResponse::clear_header() {
  if (GetArenaForAllocation() == nullptr && _impl_.header_ != nullptr) {
    delete _impl_.header_;
  }
  _impl_.header_ = nullptr;
}
inline const ::kservice::ResponseHeader& LoginResponse::_internal_header() const {
  const ::kservice::ResponseHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::kservice::ResponseHeader&>(
      ::kservice::_ResponseHeader_default_instance_);
}
inline const ::kservice::ResponseHeader& LoginResponse::header() const {
  // @@protoc_insertion_point(field_get:kservice.LoginResponse.header)
  return _internal_header();
}
inline void LoginResponse::unsafe_arena_set_allocated_header(
    ::kservice::ResponseHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kservice.LoginResponse.header)
}
inline ::kservice::ResponseHeader* LoginResponse::release_header() {
  
  ::kservice::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::kservice::ResponseHeader* LoginResponse::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:kservice.LoginResponse.header)
  
  ::kservice::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::kservice::ResponseHeader* LoginResponse::_internal_mutable_header() {
  
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::kservice::ResponseHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::kservice::ResponseHeader* LoginResponse::mutable_header() {
  ::kservice::ResponseHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:kservice.LoginResponse.header)
  return _msg;
}
inline void LoginResponse::set_allocated_header(::kservice::ResponseHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.header_;
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(header);
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:kservice.LoginResponse.header)
}

// string uid = 2;
inline void LoginResponse::clear_uid() {
  _impl_.uid_.ClearToEmpty();
}
inline const std::string& LoginResponse::uid() const {
  // @@protoc_insertion_point(field_get:kservice.LoginResponse.uid)
  return _internal_uid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LoginResponse::set_uid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.uid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:kservice.LoginResponse.uid)
}
inline std::string* LoginResponse::mutable_uid() {
  std::string* _s = _internal_mutable_uid();
  // @@protoc_insertion_point(field_mutable:kservice.LoginResponse.uid)
  return _s;
}
inline const std::string& LoginResponse::_internal_uid() const {
  return _impl_.uid_.Get();
}
inline void LoginResponse::_internal_set_uid(const std::string& value) {
  
  _impl_.uid_.Set(value, GetArenaForAllocation());
}
inline std::string* LoginResponse::_internal_mutable_uid() {
  
  return _impl_.uid_.Mutable(GetArenaForAllocation());
}
inline std::string* LoginResponse::release_uid() {
  // @@protoc_insertion_point(field_release:kservice.LoginResponse.uid)
  return _impl_.uid_.Release();
}
inline void LoginResponse::set_allocated_uid(std::string* uid) {
  if (uid != nullptr) {
    
  } else {
    
  }
  _impl_.uid_.SetAllocated(uid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.uid_.IsDefault()) {
    _impl_.uid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:kservice.LoginResponse.uid)
}

// string username = 3;
inline void LoginResponse::clear_username() {
  _impl_.username_.ClearToEmpty();
}
inline const std::string& LoginResponse::username() const {
  // @@protoc_insertion_point(field_get:kservice.LoginResponse.username)
  return _internal_username();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LoginResponse::set_username(ArgT0&& arg0, ArgT... args) {
 
 _impl_.username_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:kservice.LoginResponse.username)
}
inline std::string* LoginResponse::mutable_username() {
  std::string* _s = _internal_mutable_username();
  // @@protoc_insertion_point(field_mutable:kservice.LoginResponse.username)
  return _s;
}
inline const std::string& LoginResponse::_internal_username() const {
  return _impl_.username_.Get();
}
inline void LoginResponse::_internal_set_username(const std::string& value) {
  
  _impl_.username_.Set(value, GetArenaForAllocation());
}
inline std::string* LoginResponse::_internal_mutable_username() {
  
  return _impl_.username_.Mutable(GetArenaForAllocation());
}
inline std::string* LoginResponse::release_username() {
  // @@protoc_insertion_point(field_release:kservice.LoginResponse.username)
  return _impl_.username_.Release();
}
inline void LoginResponse::set_allocated_username(std::string* username) {
  if (username != nullptr) {
    
  } else {
    
  }
  _impl_.username_.SetAllocated(username, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.username_.IsDefault()) {
    _impl_.username_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:kservice.LoginResponse.username)
}

// string email = 4;
inline void LoginResponse::clear_email() {
  _impl_.email_.ClearToEmpty();
}
inline const std::string& LoginResponse::email() const {
  // @@protoc_insertion_point(field_get:kservice.LoginResponse.email)
  return _internal_email();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LoginResponse::set_email(ArgT0&& arg0, ArgT... args) {
 
 _impl_.email_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:kservice.LoginResponse.email)
}
inline std::string* LoginResponse::mutable_email() {
  std::string* _s = _internal_mutable_email();
  // @@protoc_insertion_point(field_mutable:kservice.LoginResponse.email)
  return _s;
}
inline const std::string& LoginResponse::_internal_email() const {
  return _impl_.email_.Get();
}
inline void LoginResponse::_internal_set_email(const std::string& value) {
  
  _impl_.email_.Set(value, GetArenaForAllocation());
}
inline std::string* LoginResponse::_internal_mutable_email() {
  
  return _impl_.email_.Mutable(GetArenaForAllocation());
}
inline std::string* LoginResponse::release_email() {
  // @@protoc_insertion_point(field_release:kservice.LoginResponse.email)
  return _impl_.email_.Release();
}
inline void LoginResponse::set_allocated_email(std::string* email) {
  if (email != nullptr) {
    
  } else {
    
  }
  _impl_.email_.SetAllocated(email, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.email_.IsDefault()) {
    _impl_.email_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:kservice.LoginResponse.email)
}

// string access_token = 5;
inline void LoginResponse::clear_access_token() {
  _impl_.access_token_.ClearToEmpty();
}
inline const std::string& LoginResponse::access_token() const {
  // @@protoc_insertion_point(field_get:kservice.LoginResponse.access_token)
  return _internal_access_token();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LoginResponse::set_access_token(ArgT0&& arg0, ArgT... args) {
 
 _impl_.access_token_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:kservice.LoginResponse.access_token)
}
inline std::string* LoginResponse::mutable_access_token() {
  std::string* _s = _internal_mutable_access_token();
  // @@protoc_insertion_point(field_mutable:kservice.LoginResponse.access_token)
  return _s;
}
inline const std::string& LoginResponse::_internal_access_token() const {
  return _impl_.access_token_.Get();
}
inline void LoginResponse::_internal_set_access_token(const std::string& value) {
  
  _impl_.access_token_.Set(value, GetArenaForAllocation());
}
inline std::string* LoginResponse::_internal_mutable_access_token() {
  
  return _impl_.access_token_.Mutable(GetArenaForAllocation());
}
inline std::string* LoginResponse::release_access_token() {
  // @@protoc_insertion_point(field_release:kservice.LoginResponse.access_token)
  return _impl_.access_token_.Release();
}
inline void LoginResponse::set_allocated_access_token(std::string* access_token) {
  if (access_token != nullptr) {
    
  } else {
    
  }
  _impl_.access_token_.SetAllocated(access_token, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.access_token_.IsDefault()) {
    _impl_.access_token_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:kservice.LoginResponse.access_token)
}

// string refresh_token = 6;
inline void LoginResponse::clear_refresh_token() {
  _impl_.refresh_token_.ClearToEmpty();
}
inline const std::string& LoginResponse::refresh_token() const {
  // @@protoc_insertion_point(field_get:kservice.LoginResponse.refresh_token)
  return _internal_refresh_token();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LoginResponse::set_refresh_token(ArgT0&& arg0, ArgT... args) {
 
 _impl_.refresh_token_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:kservice.LoginResponse.refresh_token)
}
inline std::string* LoginResponse::mutable_refresh_token() {
  std::string* _s = _internal_mutable_refresh_token();
  // @@protoc_insertion_point(field_mutable:kservice.LoginResponse.refresh_token)
  return _s;
}
inline const std::string& LoginResponse::_internal_refresh_token() const {
  return _impl_.refresh_token_.Get();
}
inline void LoginResponse::_internal_set_refresh_token(const std::string& value) {
  
  _impl_.refresh_token_.Set(value, GetArenaForAllocation());
}
inline std::string* LoginResponse::_internal_mutable_refresh_token() {
  
  return _impl_.refresh_token_.Mutable(GetArenaForAllocation());
}
inline std::string* LoginResponse::release_refresh_token() {
  // @@protoc_insertion_point(field_release:kservice.LoginResponse.refresh_token)
  return _impl_.refresh_token_.Release();
}
inline void LoginResponse::set_allocated_refresh_token(std::string* refresh_token) {
  if (refresh_token != nullptr) {
    
  } else {
    
  }
  _impl_.refresh_token_.SetAllocated(refresh_token, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.refresh_token_.IsDefault()) {
    _impl_.refresh_token_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:kservice.LoginResponse.refresh_token)
}

// -------------------------------------------------------------------

// RefreshRequest

// .kservice.EventHeader header = 1;
inline bool RefreshRequest::_internal_has_header() const {
  return this != internal_default_instance() && _impl_.header_ != nullptr;
}
inline bool RefreshRequest::has_header() const {
  return _internal_has_header();
}
inline void RefreshRequest::clear_header() {
  if (GetArenaForAllocation() == nullptr && _impl_.header_ != nullptr) {
    delete _impl_.header_;
  }
  _impl_.header_ = nullptr;
}
inline const ::kservice::EventHeader& RefreshRequest::_internal_header() const {
  const ::kservice::EventHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::kservice::EventHeader&>(
      ::kservice::_EventHeader_default_instance_);
}
inline const ::kservice::EventHeader& RefreshRequest::header() const {
  // @@protoc_insertion_point(field_get:kservice.RefreshRequest.header)
  return _internal_header();
}
inline void RefreshRequest::unsafe_arena_set_allocated_header(
    ::kservice::EventHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kservice.RefreshRequest.header)
}
inline ::kservice::EventHeader* RefreshRequest::release_header() {
  
  ::kservice::EventHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::kservice::EventHeader* RefreshRequest::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:kservice.RefreshRequest.header)
  
  ::kservice::EventHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::kservice::EventHeader* RefreshRequest::_internal_mutable_header() {
  
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::kservice::EventHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::kservice::EventHeader* RefreshRequest::mutable_header() {
  ::kservice::EventHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:kservice.RefreshRequest.header)
  return _msg;
}
inline void RefreshRequest::set_allocated_header(::kservice::EventHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.header_;
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(header);
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:kservice.RefreshRequest.header)
}

// -------------------------------------------------------------------

// RefreshResponse

// .kservice.ResponseHeader header = 1;
inline bool RefreshResponse::_internal_has_header() const {
  return this != internal_default_instance() && _impl_.header_ != nullptr;
}
inline bool RefreshResponse::has_header() const {
  return _internal_has_header();
}
inline void RefreshResponse::clear_header() {
  if (GetArenaForAllocation() == nullptr && _impl_.header_ != nullptr) {
    delete _impl_.header_;
  }
  _impl_.header_ = nullptr;
}
inline const ::kservice::ResponseHeader& RefreshResponse::_internal_header() const {
  const ::kservice::ResponseHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::kservice::ResponseHeader&>(
      ::kservice::_ResponseHeader_default_instance_);
}
inline const ::kservice::ResponseHeader& RefreshResponse::header() const {
  // @@protoc_insertion_point(field_get:kservice.RefreshResponse.header)
  return _internal_header();
}
inline void RefreshResponse::unsafe_arena_set_allocated_header(
    ::kservice::ResponseHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kservice.RefreshResponse.header)
}
inline ::kservice::ResponseHeader* RefreshResponse::release_header() {
  
  ::kservice::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::kservice::ResponseHeader* RefreshResponse::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:kservice.RefreshResponse.header)
  
  ::kservice::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::kservice::ResponseHeader* RefreshResponse::_internal_mutable_header() {
  
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::kservice::ResponseHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::kservice::ResponseHeader* RefreshResponse::mutable_header() {
  ::kservice::ResponseHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:kservice.RefreshResponse.header)
  return _msg;
}
inline void RefreshResponse::set_allocated_header(::kservice::ResponseHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.header_;
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(header);
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:kservice.RefreshResponse.header)
}

// string uid = 2;
inline void RefreshResponse::clear_uid() {
  _impl_.uid_.ClearToEmpty();
}
inline const std::string& RefreshResponse::uid() const {
  // @@protoc_insertion_point(field_get:kservice.RefreshResponse.uid)
  return _internal_uid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RefreshResponse::set_uid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.uid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:kservice.RefreshResponse.uid)
}
inline std::string* RefreshResponse::mutable_uid() {
  std::string* _s = _internal_mutable_uid();
  // @@protoc_insertion_point(field_mutable:kservice.RefreshResponse.uid)
  return _s;
}
inline const std::string& RefreshResponse::_internal_uid() const {
  return _impl_.uid_.Get();
}
inline void RefreshResponse::_internal_set_uid(const std::string& value) {
  
  _impl_.uid_.Set(value, GetArenaForAllocation());
}
inline std::string* RefreshResponse::_internal_mutable_uid() {
  
  return _impl_.uid_.Mutable(GetArenaForAllocation());
}
inline std::string* RefreshResponse::release_uid() {
  // @@protoc_insertion_point(field_release:kservice.RefreshResponse.uid)
  return _impl_.uid_.Release();
}
inline void RefreshResponse::set_allocated_uid(std::string* uid) {
  if (uid != nullptr) {
    
  } else {
    
  }
  _impl_.uid_.SetAllocated(uid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.uid_.IsDefault()) {
    _impl_.uid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:kservice.RefreshResponse.uid)
}

// string access_token = 3;
inline void RefreshResponse::clear_access_token() {
  _impl_.access_token_.ClearToEmpty();
}
inline const std::string& RefreshResponse::access_token() const {
  // @@protoc_insertion_point(field_get:kservice.RefreshResponse.access_token)
  return _internal_access_token();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RefreshResponse::set_access_token(ArgT0&& arg0, ArgT... args) {
 
 _impl_.access_token_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:kservice.RefreshResponse.access_token)
}
inline std::string* RefreshResponse::mutable_access_token() {
  std::string* _s = _internal_mutable_access_token();
  // @@protoc_insertion_point(field_mutable:kservice.RefreshResponse.access_token)
  return _s;
}
inline const std::string& RefreshResponse::_internal_access_token() const {
  return _impl_.access_token_.Get();
}
inline void RefreshResponse::_internal_set_access_token(const std::string& value) {
  
  _impl_.access_token_.Set(value, GetArenaForAllocation());
}
inline std::string* RefreshResponse::_internal_mutable_access_token() {
  
  return _impl_.access_token_.Mutable(GetArenaForAllocation());
}
inline std::string* RefreshResponse::release_access_token() {
  // @@protoc_insertion_point(field_release:kservice.RefreshResponse.access_token)
  return _impl_.access_token_.Release();
}
inline void RefreshResponse::set_allocated_access_token(std::string* access_token) {
  if (access_token != nullptr) {
    
  } else {
    
  }
  _impl_.access_token_.SetAllocated(access_token, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.access_token_.IsDefault()) {
    _impl_.access_token_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:kservice.RefreshResponse.access_token)
}

// -------------------------------------------------------------------

// SendVerificationRequest

// .kservice.EventHeader header = 1;
inline bool SendVerificationRequest::_internal_has_header() const {
  return this != internal_default_instance() && _impl_.header_ != nullptr;
}
inline bool SendVerificationRequest::has_header() const {
  return _internal_has_header();
}
inline void SendVerificationRequest::clear_header() {
  if (GetArenaForAllocation() == nullptr && _impl_.header_ != nullptr) {
    delete _impl_.header_;
  }
  _impl_.header_ = nullptr;
}
inline const ::kservice::EventHeader& SendVerificationRequest::_internal_header() const {
  const ::kservice::EventHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::kservice::EventHeader&>(
      ::kservice::_EventHeader_default_instance_);
}
inline const ::kservice::EventHeader& SendVerificationRequest::header() const {
  // @@protoc_insertion_point(field_get:kservice.SendVerificationRequest.header)
  return _internal_header();
}
inline void SendVerificationRequest::unsafe_arena_set_allocated_header(
    ::kservice::EventHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kservice.SendVerificationRequest.header)
}
inline ::kservice::EventHeader* SendVerificationRequest::release_header() {
  
  ::kservice::EventHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::kservice::EventHeader* SendVerificationRequest::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:kservice.SendVerificationRequest.header)
  
  ::kservice::EventHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::kservice::EventHeader* SendVerificationRequest::_internal_mutable_header() {
  
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::kservice::EventHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::kservice::EventHeader* SendVerificationRequest::mutable_header() {
  ::kservice::EventHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:kservice.SendVerificationRequest.header)
  return _msg;
}
inline void SendVerificationRequest::set_allocated_header(::kservice::EventHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.header_;
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(header);
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:kservice.SendVerificationRequest.header)
}

// string email = 2;
inline void SendVerificationRequest::clear_email() {
  _impl_.email_.ClearToEmpty();
}
inline const std::string& SendVerificationRequest::email() const {
  // @@protoc_insertion_point(field_get:kservice.SendVerificationRequest.email)
  return _internal_email();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SendVerificationRequest::set_email(ArgT0&& arg0, ArgT... args) {
 
 _impl_.email_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:kservice.SendVerificationRequest.email)
}
inline std::string* SendVerificationRequest::mutable_email() {
  std::string* _s = _internal_mutable_email();
  // @@protoc_insertion_point(field_mutable:kservice.SendVerificationRequest.email)
  return _s;
}
inline const std::string& SendVerificationRequest::_internal_email() const {
  return _impl_.email_.Get();
}
inline void SendVerificationRequest::_internal_set_email(const std::string& value) {
  
  _impl_.email_.Set(value, GetArenaForAllocation());
}
inline std::string* SendVerificationRequest::_internal_mutable_email() {
  
  return _impl_.email_.Mutable(GetArenaForAllocation());
}
inline std::string* SendVerificationRequest::release_email() {
  // @@protoc_insertion_point(field_release:kservice.SendVerificationRequest.email)
  return _impl_.email_.Release();
}
inline void SendVerificationRequest::set_allocated_email(std::string* email) {
  if (email != nullptr) {
    
  } else {
    
  }
  _impl_.email_.SetAllocated(email, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.email_.IsDefault()) {
    _impl_.email_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:kservice.SendVerificationRequest.email)
}

// -------------------------------------------------------------------

// SendVerificationResponse

// .kservice.ResponseHeader header = 1;
inline bool SendVerificationResponse::_internal_has_header() const {
  return this != internal_default_instance() && _impl_.header_ != nullptr;
}
inline bool SendVerificationResponse::has_header() const {
  return _internal_has_header();
}
inline void SendVerificationResponse::clear_header() {
  if (GetArenaForAllocation() == nullptr && _impl_.header_ != nullptr) {
    delete _impl_.header_;
  }
  _impl_.header_ = nullptr;
}
inline const ::kservice::ResponseHeader& SendVerificationResponse::_internal_header() const {
  const ::kservice::ResponseHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::kservice::ResponseHeader&>(
      ::kservice::_ResponseHeader_default_instance_);
}
inline const ::kservice::ResponseHeader& SendVerificationResponse::header() const {
  // @@protoc_insertion_point(field_get:kservice.SendVerificationResponse.header)
  return _internal_header();
}
inline void SendVerificationResponse::unsafe_arena_set_allocated_header(
    ::kservice::ResponseHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kservice.SendVerificationResponse.header)
}
inline ::kservice::ResponseHeader* SendVerificationResponse::release_header() {
  
  ::kservice::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::kservice::ResponseHeader* SendVerificationResponse::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:kservice.SendVerificationResponse.header)
  
  ::kservice::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::kservice::ResponseHeader* SendVerificationResponse::_internal_mutable_header() {
  
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::kservice::ResponseHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::kservice::ResponseHeader* SendVerificationResponse::mutable_header() {
  ::kservice::ResponseHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:kservice.SendVerificationResponse.header)
  return _msg;
}
inline void SendVerificationResponse::set_allocated_header(::kservice::ResponseHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.header_;
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(header);
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:kservice.SendVerificationResponse.header)
}

// -------------------------------------------------------------------

// UVEvent_StepTime

// string step = 1;
inline void UVEvent_StepTime::clear_step() {
  _impl_.step_.ClearToEmpty();
}
inline const std::string& UVEvent_StepTime::step() const {
  // @@protoc_insertion_point(field_get:kservice.UVEvent.StepTime.step)
  return _internal_step();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UVEvent_StepTime::set_step(ArgT0&& arg0, ArgT... args) {
 
 _impl_.step_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:kservice.UVEvent.StepTime.step)
}
inline std::string* UVEvent_StepTime::mutable_step() {
  std::string* _s = _internal_mutable_step();
  // @@protoc_insertion_point(field_mutable:kservice.UVEvent.StepTime.step)
  return _s;
}
inline const std::string& UVEvent_StepTime::_internal_step() const {
  return _impl_.step_.Get();
}
inline void UVEvent_StepTime::_internal_set_step(const std::string& value) {
  
  _impl_.step_.Set(value, GetArenaForAllocation());
}
inline std::string* UVEvent_StepTime::_internal_mutable_step() {
  
  return _impl_.step_.Mutable(GetArenaForAllocation());
}
inline std::string* UVEvent_StepTime::release_step() {
  // @@protoc_insertion_point(field_release:kservice.UVEvent.StepTime.step)
  return _impl_.step_.Release();
}
inline void UVEvent_StepTime::set_allocated_step(std::string* step) {
  if (step != nullptr) {
    
  } else {
    
  }
  _impl_.step_.SetAllocated(step, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.step_.IsDefault()) {
    _impl_.step_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:kservice.UVEvent.StepTime.step)
}

// int64 time = 2;
inline void UVEvent_StepTime::clear_time() {
  _impl_.time_ = int64_t{0};
}
inline int64_t UVEvent_StepTime::_internal_time() const {
  return _impl_.time_;
}
inline int64_t UVEvent_StepTime::time() const {
  // @@protoc_insertion_point(field_get:kservice.UVEvent.StepTime.time)
  return _internal_time();
}
inline void UVEvent_StepTime::_internal_set_time(int64_t value) {
  
  _impl_.time_ = value;
}
inline void UVEvent_StepTime::set_time(int64_t value) {
  _internal_set_time(value);
  // @@protoc_insertion_point(field_set:kservice.UVEvent.StepTime.time)
}

// -------------------------------------------------------------------

// UVEvent

// .kservice.EventHeader header = 1;
inline bool UVEvent::_internal_has_header() const {
  return this != internal_default_instance() && _impl_.header_ != nullptr;
}
inline bool UVEvent::has_header() const {
  return _internal_has_header();
}
inline void UVEvent::clear_header() {
  if (GetArenaForAllocation() == nullptr && _impl_.header_ != nullptr) {
    delete _impl_.header_;
  }
  _impl_.header_ = nullptr;
}
inline const ::kservice::EventHeader& UVEvent::_internal_header() const {
  const ::kservice::EventHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::kservice::EventHeader&>(
      ::kservice::_EventHeader_default_instance_);
}
inline const ::kservice::EventHeader& UVEvent::header() const {
  // @@protoc_insertion_point(field_get:kservice.UVEvent.header)
  return _internal_header();
}
inline void UVEvent::unsafe_arena_set_allocated_header(
    ::kservice::EventHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kservice.UVEvent.header)
}
inline ::kservice::EventHeader* UVEvent::release_header() {
  
  ::kservice::EventHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::kservice::EventHeader* UVEvent::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:kservice.UVEvent.header)
  
  ::kservice::EventHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::kservice::EventHeader* UVEvent::_internal_mutable_header() {
  
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::kservice::EventHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::kservice::EventHeader* UVEvent::mutable_header() {
  ::kservice::EventHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:kservice.UVEvent.header)
  return _msg;
}
inline void UVEvent::set_allocated_header(::kservice::EventHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.header_;
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(header);
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:kservice.UVEvent.header)
}

// bool isStartup = 2;
inline void UVEvent::clear_isstartup() {
  _impl_.isstartup_ = false;
}
inline bool UVEvent::_internal_isstartup() const {
  return _impl_.isstartup_;
}
inline bool UVEvent::isstartup() const {
  // @@protoc_insertion_point(field_get:kservice.UVEvent.isStartup)
  return _internal_isstartup();
}
inline void UVEvent::_internal_set_isstartup(bool value) {
  
  _impl_.isstartup_ = value;
}
inline void UVEvent::set_isstartup(bool value) {
  _internal_set_isstartup(value);
  // @@protoc_insertion_point(field_set:kservice.UVEvent.isStartup)
}

// int64 startupTs = 3;
inline void UVEvent::clear_startupts() {
  _impl_.startupts_ = int64_t{0};
}
inline int64_t UVEvent::_internal_startupts() const {
  return _impl_.startupts_;
}
inline int64_t UVEvent::startupts() const {
  // @@protoc_insertion_point(field_get:kservice.UVEvent.startupTs)
  return _internal_startupts();
}
inline void UVEvent::_internal_set_startupts(int64_t value) {
  
  _impl_.startupts_ = value;
}
inline void UVEvent::set_startupts(int64_t value) {
  _internal_set_startupts(value);
  // @@protoc_insertion_point(field_set:kservice.UVEvent.startupTs)
}

// repeated .kservice.UVEvent.StepTime stepTimes = 4;
inline int UVEvent::_internal_steptimes_size() const {
  return _impl_.steptimes_.size();
}
inline int UVEvent::steptimes_size() const {
  return _internal_steptimes_size();
}
inline void UVEvent::clear_steptimes() {
  _impl_.steptimes_.Clear();
}
inline ::kservice::UVEvent_StepTime* UVEvent::mutable_steptimes(int index) {
  // @@protoc_insertion_point(field_mutable:kservice.UVEvent.stepTimes)
  return _impl_.steptimes_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::kservice::UVEvent_StepTime >*
UVEvent::mutable_steptimes() {
  // @@protoc_insertion_point(field_mutable_list:kservice.UVEvent.stepTimes)
  return &_impl_.steptimes_;
}
inline const ::kservice::UVEvent_StepTime& UVEvent::_internal_steptimes(int index) const {
  return _impl_.steptimes_.Get(index);
}
inline const ::kservice::UVEvent_StepTime& UVEvent::steptimes(int index) const {
  // @@protoc_insertion_point(field_get:kservice.UVEvent.stepTimes)
  return _internal_steptimes(index);
}
inline ::kservice::UVEvent_StepTime* UVEvent::_internal_add_steptimes() {
  return _impl_.steptimes_.Add();
}
inline ::kservice::UVEvent_StepTime* UVEvent::add_steptimes() {
  ::kservice::UVEvent_StepTime* _add = _internal_add_steptimes();
  // @@protoc_insertion_point(field_add:kservice.UVEvent.stepTimes)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::kservice::UVEvent_StepTime >&
UVEvent::steptimes() const {
  // @@protoc_insertion_point(field_list:kservice.UVEvent.stepTimes)
  return _impl_.steptimes_;
}

// -------------------------------------------------------------------

// UVEventResponse_LatestVersion

// int32 version = 1;
inline void UVEventResponse_LatestVersion::clear_version() {
  _impl_.version_ = 0;
}
inline int32_t UVEventResponse_LatestVersion::_internal_version() const {
  return _impl_.version_;
}
inline int32_t UVEventResponse_LatestVersion::version() const {
  // @@protoc_insertion_point(field_get:kservice.UVEventResponse.LatestVersion.version)
  return _internal_version();
}
inline void UVEventResponse_LatestVersion::_internal_set_version(int32_t value) {
  
  _impl_.version_ = value;
}
inline void UVEventResponse_LatestVersion::set_version(int32_t value) {
  _internal_set_version(value);
  // @@protoc_insertion_point(field_set:kservice.UVEventResponse.LatestVersion.version)
}

// string url = 2;
inline void UVEventResponse_LatestVersion::clear_url() {
  _impl_.url_.ClearToEmpty();
}
inline const std::string& UVEventResponse_LatestVersion::url() const {
  // @@protoc_insertion_point(field_get:kservice.UVEventResponse.LatestVersion.url)
  return _internal_url();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UVEventResponse_LatestVersion::set_url(ArgT0&& arg0, ArgT... args) {
 
 _impl_.url_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:kservice.UVEventResponse.LatestVersion.url)
}
inline std::string* UVEventResponse_LatestVersion::mutable_url() {
  std::string* _s = _internal_mutable_url();
  // @@protoc_insertion_point(field_mutable:kservice.UVEventResponse.LatestVersion.url)
  return _s;
}
inline const std::string& UVEventResponse_LatestVersion::_internal_url() const {
  return _impl_.url_.Get();
}
inline void UVEventResponse_LatestVersion::_internal_set_url(const std::string& value) {
  
  _impl_.url_.Set(value, GetArenaForAllocation());
}
inline std::string* UVEventResponse_LatestVersion::_internal_mutable_url() {
  
  return _impl_.url_.Mutable(GetArenaForAllocation());
}
inline std::string* UVEventResponse_LatestVersion::release_url() {
  // @@protoc_insertion_point(field_release:kservice.UVEventResponse.LatestVersion.url)
  return _impl_.url_.Release();
}
inline void UVEventResponse_LatestVersion::set_allocated_url(std::string* url) {
  if (url != nullptr) {
    
  } else {
    
  }
  _impl_.url_.SetAllocated(url, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.url_.IsDefault()) {
    _impl_.url_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:kservice.UVEventResponse.LatestVersion.url)
}

// string info = 3;
inline void UVEventResponse_LatestVersion::clear_info() {
  _impl_.info_.ClearToEmpty();
}
inline const std::string& UVEventResponse_LatestVersion::info() const {
  // @@protoc_insertion_point(field_get:kservice.UVEventResponse.LatestVersion.info)
  return _internal_info();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UVEventResponse_LatestVersion::set_info(ArgT0&& arg0, ArgT... args) {
 
 _impl_.info_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:kservice.UVEventResponse.LatestVersion.info)
}
inline std::string* UVEventResponse_LatestVersion::mutable_info() {
  std::string* _s = _internal_mutable_info();
  // @@protoc_insertion_point(field_mutable:kservice.UVEventResponse.LatestVersion.info)
  return _s;
}
inline const std::string& UVEventResponse_LatestVersion::_internal_info() const {
  return _impl_.info_.Get();
}
inline void UVEventResponse_LatestVersion::_internal_set_info(const std::string& value) {
  
  _impl_.info_.Set(value, GetArenaForAllocation());
}
inline std::string* UVEventResponse_LatestVersion::_internal_mutable_info() {
  
  return _impl_.info_.Mutable(GetArenaForAllocation());
}
inline std::string* UVEventResponse_LatestVersion::release_info() {
  // @@protoc_insertion_point(field_release:kservice.UVEventResponse.LatestVersion.info)
  return _impl_.info_.Release();
}
inline void UVEventResponse_LatestVersion::set_allocated_info(std::string* info) {
  if (info != nullptr) {
    
  } else {
    
  }
  _impl_.info_.SetAllocated(info, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.info_.IsDefault()) {
    _impl_.info_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:kservice.UVEventResponse.LatestVersion.info)
}

// -------------------------------------------------------------------

// UVEventResponse

// .kservice.ResponseHeader header = 1;
inline bool UVEventResponse::_internal_has_header() const {
  return this != internal_default_instance() && _impl_.header_ != nullptr;
}
inline bool UVEventResponse::has_header() const {
  return _internal_has_header();
}
inline void UVEventResponse::clear_header() {
  if (GetArenaForAllocation() == nullptr && _impl_.header_ != nullptr) {
    delete _impl_.header_;
  }
  _impl_.header_ = nullptr;
}
inline const ::kservice::ResponseHeader& UVEventResponse::_internal_header() const {
  const ::kservice::ResponseHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::kservice::ResponseHeader&>(
      ::kservice::_ResponseHeader_default_instance_);
}
inline const ::kservice::ResponseHeader& UVEventResponse::header() const {
  // @@protoc_insertion_point(field_get:kservice.UVEventResponse.header)
  return _internal_header();
}
inline void UVEventResponse::unsafe_arena_set_allocated_header(
    ::kservice::ResponseHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kservice.UVEventResponse.header)
}
inline ::kservice::ResponseHeader* UVEventResponse::release_header() {
  
  ::kservice::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::kservice::ResponseHeader* UVEventResponse::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:kservice.UVEventResponse.header)
  
  ::kservice::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::kservice::ResponseHeader* UVEventResponse::_internal_mutable_header() {
  
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::kservice::ResponseHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::kservice::ResponseHeader* UVEventResponse::mutable_header() {
  ::kservice::ResponseHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:kservice.UVEventResponse.header)
  return _msg;
}
inline void UVEventResponse::set_allocated_header(::kservice::ResponseHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.header_;
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(header);
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:kservice.UVEventResponse.header)
}

// .kservice.UVEventResponse.LatestVersion latestVersionInfo = 2;
inline bool UVEventResponse::_internal_has_latestversioninfo() const {
  return this != internal_default_instance() && _impl_.latestversioninfo_ != nullptr;
}
inline bool UVEventResponse::has_latestversioninfo() const {
  return _internal_has_latestversioninfo();
}
inline void UVEventResponse::clear_latestversioninfo() {
  if (GetArenaForAllocation() == nullptr && _impl_.latestversioninfo_ != nullptr) {
    delete _impl_.latestversioninfo_;
  }
  _impl_.latestversioninfo_ = nullptr;
}
inline const ::kservice::UVEventResponse_LatestVersion& UVEventResponse::_internal_latestversioninfo() const {
  const ::kservice::UVEventResponse_LatestVersion* p = _impl_.latestversioninfo_;
  return p != nullptr ? *p : reinterpret_cast<const ::kservice::UVEventResponse_LatestVersion&>(
      ::kservice::_UVEventResponse_LatestVersion_default_instance_);
}
inline const ::kservice::UVEventResponse_LatestVersion& UVEventResponse::latestversioninfo() const {
  // @@protoc_insertion_point(field_get:kservice.UVEventResponse.latestVersionInfo)
  return _internal_latestversioninfo();
}
inline void UVEventResponse::unsafe_arena_set_allocated_latestversioninfo(
    ::kservice::UVEventResponse_LatestVersion* latestversioninfo) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.latestversioninfo_);
  }
  _impl_.latestversioninfo_ = latestversioninfo;
  if (latestversioninfo) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kservice.UVEventResponse.latestVersionInfo)
}
inline ::kservice::UVEventResponse_LatestVersion* UVEventResponse::release_latestversioninfo() {
  
  ::kservice::UVEventResponse_LatestVersion* temp = _impl_.latestversioninfo_;
  _impl_.latestversioninfo_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::kservice::UVEventResponse_LatestVersion* UVEventResponse::unsafe_arena_release_latestversioninfo() {
  // @@protoc_insertion_point(field_release:kservice.UVEventResponse.latestVersionInfo)
  
  ::kservice::UVEventResponse_LatestVersion* temp = _impl_.latestversioninfo_;
  _impl_.latestversioninfo_ = nullptr;
  return temp;
}
inline ::kservice::UVEventResponse_LatestVersion* UVEventResponse::_internal_mutable_latestversioninfo() {
  
  if (_impl_.latestversioninfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::kservice::UVEventResponse_LatestVersion>(GetArenaForAllocation());
    _impl_.latestversioninfo_ = p;
  }
  return _impl_.latestversioninfo_;
}
inline ::kservice::UVEventResponse_LatestVersion* UVEventResponse::mutable_latestversioninfo() {
  ::kservice::UVEventResponse_LatestVersion* _msg = _internal_mutable_latestversioninfo();
  // @@protoc_insertion_point(field_mutable:kservice.UVEventResponse.latestVersionInfo)
  return _msg;
}
inline void UVEventResponse::set_allocated_latestversioninfo(::kservice::UVEventResponse_LatestVersion* latestversioninfo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.latestversioninfo_;
  }
  if (latestversioninfo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(latestversioninfo);
    if (message_arena != submessage_arena) {
      latestversioninfo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, latestversioninfo, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.latestversioninfo_ = latestversioninfo;
  // @@protoc_insertion_point(field_set_allocated:kservice.UVEventResponse.latestVersionInfo)
}

// -------------------------------------------------------------------

// KFileInfo

// string fileName = 1;
inline void KFileInfo::clear_filename() {
  _impl_.filename_.ClearToEmpty();
}
inline const std::string& KFileInfo::filename() const {
  // @@protoc_insertion_point(field_get:kservice.KFileInfo.fileName)
  return _internal_filename();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void KFileInfo::set_filename(ArgT0&& arg0, ArgT... args) {
 
 _impl_.filename_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:kservice.KFileInfo.fileName)
}
inline std::string* KFileInfo::mutable_filename() {
  std::string* _s = _internal_mutable_filename();
  // @@protoc_insertion_point(field_mutable:kservice.KFileInfo.fileName)
  return _s;
}
inline const std::string& KFileInfo::_internal_filename() const {
  return _impl_.filename_.Get();
}
inline void KFileInfo::_internal_set_filename(const std::string& value) {
  
  _impl_.filename_.Set(value, GetArenaForAllocation());
}
inline std::string* KFileInfo::_internal_mutable_filename() {
  
  return _impl_.filename_.Mutable(GetArenaForAllocation());
}
inline std::string* KFileInfo::release_filename() {
  // @@protoc_insertion_point(field_release:kservice.KFileInfo.fileName)
  return _impl_.filename_.Release();
}
inline void KFileInfo::set_allocated_filename(std::string* filename) {
  if (filename != nullptr) {
    
  } else {
    
  }
  _impl_.filename_.SetAllocated(filename, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.filename_.IsDefault()) {
    _impl_.filename_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:kservice.KFileInfo.fileName)
}

// string fullPath = 2;
inline void KFileInfo::clear_fullpath() {
  _impl_.fullpath_.ClearToEmpty();
}
inline const std::string& KFileInfo::fullpath() const {
  // @@protoc_insertion_point(field_get:kservice.KFileInfo.fullPath)
  return _internal_fullpath();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void KFileInfo::set_fullpath(ArgT0&& arg0, ArgT... args) {
 
 _impl_.fullpath_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:kservice.KFileInfo.fullPath)
}
inline std::string* KFileInfo::mutable_fullpath() {
  std::string* _s = _internal_mutable_fullpath();
  // @@protoc_insertion_point(field_mutable:kservice.KFileInfo.fullPath)
  return _s;
}
inline const std::string& KFileInfo::_internal_fullpath() const {
  return _impl_.fullpath_.Get();
}
inline void KFileInfo::_internal_set_fullpath(const std::string& value) {
  
  _impl_.fullpath_.Set(value, GetArenaForAllocation());
}
inline std::string* KFileInfo::_internal_mutable_fullpath() {
  
  return _impl_.fullpath_.Mutable(GetArenaForAllocation());
}
inline std::string* KFileInfo::release_fullpath() {
  // @@protoc_insertion_point(field_release:kservice.KFileInfo.fullPath)
  return _impl_.fullpath_.Release();
}
inline void KFileInfo::set_allocated_fullpath(std::string* fullpath) {
  if (fullpath != nullptr) {
    
  } else {
    
  }
  _impl_.fullpath_.SetAllocated(fullpath, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.fullpath_.IsDefault()) {
    _impl_.fullpath_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:kservice.KFileInfo.fullPath)
}

// string hash32 = 3;
inline void KFileInfo::clear_hash32() {
  _impl_.hash32_.ClearToEmpty();
}
inline const std::string& KFileInfo::hash32() const {
  // @@protoc_insertion_point(field_get:kservice.KFileInfo.hash32)
  return _internal_hash32();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void KFileInfo::set_hash32(ArgT0&& arg0, ArgT... args) {
 
 _impl_.hash32_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:kservice.KFileInfo.hash32)
}
inline std::string* KFileInfo::mutable_hash32() {
  std::string* _s = _internal_mutable_hash32();
  // @@protoc_insertion_point(field_mutable:kservice.KFileInfo.hash32)
  return _s;
}
inline const std::string& KFileInfo::_internal_hash32() const {
  return _impl_.hash32_.Get();
}
inline void KFileInfo::_internal_set_hash32(const std::string& value) {
  
  _impl_.hash32_.Set(value, GetArenaForAllocation());
}
inline std::string* KFileInfo::_internal_mutable_hash32() {
  
  return _impl_.hash32_.Mutable(GetArenaForAllocation());
}
inline std::string* KFileInfo::release_hash32() {
  // @@protoc_insertion_point(field_release:kservice.KFileInfo.hash32)
  return _impl_.hash32_.Release();
}
inline void KFileInfo::set_allocated_hash32(std::string* hash32) {
  if (hash32 != nullptr) {
    
  } else {
    
  }
  _impl_.hash32_.SetAllocated(hash32, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.hash32_.IsDefault()) {
    _impl_.hash32_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:kservice.KFileInfo.hash32)
}

// string torrentHash = 4;
inline void KFileInfo::clear_torrenthash() {
  _impl_.torrenthash_.ClearToEmpty();
}
inline const std::string& KFileInfo::torrenthash() const {
  // @@protoc_insertion_point(field_get:kservice.KFileInfo.torrentHash)
  return _internal_torrenthash();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void KFileInfo::set_torrenthash(ArgT0&& arg0, ArgT... args) {
 
 _impl_.torrenthash_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:kservice.KFileInfo.torrentHash)
}
inline std::string* KFileInfo::mutable_torrenthash() {
  std::string* _s = _internal_mutable_torrenthash();
  // @@protoc_insertion_point(field_mutable:kservice.KFileInfo.torrentHash)
  return _s;
}
inline const std::string& KFileInfo::_internal_torrenthash() const {
  return _impl_.torrenthash_.Get();
}
inline void KFileInfo::_internal_set_torrenthash(const std::string& value) {
  
  _impl_.torrenthash_.Set(value, GetArenaForAllocation());
}
inline std::string* KFileInfo::_internal_mutable_torrenthash() {
  
  return _impl_.torrenthash_.Mutable(GetArenaForAllocation());
}
inline std::string* KFileInfo::release_torrenthash() {
  // @@protoc_insertion_point(field_release:kservice.KFileInfo.torrentHash)
  return _impl_.torrenthash_.Release();
}
inline void KFileInfo::set_allocated_torrenthash(std::string* torrenthash) {
  if (torrenthash != nullptr) {
    
  } else {
    
  }
  _impl_.torrenthash_.SetAllocated(torrenthash, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.torrenthash_.IsDefault()) {
    _impl_.torrenthash_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:kservice.KFileInfo.torrentHash)
}

// string url = 5;
inline void KFileInfo::clear_url() {
  _impl_.url_.ClearToEmpty();
}
inline const std::string& KFileInfo::url() const {
  // @@protoc_insertion_point(field_get:kservice.KFileInfo.url)
  return _internal_url();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void KFileInfo::set_url(ArgT0&& arg0, ArgT... args) {
 
 _impl_.url_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:kservice.KFileInfo.url)
}
inline std::string* KFileInfo::mutable_url() {
  std::string* _s = _internal_mutable_url();
  // @@protoc_insertion_point(field_mutable:kservice.KFileInfo.url)
  return _s;
}
inline const std::string& KFileInfo::_internal_url() const {
  return _impl_.url_.Get();
}
inline void KFileInfo::_internal_set_url(const std::string& value) {
  
  _impl_.url_.Set(value, GetArenaForAllocation());
}
inline std::string* KFileInfo::_internal_mutable_url() {
  
  return _impl_.url_.Mutable(GetArenaForAllocation());
}
inline std::string* KFileInfo::release_url() {
  // @@protoc_insertion_point(field_release:kservice.KFileInfo.url)
  return _impl_.url_.Release();
}
inline void KFileInfo::set_allocated_url(std::string* url) {
  if (url != nullptr) {
    
  } else {
    
  }
  _impl_.url_.SetAllocated(url, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.url_.IsDefault()) {
    _impl_.url_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:kservice.KFileInfo.url)
}

// int64 durationMs = 6;
inline void KFileInfo::clear_durationms() {
  _impl_.durationms_ = int64_t{0};
}
inline int64_t KFileInfo::_internal_durationms() const {
  return _impl_.durationms_;
}
inline int64_t KFileInfo::durationms() const {
  // @@protoc_insertion_point(field_get:kservice.KFileInfo.durationMs)
  return _internal_durationms();
}
inline void KFileInfo::_internal_set_durationms(int64_t value) {
  
  _impl_.durationms_ = value;
}
inline void KFileInfo::set_durationms(int64_t value) {
  _internal_set_durationms(value);
  // @@protoc_insertion_point(field_set:kservice.KFileInfo.durationMs)
}

// int64 fileSize = 7;
inline void KFileInfo::clear_filesize() {
  _impl_.filesize_ = int64_t{0};
}
inline int64_t KFileInfo::_internal_filesize() const {
  return _impl_.filesize_;
}
inline int64_t KFileInfo::filesize() const {
  // @@protoc_insertion_point(field_get:kservice.KFileInfo.fileSize)
  return _internal_filesize();
}
inline void KFileInfo::_internal_set_filesize(int64_t value) {
  
  _impl_.filesize_ = value;
}
inline void KFileInfo::set_filesize(int64_t value) {
  _internal_set_filesize(value);
  // @@protoc_insertion_point(field_set:kservice.KFileInfo.fileSize)
}

// bool isLocal = 8;
inline void KFileInfo::clear_islocal() {
  _impl_.islocal_ = false;
}
inline bool KFileInfo::_internal_islocal() const {
  return _impl_.islocal_;
}
inline bool KFileInfo::islocal() const {
  // @@protoc_insertion_point(field_get:kservice.KFileInfo.isLocal)
  return _internal_islocal();
}
inline void KFileInfo::_internal_set_islocal(bool value) {
  
  _impl_.islocal_ = value;
}
inline void KFileInfo::set_islocal(bool value) {
  _internal_set_islocal(value);
  // @@protoc_insertion_point(field_set:kservice.KFileInfo.isLocal)
}

// -------------------------------------------------------------------

// RecoRequest

// .kservice.EventHeader header = 1;
inline bool RecoRequest::_internal_has_header() const {
  return this != internal_default_instance() && _impl_.header_ != nullptr;
}
inline bool RecoRequest::has_header() const {
  return _internal_has_header();
}
inline void RecoRequest::clear_header() {
  if (GetArenaForAllocation() == nullptr && _impl_.header_ != nullptr) {
    delete _impl_.header_;
  }
  _impl_.header_ = nullptr;
}
inline const ::kservice::EventHeader& RecoRequest::_internal_header() const {
  const ::kservice::EventHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::kservice::EventHeader&>(
      ::kservice::_EventHeader_default_instance_);
}
inline const ::kservice::EventHeader& RecoRequest::header() const {
  // @@protoc_insertion_point(field_get:kservice.RecoRequest.header)
  return _internal_header();
}
inline void RecoRequest::unsafe_arena_set_allocated_header(
    ::kservice::EventHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kservice.RecoRequest.header)
}
inline ::kservice::EventHeader* RecoRequest::release_header() {
  
  ::kservice::EventHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::kservice::EventHeader* RecoRequest::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:kservice.RecoRequest.header)
  
  ::kservice::EventHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::kservice::EventHeader* RecoRequest::_internal_mutable_header() {
  
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::kservice::EventHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::kservice::EventHeader* RecoRequest::mutable_header() {
  ::kservice::EventHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:kservice.RecoRequest.header)
  return _msg;
}
inline void RecoRequest::set_allocated_header(::kservice::EventHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.header_;
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(header);
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:kservice.RecoRequest.header)
}

// .kservice.KFileInfo fileInfo = 2;
inline bool RecoRequest::_internal_has_fileinfo() const {
  return this != internal_default_instance() && _impl_.fileinfo_ != nullptr;
}
inline bool RecoRequest::has_fileinfo() const {
  return _internal_has_fileinfo();
}
inline void RecoRequest::clear_fileinfo() {
  if (GetArenaForAllocation() == nullptr && _impl_.fileinfo_ != nullptr) {
    delete _impl_.fileinfo_;
  }
  _impl_.fileinfo_ = nullptr;
}
inline const ::kservice::KFileInfo& RecoRequest::_internal_fileinfo() const {
  const ::kservice::KFileInfo* p = _impl_.fileinfo_;
  return p != nullptr ? *p : reinterpret_cast<const ::kservice::KFileInfo&>(
      ::kservice::_KFileInfo_default_instance_);
}
inline const ::kservice::KFileInfo& RecoRequest::fileinfo() const {
  // @@protoc_insertion_point(field_get:kservice.RecoRequest.fileInfo)
  return _internal_fileinfo();
}
inline void RecoRequest::unsafe_arena_set_allocated_fileinfo(
    ::kservice::KFileInfo* fileinfo) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.fileinfo_);
  }
  _impl_.fileinfo_ = fileinfo;
  if (fileinfo) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kservice.RecoRequest.fileInfo)
}
inline ::kservice::KFileInfo* RecoRequest::release_fileinfo() {
  
  ::kservice::KFileInfo* temp = _impl_.fileinfo_;
  _impl_.fileinfo_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::kservice::KFileInfo* RecoRequest::unsafe_arena_release_fileinfo() {
  // @@protoc_insertion_point(field_release:kservice.RecoRequest.fileInfo)
  
  ::kservice::KFileInfo* temp = _impl_.fileinfo_;
  _impl_.fileinfo_ = nullptr;
  return temp;
}
inline ::kservice::KFileInfo* RecoRequest::_internal_mutable_fileinfo() {
  
  if (_impl_.fileinfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::kservice::KFileInfo>(GetArenaForAllocation());
    _impl_.fileinfo_ = p;
  }
  return _impl_.fileinfo_;
}
inline ::kservice::KFileInfo* RecoRequest::mutable_fileinfo() {
  ::kservice::KFileInfo* _msg = _internal_mutable_fileinfo();
  // @@protoc_insertion_point(field_mutable:kservice.RecoRequest.fileInfo)
  return _msg;
}
inline void RecoRequest::set_allocated_fileinfo(::kservice::KFileInfo* fileinfo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.fileinfo_;
  }
  if (fileinfo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(fileinfo);
    if (message_arena != submessage_arena) {
      fileinfo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, fileinfo, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.fileinfo_ = fileinfo;
  // @@protoc_insertion_point(field_set_allocated:kservice.RecoRequest.fileInfo)
}

// -------------------------------------------------------------------

// DanmuSource

// .kservice.DanmuSourceType type = 1;
inline void DanmuSource::clear_type() {
  _impl_.type_ = 0;
}
inline ::kservice::DanmuSourceType DanmuSource::_internal_type() const {
  return static_cast< ::kservice::DanmuSourceType >(_impl_.type_);
}
inline ::kservice::DanmuSourceType DanmuSource::type() const {
  // @@protoc_insertion_point(field_get:kservice.DanmuSource.type)
  return _internal_type();
}
inline void DanmuSource::_internal_set_type(::kservice::DanmuSourceType value) {
  
  _impl_.type_ = value;
}
inline void DanmuSource::set_type(::kservice::DanmuSourceType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:kservice.DanmuSource.type)
}

// string title = 2;
inline void DanmuSource::clear_title() {
  _impl_.title_.ClearToEmpty();
}
inline const std::string& DanmuSource::title() const {
  // @@protoc_insertion_point(field_get:kservice.DanmuSource.title)
  return _internal_title();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DanmuSource::set_title(ArgT0&& arg0, ArgT... args) {
 
 _impl_.title_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:kservice.DanmuSource.title)
}
inline std::string* DanmuSource::mutable_title() {
  std::string* _s = _internal_mutable_title();
  // @@protoc_insertion_point(field_mutable:kservice.DanmuSource.title)
  return _s;
}
inline const std::string& DanmuSource::_internal_title() const {
  return _impl_.title_.Get();
}
inline void DanmuSource::_internal_set_title(const std::string& value) {
  
  _impl_.title_.Set(value, GetArenaForAllocation());
}
inline std::string* DanmuSource::_internal_mutable_title() {
  
  return _impl_.title_.Mutable(GetArenaForAllocation());
}
inline std::string* DanmuSource::release_title() {
  // @@protoc_insertion_point(field_release:kservice.DanmuSource.title)
  return _impl_.title_.Release();
}
inline void DanmuSource::set_allocated_title(std::string* title) {
  if (title != nullptr) {
    
  } else {
    
  }
  _impl_.title_.SetAllocated(title, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.title_.IsDefault()) {
    _impl_.title_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:kservice.DanmuSource.title)
}

// string scriptId = 3;
inline void DanmuSource::clear_scriptid() {
  _impl_.scriptid_.ClearToEmpty();
}
inline const std::string& DanmuSource::scriptid() const {
  // @@protoc_insertion_point(field_get:kservice.DanmuSource.scriptId)
  return _internal_scriptid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DanmuSource::set_scriptid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.scriptid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:kservice.DanmuSource.scriptId)
}
inline std::string* DanmuSource::mutable_scriptid() {
  std::string* _s = _internal_mutable_scriptid();
  // @@protoc_insertion_point(field_mutable:kservice.DanmuSource.scriptId)
  return _s;
}
inline const std::string& DanmuSource::_internal_scriptid() const {
  return _impl_.scriptid_.Get();
}
inline void DanmuSource::_internal_set_scriptid(const std::string& value) {
  
  _impl_.scriptid_.Set(value, GetArenaForAllocation());
}
inline std::string* DanmuSource::_internal_mutable_scriptid() {
  
  return _impl_.scriptid_.Mutable(GetArenaForAllocation());
}
inline std::string* DanmuSource::release_scriptid() {
  // @@protoc_insertion_point(field_release:kservice.DanmuSource.scriptId)
  return _impl_.scriptid_.Release();
}
inline void DanmuSource::set_allocated_scriptid(std::string* scriptid) {
  if (scriptid != nullptr) {
    
  } else {
    
  }
  _impl_.scriptid_.SetAllocated(scriptid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.scriptid_.IsDefault()) {
    _impl_.scriptid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:kservice.DanmuSource.scriptId)
}

// string scriptData = 4;
inline void DanmuSource::clear_scriptdata() {
  _impl_.scriptdata_.ClearToEmpty();
}
inline const std::string& DanmuSource::scriptdata() const {
  // @@protoc_insertion_point(field_get:kservice.DanmuSource.scriptData)
  return _internal_scriptdata();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DanmuSource::set_scriptdata(ArgT0&& arg0, ArgT... args) {
 
 _impl_.scriptdata_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:kservice.DanmuSource.scriptData)
}
inline std::string* DanmuSource::mutable_scriptdata() {
  std::string* _s = _internal_mutable_scriptdata();
  // @@protoc_insertion_point(field_mutable:kservice.DanmuSource.scriptData)
  return _s;
}
inline const std::string& DanmuSource::_internal_scriptdata() const {
  return _impl_.scriptdata_.Get();
}
inline void DanmuSource::_internal_set_scriptdata(const std::string& value) {
  
  _impl_.scriptdata_.Set(value, GetArenaForAllocation());
}
inline std::string* DanmuSource::_internal_mutable_scriptdata() {
  
  return _impl_.scriptdata_.Mutable(GetArenaForAllocation());
}
inline std::string* DanmuSource::release_scriptdata() {
  // @@protoc_insertion_point(field_release:kservice.DanmuSource.scriptData)
  return _impl_.scriptdata_.Release();
}
inline void DanmuSource::set_allocated_scriptdata(std::string* scriptdata) {
  if (scriptdata != nullptr) {
    
  } else {
    
  }
  _impl_.scriptdata_.SetAllocated(scriptdata, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.scriptdata_.IsDefault()) {
    _impl_.scriptdata_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:kservice.DanmuSource.scriptData)
}

// int32 durationSeconds = 5;
inline void DanmuSource::clear_durationseconds() {
  _impl_.durationseconds_ = 0;
}
inline int32_t DanmuSource::_internal_durationseconds() const {
  return _impl_.durationseconds_;
}
inline int32_t DanmuSource::durationseconds() const {
  // @@protoc_insertion_point(field_get:kservice.DanmuSource.durationSeconds)
  return _internal_durationseconds();
}
inline void DanmuSource::_internal_set_durationseconds(int32_t value) {
  
  _impl_.durationseconds_ = value;
}
inline void DanmuSource::set_durationseconds(int32_t value) {
  _internal_set_durationseconds(value);
  // @@protoc_insertion_point(field_set:kservice.DanmuSource.durationSeconds)
}

// -------------------------------------------------------------------

// InfoSource

// .kservice.InfoSourceType type = 1;
inline void InfoSource::clear_type() {
  _impl_.type_ = 0;
}
inline ::kservice::InfoSourceType InfoSource::_internal_type() const {
  return static_cast< ::kservice::InfoSourceType >(_impl_.type_);
}
inline ::kservice::InfoSourceType InfoSource::type() const {
  // @@protoc_insertion_point(field_get:kservice.InfoSource.type)
  return _internal_type();
}
inline void InfoSource::_internal_set_type(::kservice::InfoSourceType value) {
  
  _impl_.type_ = value;
}
inline void InfoSource::set_type(::kservice::InfoSourceType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:kservice.InfoSource.type)
}

// string scriptId = 2;
inline void InfoSource::clear_scriptid() {
  _impl_.scriptid_.ClearToEmpty();
}
inline const std::string& InfoSource::scriptid() const {
  // @@protoc_insertion_point(field_get:kservice.InfoSource.scriptId)
  return _internal_scriptid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void InfoSource::set_scriptid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.scriptid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:kservice.InfoSource.scriptId)
}
inline std::string* InfoSource::mutable_scriptid() {
  std::string* _s = _internal_mutable_scriptid();
  // @@protoc_insertion_point(field_mutable:kservice.InfoSource.scriptId)
  return _s;
}
inline const std::string& InfoSource::_internal_scriptid() const {
  return _impl_.scriptid_.Get();
}
inline void InfoSource::_internal_set_scriptid(const std::string& value) {
  
  _impl_.scriptid_.Set(value, GetArenaForAllocation());
}
inline std::string* InfoSource::_internal_mutable_scriptid() {
  
  return _impl_.scriptid_.Mutable(GetArenaForAllocation());
}
inline std::string* InfoSource::release_scriptid() {
  // @@protoc_insertion_point(field_release:kservice.InfoSource.scriptId)
  return _impl_.scriptid_.Release();
}
inline void InfoSource::set_allocated_scriptid(std::string* scriptid) {
  if (scriptid != nullptr) {
    
  } else {
    
  }
  _impl_.scriptid_.SetAllocated(scriptid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.scriptid_.IsDefault()) {
    _impl_.scriptid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:kservice.InfoSource.scriptId)
}

// string scriptData = 3;
inline void InfoSource::clear_scriptdata() {
  _impl_.scriptdata_.ClearToEmpty();
}
inline const std::string& InfoSource::scriptdata() const {
  // @@protoc_insertion_point(field_get:kservice.InfoSource.scriptData)
  return _internal_scriptdata();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void InfoSource::set_scriptdata(ArgT0&& arg0, ArgT... args) {
 
 _impl_.scriptdata_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:kservice.InfoSource.scriptData)
}
inline std::string* InfoSource::mutable_scriptdata() {
  std::string* _s = _internal_mutable_scriptdata();
  // @@protoc_insertion_point(field_mutable:kservice.InfoSource.scriptData)
  return _s;
}
inline const std::string& InfoSource::_internal_scriptdata() const {
  return _impl_.scriptdata_.Get();
}
inline void InfoSource::_internal_set_scriptdata(const std::string& value) {
  
  _impl_.scriptdata_.Set(value, GetArenaForAllocation());
}
inline std::string* InfoSource::_internal_mutable_scriptdata() {
  
  return _impl_.scriptdata_.Mutable(GetArenaForAllocation());
}
inline std::string* InfoSource::release_scriptdata() {
  // @@protoc_insertion_point(field_release:kservice.InfoSource.scriptData)
  return _impl_.scriptdata_.Release();
}
inline void InfoSource::set_allocated_scriptdata(std::string* scriptdata) {
  if (scriptdata != nullptr) {
    
  } else {
    
  }
  _impl_.scriptdata_.SetAllocated(scriptdata, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.scriptdata_.IsDefault()) {
    _impl_.scriptdata_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:kservice.InfoSource.scriptData)
}

// -------------------------------------------------------------------

// Pool

// string name = 1;
inline void Pool::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& Pool::name() const {
  // @@protoc_insertion_point(field_get:kservice.Pool.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Pool::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:kservice.Pool.name)
}
inline std::string* Pool::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:kservice.Pool.name)
  return _s;
}
inline const std::string& Pool::_internal_name() const {
  return _impl_.name_.Get();
}
inline void Pool::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* Pool::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* Pool::release_name() {
  // @@protoc_insertion_point(field_release:kservice.Pool.name)
  return _impl_.name_.Release();
}
inline void Pool::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:kservice.Pool.name)
}

// .kservice.EpType epType = 2;
inline void Pool::clear_eptype() {
  _impl_.eptype_ = 0;
}
inline ::kservice::EpType Pool::_internal_eptype() const {
  return static_cast< ::kservice::EpType >(_impl_.eptype_);
}
inline ::kservice::EpType Pool::eptype() const {
  // @@protoc_insertion_point(field_get:kservice.Pool.epType)
  return _internal_eptype();
}
inline void Pool::_internal_set_eptype(::kservice::EpType value) {
  
  _impl_.eptype_ = value;
}
inline void Pool::set_eptype(::kservice::EpType value) {
  _internal_set_eptype(value);
  // @@protoc_insertion_point(field_set:kservice.Pool.epType)
}

// string epName = 3;
inline void Pool::clear_epname() {
  _impl_.epname_.ClearToEmpty();
}
inline const std::string& Pool::epname() const {
  // @@protoc_insertion_point(field_get:kservice.Pool.epName)
  return _internal_epname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Pool::set_epname(ArgT0&& arg0, ArgT... args) {
 
 _impl_.epname_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:kservice.Pool.epName)
}
inline std::string* Pool::mutable_epname() {
  std::string* _s = _internal_mutable_epname();
  // @@protoc_insertion_point(field_mutable:kservice.Pool.epName)
  return _s;
}
inline const std::string& Pool::_internal_epname() const {
  return _impl_.epname_.Get();
}
inline void Pool::_internal_set_epname(const std::string& value) {
  
  _impl_.epname_.Set(value, GetArenaForAllocation());
}
inline std::string* Pool::_internal_mutable_epname() {
  
  return _impl_.epname_.Mutable(GetArenaForAllocation());
}
inline std::string* Pool::release_epname() {
  // @@protoc_insertion_point(field_release:kservice.Pool.epName)
  return _impl_.epname_.Release();
}
inline void Pool::set_allocated_epname(std::string* epname) {
  if (epname != nullptr) {
    
  } else {
    
  }
  _impl_.epname_.SetAllocated(epname, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.epname_.IsDefault()) {
    _impl_.epname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:kservice.Pool.epName)
}

// double epIndex = 4;
inline void Pool::clear_epindex() {
  _impl_.epindex_ = 0;
}
inline double Pool::_internal_epindex() const {
  return _impl_.epindex_;
}
inline double Pool::epindex() const {
  // @@protoc_insertion_point(field_get:kservice.Pool.epIndex)
  return _internal_epindex();
}
inline void Pool::_internal_set_epindex(double value) {
  
  _impl_.epindex_ = value;
}
inline void Pool::set_epindex(double value) {
  _internal_set_epindex(value);
  // @@protoc_insertion_point(field_set:kservice.Pool.epIndex)
}

// string poolid = 5;
inline void Pool::clear_poolid() {
  _impl_.poolid_.ClearToEmpty();
}
inline const std::string& Pool::poolid() const {
  // @@protoc_insertion_point(field_get:kservice.Pool.poolid)
  return _internal_poolid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Pool::set_poolid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.poolid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:kservice.Pool.poolid)
}
inline std::string* Pool::mutable_poolid() {
  std::string* _s = _internal_mutable_poolid();
  // @@protoc_insertion_point(field_mutable:kservice.Pool.poolid)
  return _s;
}
inline const std::string& Pool::_internal_poolid() const {
  return _impl_.poolid_.Get();
}
inline void Pool::_internal_set_poolid(const std::string& value) {
  
  _impl_.poolid_.Set(value, GetArenaForAllocation());
}
inline std::string* Pool::_internal_mutable_poolid() {
  
  return _impl_.poolid_.Mutable(GetArenaForAllocation());
}
inline std::string* Pool::release_poolid() {
  // @@protoc_insertion_point(field_release:kservice.Pool.poolid)
  return _impl_.poolid_.Release();
}
inline void Pool::set_allocated_poolid(std::string* poolid) {
  if (poolid != nullptr) {
    
  } else {
    
  }
  _impl_.poolid_.SetAllocated(poolid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.poolid_.IsDefault()) {
    _impl_.poolid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:kservice.Pool.poolid)
}

// -------------------------------------------------------------------

// RecoResponse

// .kservice.ResponseHeader header = 1;
inline bool RecoResponse::_internal_has_header() const {
  return this != internal_default_instance() && _impl_.header_ != nullptr;
}
inline bool RecoResponse::has_header() const {
  return _internal_has_header();
}
inline void RecoResponse::clear_header() {
  if (GetArenaForAllocation() == nullptr && _impl_.header_ != nullptr) {
    delete _impl_.header_;
  }
  _impl_.header_ = nullptr;
}
inline const ::kservice::ResponseHeader& RecoResponse::_internal_header() const {
  const ::kservice::ResponseHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::kservice::ResponseHeader&>(
      ::kservice::_ResponseHeader_default_instance_);
}
inline const ::kservice::ResponseHeader& RecoResponse::header() const {
  // @@protoc_insertion_point(field_get:kservice.RecoResponse.header)
  return _internal_header();
}
inline void RecoResponse::unsafe_arena_set_allocated_header(
    ::kservice::ResponseHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kservice.RecoResponse.header)
}
inline ::kservice::ResponseHeader* RecoResponse::release_header() {
  
  ::kservice::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::kservice::ResponseHeader* RecoResponse::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:kservice.RecoResponse.header)
  
  ::kservice::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::kservice::ResponseHeader* RecoResponse::_internal_mutable_header() {
  
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::kservice::ResponseHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::kservice::ResponseHeader* RecoResponse::mutable_header() {
  ::kservice::ResponseHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:kservice.RecoResponse.header)
  return _msg;
}
inline void RecoResponse::set_allocated_header(::kservice::ResponseHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.header_;
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(header);
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:kservice.RecoResponse.header)
}

// .kservice.Pool matchResult = 2;
inline bool RecoResponse::_internal_has_matchresult() const {
  return this != internal_default_instance() && _impl_.matchresult_ != nullptr;
}
inline bool RecoResponse::has_matchresult() const {
  return _internal_has_matchresult();
}
inline void RecoResponse::clear_matchresult() {
  if (GetArenaForAllocation() == nullptr && _impl_.matchresult_ != nullptr) {
    delete _impl_.matchresult_;
  }
  _impl_.matchresult_ = nullptr;
}
inline const ::kservice::Pool& RecoResponse::_internal_matchresult() const {
  const ::kservice::Pool* p = _impl_.matchresult_;
  return p != nullptr ? *p : reinterpret_cast<const ::kservice::Pool&>(
      ::kservice::_Pool_default_instance_);
}
inline const ::kservice::Pool& RecoResponse::matchresult() const {
  // @@protoc_insertion_point(field_get:kservice.RecoResponse.matchResult)
  return _internal_matchresult();
}
inline void RecoResponse::unsafe_arena_set_allocated_matchresult(
    ::kservice::Pool* matchresult) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.matchresult_);
  }
  _impl_.matchresult_ = matchresult;
  if (matchresult) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kservice.RecoResponse.matchResult)
}
inline ::kservice::Pool* RecoResponse::release_matchresult() {
  
  ::kservice::Pool* temp = _impl_.matchresult_;
  _impl_.matchresult_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::kservice::Pool* RecoResponse::unsafe_arena_release_matchresult() {
  // @@protoc_insertion_point(field_release:kservice.RecoResponse.matchResult)
  
  ::kservice::Pool* temp = _impl_.matchresult_;
  _impl_.matchresult_ = nullptr;
  return temp;
}
inline ::kservice::Pool* RecoResponse::_internal_mutable_matchresult() {
  
  if (_impl_.matchresult_ == nullptr) {
    auto* p = CreateMaybeMessage<::kservice::Pool>(GetArenaForAllocation());
    _impl_.matchresult_ = p;
  }
  return _impl_.matchresult_;
}
inline ::kservice::Pool* RecoResponse::mutable_matchresult() {
  ::kservice::Pool* _msg = _internal_mutable_matchresult();
  // @@protoc_insertion_point(field_mutable:kservice.RecoResponse.matchResult)
  return _msg;
}
inline void RecoResponse::set_allocated_matchresult(::kservice::Pool* matchresult) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.matchresult_;
  }
  if (matchresult) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(matchresult);
    if (message_arena != submessage_arena) {
      matchresult = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, matchresult, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.matchresult_ = matchresult;
  // @@protoc_insertion_point(field_set_allocated:kservice.RecoResponse.matchResult)
}

// repeated .kservice.InfoSource infoSources = 3;
inline int RecoResponse::_internal_infosources_size() const {
  return _impl_.infosources_.size();
}
inline int RecoResponse::infosources_size() const {
  return _internal_infosources_size();
}
inline void RecoResponse::clear_infosources() {
  _impl_.infosources_.Clear();
}
inline ::kservice::InfoSource* RecoResponse::mutable_infosources(int index) {
  // @@protoc_insertion_point(field_mutable:kservice.RecoResponse.infoSources)
  return _impl_.infosources_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::kservice::InfoSource >*
RecoResponse::mutable_infosources() {
  // @@protoc_insertion_point(field_mutable_list:kservice.RecoResponse.infoSources)
  return &_impl_.infosources_;
}
inline const ::kservice::InfoSource& RecoResponse::_internal_infosources(int index) const {
  return _impl_.infosources_.Get(index);
}
inline const ::kservice::InfoSource& RecoResponse::infosources(int index) const {
  // @@protoc_insertion_point(field_get:kservice.RecoResponse.infoSources)
  return _internal_infosources(index);
}
inline ::kservice::InfoSource* RecoResponse::_internal_add_infosources() {
  return _impl_.infosources_.Add();
}
inline ::kservice::InfoSource* RecoResponse::add_infosources() {
  ::kservice::InfoSource* _add = _internal_add_infosources();
  // @@protoc_insertion_point(field_add:kservice.RecoResponse.infoSources)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::kservice::InfoSource >&
RecoResponse::infosources() const {
  // @@protoc_insertion_point(field_list:kservice.RecoResponse.infoSources)
  return _impl_.infosources_;
}

// repeated .kservice.DanmuSource danmuSources = 4;
inline int RecoResponse::_internal_danmusources_size() const {
  return _impl_.danmusources_.size();
}
inline int RecoResponse::danmusources_size() const {
  return _internal_danmusources_size();
}
inline void RecoResponse::clear_danmusources() {
  _impl_.danmusources_.Clear();
}
inline ::kservice::DanmuSource* RecoResponse::mutable_danmusources(int index) {
  // @@protoc_insertion_point(field_mutable:kservice.RecoResponse.danmuSources)
  return _impl_.danmusources_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::kservice::DanmuSource >*
RecoResponse::mutable_danmusources() {
  // @@protoc_insertion_point(field_mutable_list:kservice.RecoResponse.danmuSources)
  return &_impl_.danmusources_;
}
inline const ::kservice::DanmuSource& RecoResponse::_internal_danmusources(int index) const {
  return _impl_.danmusources_.Get(index);
}
inline const ::kservice::DanmuSource& RecoResponse::danmusources(int index) const {
  // @@protoc_insertion_point(field_get:kservice.RecoResponse.danmuSources)
  return _internal_danmusources(index);
}
inline ::kservice::DanmuSource* RecoResponse::_internal_add_danmusources() {
  return _impl_.danmusources_.Add();
}
inline ::kservice::DanmuSource* RecoResponse::add_danmusources() {
  ::kservice::DanmuSource* _add = _internal_add_danmusources();
  // @@protoc_insertion_point(field_add:kservice.RecoResponse.danmuSources)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::kservice::DanmuSource >&
RecoResponse::danmusources() const {
  // @@protoc_insertion_point(field_list:kservice.RecoResponse.danmuSources)
  return _impl_.danmusources_;
}

// -------------------------------------------------------------------

// MatchEvent_Match

// .kservice.KFileInfo fileInfo = 1;
inline bool MatchEvent_Match::_internal_has_fileinfo() const {
  return this != internal_default_instance() && _impl_.fileinfo_ != nullptr;
}
inline bool MatchEvent_Match::has_fileinfo() const {
  return _internal_has_fileinfo();
}
inline void MatchEvent_Match::clear_fileinfo() {
  if (GetArenaForAllocation() == nullptr && _impl_.fileinfo_ != nullptr) {
    delete _impl_.fileinfo_;
  }
  _impl_.fileinfo_ = nullptr;
}
inline const ::kservice::KFileInfo& MatchEvent_Match::_internal_fileinfo() const {
  const ::kservice::KFileInfo* p = _impl_.fileinfo_;
  return p != nullptr ? *p : reinterpret_cast<const ::kservice::KFileInfo&>(
      ::kservice::_KFileInfo_default_instance_);
}
inline const ::kservice::KFileInfo& MatchEvent_Match::fileinfo() const {
  // @@protoc_insertion_point(field_get:kservice.MatchEvent.Match.fileInfo)
  return _internal_fileinfo();
}
inline void MatchEvent_Match::unsafe_arena_set_allocated_fileinfo(
    ::kservice::KFileInfo* fileinfo) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.fileinfo_);
  }
  _impl_.fileinfo_ = fileinfo;
  if (fileinfo) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kservice.MatchEvent.Match.fileInfo)
}
inline ::kservice::KFileInfo* MatchEvent_Match::release_fileinfo() {
  
  ::kservice::KFileInfo* temp = _impl_.fileinfo_;
  _impl_.fileinfo_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::kservice::KFileInfo* MatchEvent_Match::unsafe_arena_release_fileinfo() {
  // @@protoc_insertion_point(field_release:kservice.MatchEvent.Match.fileInfo)
  
  ::kservice::KFileInfo* temp = _impl_.fileinfo_;
  _impl_.fileinfo_ = nullptr;
  return temp;
}
inline ::kservice::KFileInfo* MatchEvent_Match::_internal_mutable_fileinfo() {
  
  if (_impl_.fileinfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::kservice::KFileInfo>(GetArenaForAllocation());
    _impl_.fileinfo_ = p;
  }
  return _impl_.fileinfo_;
}
inline ::kservice::KFileInfo* MatchEvent_Match::mutable_fileinfo() {
  ::kservice::KFileInfo* _msg = _internal_mutable_fileinfo();
  // @@protoc_insertion_point(field_mutable:kservice.MatchEvent.Match.fileInfo)
  return _msg;
}
inline void MatchEvent_Match::set_allocated_fileinfo(::kservice::KFileInfo* fileinfo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.fileinfo_;
  }
  if (fileinfo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(fileinfo);
    if (message_arena != submessage_arena) {
      fileinfo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, fileinfo, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.fileinfo_ = fileinfo;
  // @@protoc_insertion_point(field_set_allocated:kservice.MatchEvent.Match.fileInfo)
}

// .kservice.Pool poolInfo = 2;
inline bool MatchEvent_Match::_internal_has_poolinfo() const {
  return this != internal_default_instance() && _impl_.poolinfo_ != nullptr;
}
inline bool MatchEvent_Match::has_poolinfo() const {
  return _internal_has_poolinfo();
}
inline void MatchEvent_Match::clear_poolinfo() {
  if (GetArenaForAllocation() == nullptr && _impl_.poolinfo_ != nullptr) {
    delete _impl_.poolinfo_;
  }
  _impl_.poolinfo_ = nullptr;
}
inline const ::kservice::Pool& MatchEvent_Match::_internal_poolinfo() const {
  const ::kservice::Pool* p = _impl_.poolinfo_;
  return p != nullptr ? *p : reinterpret_cast<const ::kservice::Pool&>(
      ::kservice::_Pool_default_instance_);
}
inline const ::kservice::Pool& MatchEvent_Match::poolinfo() const {
  // @@protoc_insertion_point(field_get:kservice.MatchEvent.Match.poolInfo)
  return _internal_poolinfo();
}
inline void MatchEvent_Match::unsafe_arena_set_allocated_poolinfo(
    ::kservice::Pool* poolinfo) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.poolinfo_);
  }
  _impl_.poolinfo_ = poolinfo;
  if (poolinfo) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kservice.MatchEvent.Match.poolInfo)
}
inline ::kservice::Pool* MatchEvent_Match::release_poolinfo() {
  
  ::kservice::Pool* temp = _impl_.poolinfo_;
  _impl_.poolinfo_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::kservice::Pool* MatchEvent_Match::unsafe_arena_release_poolinfo() {
  // @@protoc_insertion_point(field_release:kservice.MatchEvent.Match.poolInfo)
  
  ::kservice::Pool* temp = _impl_.poolinfo_;
  _impl_.poolinfo_ = nullptr;
  return temp;
}
inline ::kservice::Pool* MatchEvent_Match::_internal_mutable_poolinfo() {
  
  if (_impl_.poolinfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::kservice::Pool>(GetArenaForAllocation());
    _impl_.poolinfo_ = p;
  }
  return _impl_.poolinfo_;
}
inline ::kservice::Pool* MatchEvent_Match::mutable_poolinfo() {
  ::kservice::Pool* _msg = _internal_mutable_poolinfo();
  // @@protoc_insertion_point(field_mutable:kservice.MatchEvent.Match.poolInfo)
  return _msg;
}
inline void MatchEvent_Match::set_allocated_poolinfo(::kservice::Pool* poolinfo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.poolinfo_;
  }
  if (poolinfo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(poolinfo);
    if (message_arena != submessage_arena) {
      poolinfo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, poolinfo, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.poolinfo_ = poolinfo;
  // @@protoc_insertion_point(field_set_allocated:kservice.MatchEvent.Match.poolInfo)
}

// repeated .kservice.InfoSource infoSources = 3;
inline int MatchEvent_Match::_internal_infosources_size() const {
  return _impl_.infosources_.size();
}
inline int MatchEvent_Match::infosources_size() const {
  return _internal_infosources_size();
}
inline void MatchEvent_Match::clear_infosources() {
  _impl_.infosources_.Clear();
}
inline ::kservice::InfoSource* MatchEvent_Match::mutable_infosources(int index) {
  // @@protoc_insertion_point(field_mutable:kservice.MatchEvent.Match.infoSources)
  return _impl_.infosources_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::kservice::InfoSource >*
MatchEvent_Match::mutable_infosources() {
  // @@protoc_insertion_point(field_mutable_list:kservice.MatchEvent.Match.infoSources)
  return &_impl_.infosources_;
}
inline const ::kservice::InfoSource& MatchEvent_Match::_internal_infosources(int index) const {
  return _impl_.infosources_.Get(index);
}
inline const ::kservice::InfoSource& MatchEvent_Match::infosources(int index) const {
  // @@protoc_insertion_point(field_get:kservice.MatchEvent.Match.infoSources)
  return _internal_infosources(index);
}
inline ::kservice::InfoSource* MatchEvent_Match::_internal_add_infosources() {
  return _impl_.infosources_.Add();
}
inline ::kservice::InfoSource* MatchEvent_Match::add_infosources() {
  ::kservice::InfoSource* _add = _internal_add_infosources();
  // @@protoc_insertion_point(field_add:kservice.MatchEvent.Match.infoSources)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::kservice::InfoSource >&
MatchEvent_Match::infosources() const {
  // @@protoc_insertion_point(field_list:kservice.MatchEvent.Match.infoSources)
  return _impl_.infosources_;
}

// -------------------------------------------------------------------

// MatchEvent

// .kservice.EventHeader header = 1;
inline bool MatchEvent::_internal_has_header() const {
  return this != internal_default_instance() && _impl_.header_ != nullptr;
}
inline bool MatchEvent::has_header() const {
  return _internal_has_header();
}
inline void MatchEvent::clear_header() {
  if (GetArenaForAllocation() == nullptr && _impl_.header_ != nullptr) {
    delete _impl_.header_;
  }
  _impl_.header_ = nullptr;
}
inline const ::kservice::EventHeader& MatchEvent::_internal_header() const {
  const ::kservice::EventHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::kservice::EventHeader&>(
      ::kservice::_EventHeader_default_instance_);
}
inline const ::kservice::EventHeader& MatchEvent::header() const {
  // @@protoc_insertion_point(field_get:kservice.MatchEvent.header)
  return _internal_header();
}
inline void MatchEvent::unsafe_arena_set_allocated_header(
    ::kservice::EventHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kservice.MatchEvent.header)
}
inline ::kservice::EventHeader* MatchEvent::release_header() {
  
  ::kservice::EventHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::kservice::EventHeader* MatchEvent::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:kservice.MatchEvent.header)
  
  ::kservice::EventHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::kservice::EventHeader* MatchEvent::_internal_mutable_header() {
  
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::kservice::EventHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::kservice::EventHeader* MatchEvent::mutable_header() {
  ::kservice::EventHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:kservice.MatchEvent.header)
  return _msg;
}
inline void MatchEvent::set_allocated_header(::kservice::EventHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.header_;
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(header);
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:kservice.MatchEvent.header)
}

// repeated .kservice.MatchEvent.Match matches = 2;
inline int MatchEvent::_internal_matches_size() const {
  return _impl_.matches_.size();
}
inline int MatchEvent::matches_size() const {
  return _internal_matches_size();
}
inline void MatchEvent::clear_matches() {
  _impl_.matches_.Clear();
}
inline ::kservice::MatchEvent_Match* MatchEvent::mutable_matches(int index) {
  // @@protoc_insertion_point(field_mutable:kservice.MatchEvent.matches)
  return _impl_.matches_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::kservice::MatchEvent_Match >*
MatchEvent::mutable_matches() {
  // @@protoc_insertion_point(field_mutable_list:kservice.MatchEvent.matches)
  return &_impl_.matches_;
}
inline const ::kservice::MatchEvent_Match& MatchEvent::_internal_matches(int index) const {
  return _impl_.matches_.Get(index);
}
inline const ::kservice::MatchEvent_Match& MatchEvent::matches(int index) const {
  // @@protoc_insertion_point(field_get:kservice.MatchEvent.matches)
  return _internal_matches(index);
}
inline ::kservice::MatchEvent_Match* MatchEvent::_internal_add_matches() {
  return _impl_.matches_.Add();
}
inline ::kservice::MatchEvent_Match* MatchEvent::add_matches() {
  ::kservice::MatchEvent_Match* _add = _internal_add_matches();
  // @@protoc_insertion_point(field_add:kservice.MatchEvent.matches)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::kservice::MatchEvent_Match >&
MatchEvent::matches() const {
  // @@protoc_insertion_point(field_list:kservice.MatchEvent.matches)
  return _impl_.matches_;
}

// -------------------------------------------------------------------

// AddDanmuSourceEvent_DanmuPoolSource

// .kservice.Pool poolInfo = 1;
inline bool AddDanmuSourceEvent_DanmuPoolSource::_internal_has_poolinfo() const {
  return this != internal_default_instance() && _impl_.poolinfo_ != nullptr;
}
inline bool AddDanmuSourceEvent_DanmuPoolSource::has_poolinfo() const {
  return _internal_has_poolinfo();
}
inline void AddDanmuSourceEvent_DanmuPoolSource::clear_poolinfo() {
  if (GetArenaForAllocation() == nullptr && _impl_.poolinfo_ != nullptr) {
    delete _impl_.poolinfo_;
  }
  _impl_.poolinfo_ = nullptr;
}
inline const ::kservice::Pool& AddDanmuSourceEvent_DanmuPoolSource::_internal_poolinfo() const {
  const ::kservice::Pool* p = _impl_.poolinfo_;
  return p != nullptr ? *p : reinterpret_cast<const ::kservice::Pool&>(
      ::kservice::_Pool_default_instance_);
}
inline const ::kservice::Pool& AddDanmuSourceEvent_DanmuPoolSource::poolinfo() const {
  // @@protoc_insertion_point(field_get:kservice.AddDanmuSourceEvent.DanmuPoolSource.poolInfo)
  return _internal_poolinfo();
}
inline void AddDanmuSourceEvent_DanmuPoolSource::unsafe_arena_set_allocated_poolinfo(
    ::kservice::Pool* poolinfo) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.poolinfo_);
  }
  _impl_.poolinfo_ = poolinfo;
  if (poolinfo) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kservice.AddDanmuSourceEvent.DanmuPoolSource.poolInfo)
}
inline ::kservice::Pool* AddDanmuSourceEvent_DanmuPoolSource::release_poolinfo() {
  
  ::kservice::Pool* temp = _impl_.poolinfo_;
  _impl_.poolinfo_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::kservice::Pool* AddDanmuSourceEvent_DanmuPoolSource::unsafe_arena_release_poolinfo() {
  // @@protoc_insertion_point(field_release:kservice.AddDanmuSourceEvent.DanmuPoolSource.poolInfo)
  
  ::kservice::Pool* temp = _impl_.poolinfo_;
  _impl_.poolinfo_ = nullptr;
  return temp;
}
inline ::kservice::Pool* AddDanmuSourceEvent_DanmuPoolSource::_internal_mutable_poolinfo() {
  
  if (_impl_.poolinfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::kservice::Pool>(GetArenaForAllocation());
    _impl_.poolinfo_ = p;
  }
  return _impl_.poolinfo_;
}
inline ::kservice::Pool* AddDanmuSourceEvent_DanmuPoolSource::mutable_poolinfo() {
  ::kservice::Pool* _msg = _internal_mutable_poolinfo();
  // @@protoc_insertion_point(field_mutable:kservice.AddDanmuSourceEvent.DanmuPoolSource.poolInfo)
  return _msg;
}
inline void AddDanmuSourceEvent_DanmuPoolSource::set_allocated_poolinfo(::kservice::Pool* poolinfo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.poolinfo_;
  }
  if (poolinfo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(poolinfo);
    if (message_arena != submessage_arena) {
      poolinfo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, poolinfo, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.poolinfo_ = poolinfo;
  // @@protoc_insertion_point(field_set_allocated:kservice.AddDanmuSourceEvent.DanmuPoolSource.poolInfo)
}

// repeated .kservice.DanmuSource danmuSources = 2;
inline int AddDanmuSourceEvent_DanmuPoolSource::_internal_danmusources_size() const {
  return _impl_.danmusources_.size();
}
inline int AddDanmuSourceEvent_DanmuPoolSource::danmusources_size() const {
  return _internal_danmusources_size();
}
inline void AddDanmuSourceEvent_DanmuPoolSource::clear_danmusources() {
  _impl_.danmusources_.Clear();
}
inline ::kservice::DanmuSource* AddDanmuSourceEvent_DanmuPoolSource::mutable_danmusources(int index) {
  // @@protoc_insertion_point(field_mutable:kservice.AddDanmuSourceEvent.DanmuPoolSource.danmuSources)
  return _impl_.danmusources_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::kservice::DanmuSource >*
AddDanmuSourceEvent_DanmuPoolSource::mutable_danmusources() {
  // @@protoc_insertion_point(field_mutable_list:kservice.AddDanmuSourceEvent.DanmuPoolSource.danmuSources)
  return &_impl_.danmusources_;
}
inline const ::kservice::DanmuSource& AddDanmuSourceEvent_DanmuPoolSource::_internal_danmusources(int index) const {
  return _impl_.danmusources_.Get(index);
}
inline const ::kservice::DanmuSource& AddDanmuSourceEvent_DanmuPoolSource::danmusources(int index) const {
  // @@protoc_insertion_point(field_get:kservice.AddDanmuSourceEvent.DanmuPoolSource.danmuSources)
  return _internal_danmusources(index);
}
inline ::kservice::DanmuSource* AddDanmuSourceEvent_DanmuPoolSource::_internal_add_danmusources() {
  return _impl_.danmusources_.Add();
}
inline ::kservice::DanmuSource* AddDanmuSourceEvent_DanmuPoolSource::add_danmusources() {
  ::kservice::DanmuSource* _add = _internal_add_danmusources();
  // @@protoc_insertion_point(field_add:kservice.AddDanmuSourceEvent.DanmuPoolSource.danmuSources)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::kservice::DanmuSource >&
AddDanmuSourceEvent_DanmuPoolSource::danmusources() const {
  // @@protoc_insertion_point(field_list:kservice.AddDanmuSourceEvent.DanmuPoolSource.danmuSources)
  return _impl_.danmusources_;
}

// -------------------------------------------------------------------

// AddDanmuSourceEvent

// .kservice.EventHeader header = 1;
inline bool AddDanmuSourceEvent::_internal_has_header() const {
  return this != internal_default_instance() && _impl_.header_ != nullptr;
}
inline bool AddDanmuSourceEvent::has_header() const {
  return _internal_has_header();
}
inline void AddDanmuSourceEvent::clear_header() {
  if (GetArenaForAllocation() == nullptr && _impl_.header_ != nullptr) {
    delete _impl_.header_;
  }
  _impl_.header_ = nullptr;
}
inline const ::kservice::EventHeader& AddDanmuSourceEvent::_internal_header() const {
  const ::kservice::EventHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::kservice::EventHeader&>(
      ::kservice::_EventHeader_default_instance_);
}
inline const ::kservice::EventHeader& AddDanmuSourceEvent::header() const {
  // @@protoc_insertion_point(field_get:kservice.AddDanmuSourceEvent.header)
  return _internal_header();
}
inline void AddDanmuSourceEvent::unsafe_arena_set_allocated_header(
    ::kservice::EventHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kservice.AddDanmuSourceEvent.header)
}
inline ::kservice::EventHeader* AddDanmuSourceEvent::release_header() {
  
  ::kservice::EventHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::kservice::EventHeader* AddDanmuSourceEvent::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:kservice.AddDanmuSourceEvent.header)
  
  ::kservice::EventHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::kservice::EventHeader* AddDanmuSourceEvent::_internal_mutable_header() {
  
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::kservice::EventHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::kservice::EventHeader* AddDanmuSourceEvent::mutable_header() {
  ::kservice::EventHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:kservice.AddDanmuSourceEvent.header)
  return _msg;
}
inline void AddDanmuSourceEvent::set_allocated_header(::kservice::EventHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.header_;
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(header);
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:kservice.AddDanmuSourceEvent.header)
}

// repeated .kservice.AddDanmuSourceEvent.DanmuPoolSource danmuPoolSources = 2;
inline int AddDanmuSourceEvent::_internal_danmupoolsources_size() const {
  return _impl_.danmupoolsources_.size();
}
inline int AddDanmuSourceEvent::danmupoolsources_size() const {
  return _internal_danmupoolsources_size();
}
inline void AddDanmuSourceEvent::clear_danmupoolsources() {
  _impl_.danmupoolsources_.Clear();
}
inline ::kservice::AddDanmuSourceEvent_DanmuPoolSource* AddDanmuSourceEvent::mutable_danmupoolsources(int index) {
  // @@protoc_insertion_point(field_mutable:kservice.AddDanmuSourceEvent.danmuPoolSources)
  return _impl_.danmupoolsources_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::kservice::AddDanmuSourceEvent_DanmuPoolSource >*
AddDanmuSourceEvent::mutable_danmupoolsources() {
  // @@protoc_insertion_point(field_mutable_list:kservice.AddDanmuSourceEvent.danmuPoolSources)
  return &_impl_.danmupoolsources_;
}
inline const ::kservice::AddDanmuSourceEvent_DanmuPoolSource& AddDanmuSourceEvent::_internal_danmupoolsources(int index) const {
  return _impl_.danmupoolsources_.Get(index);
}
inline const ::kservice::AddDanmuSourceEvent_DanmuPoolSource& AddDanmuSourceEvent::danmupoolsources(int index) const {
  // @@protoc_insertion_point(field_get:kservice.AddDanmuSourceEvent.danmuPoolSources)
  return _internal_danmupoolsources(index);
}
inline ::kservice::AddDanmuSourceEvent_DanmuPoolSource* AddDanmuSourceEvent::_internal_add_danmupoolsources() {
  return _impl_.danmupoolsources_.Add();
}
inline ::kservice::AddDanmuSourceEvent_DanmuPoolSource* AddDanmuSourceEvent::add_danmupoolsources() {
  ::kservice::AddDanmuSourceEvent_DanmuPoolSource* _add = _internal_add_danmupoolsources();
  // @@protoc_insertion_point(field_add:kservice.AddDanmuSourceEvent.danmuPoolSources)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::kservice::AddDanmuSourceEvent_DanmuPoolSource >&
AddDanmuSourceEvent::danmupoolsources() const {
  // @@protoc_insertion_point(field_list:kservice.AddDanmuSourceEvent.danmuPoolSources)
  return _impl_.danmupoolsources_;
}

// -------------------------------------------------------------------

// DanmuComment

// string senderId = 1;
inline void DanmuComment::clear_senderid() {
  _impl_.senderid_.ClearToEmpty();
}
inline const std::string& DanmuComment::senderid() const {
  // @@protoc_insertion_point(field_get:kservice.DanmuComment.senderId)
  return _internal_senderid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DanmuComment::set_senderid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.senderid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:kservice.DanmuComment.senderId)
}
inline std::string* DanmuComment::mutable_senderid() {
  std::string* _s = _internal_mutable_senderid();
  // @@protoc_insertion_point(field_mutable:kservice.DanmuComment.senderId)
  return _s;
}
inline const std::string& DanmuComment::_internal_senderid() const {
  return _impl_.senderid_.Get();
}
inline void DanmuComment::_internal_set_senderid(const std::string& value) {
  
  _impl_.senderid_.Set(value, GetArenaForAllocation());
}
inline std::string* DanmuComment::_internal_mutable_senderid() {
  
  return _impl_.senderid_.Mutable(GetArenaForAllocation());
}
inline std::string* DanmuComment::release_senderid() {
  // @@protoc_insertion_point(field_release:kservice.DanmuComment.senderId)
  return _impl_.senderid_.Release();
}
inline void DanmuComment::set_allocated_senderid(std::string* senderid) {
  if (senderid != nullptr) {
    
  } else {
    
  }
  _impl_.senderid_.SetAllocated(senderid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.senderid_.IsDefault()) {
    _impl_.senderid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:kservice.DanmuComment.senderId)
}

// string text = 2;
inline void DanmuComment::clear_text() {
  _impl_.text_.ClearToEmpty();
}
inline const std::string& DanmuComment::text() const {
  // @@protoc_insertion_point(field_get:kservice.DanmuComment.text)
  return _internal_text();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DanmuComment::set_text(ArgT0&& arg0, ArgT... args) {
 
 _impl_.text_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:kservice.DanmuComment.text)
}
inline std::string* DanmuComment::mutable_text() {
  std::string* _s = _internal_mutable_text();
  // @@protoc_insertion_point(field_mutable:kservice.DanmuComment.text)
  return _s;
}
inline const std::string& DanmuComment::_internal_text() const {
  return _impl_.text_.Get();
}
inline void DanmuComment::_internal_set_text(const std::string& value) {
  
  _impl_.text_.Set(value, GetArenaForAllocation());
}
inline std::string* DanmuComment::_internal_mutable_text() {
  
  return _impl_.text_.Mutable(GetArenaForAllocation());
}
inline std::string* DanmuComment::release_text() {
  // @@protoc_insertion_point(field_release:kservice.DanmuComment.text)
  return _impl_.text_.Release();
}
inline void DanmuComment::set_allocated_text(std::string* text) {
  if (text != nullptr) {
    
  } else {
    
  }
  _impl_.text_.SetAllocated(text, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.text_.IsDefault()) {
    _impl_.text_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:kservice.DanmuComment.text)
}

// int32 color = 3;
inline void DanmuComment::clear_color() {
  _impl_.color_ = 0;
}
inline int32_t DanmuComment::_internal_color() const {
  return _impl_.color_;
}
inline int32_t DanmuComment::color() const {
  // @@protoc_insertion_point(field_get:kservice.DanmuComment.color)
  return _internal_color();
}
inline void DanmuComment::_internal_set_color(int32_t value) {
  
  _impl_.color_ = value;
}
inline void DanmuComment::set_color(int32_t value) {
  _internal_set_color(value);
  // @@protoc_insertion_point(field_set:kservice.DanmuComment.color)
}

// int32 time = 4;
inline void DanmuComment::clear_time() {
  _impl_.time_ = 0;
}
inline int32_t DanmuComment::_internal_time() const {
  return _impl_.time_;
}
inline int32_t DanmuComment::time() const {
  // @@protoc_insertion_point(field_get:kservice.DanmuComment.time)
  return _internal_time();
}
inline void DanmuComment::_internal_set_time(int32_t value) {
  
  _impl_.time_ = value;
}
inline void DanmuComment::set_time(int32_t value) {
  _internal_set_time(value);
  // @@protoc_insertion_point(field_set:kservice.DanmuComment.time)
}

// int32 mode = 5;
inline void DanmuComment::clear_mode() {
  _impl_.mode_ = 0;
}
inline int32_t DanmuComment::_internal_mode() const {
  return _impl_.mode_;
}
inline int32_t DanmuComment::mode() const {
  // @@protoc_insertion_point(field_get:kservice.DanmuComment.mode)
  return _internal_mode();
}
inline void DanmuComment::_internal_set_mode(int32_t value) {
  
  _impl_.mode_ = value;
}
inline void DanmuComment::set_mode(int32_t value) {
  _internal_set_mode(value);
  // @@protoc_insertion_point(field_set:kservice.DanmuComment.mode)
}

// int32 size = 6;
inline void DanmuComment::clear_size() {
  _impl_.size_ = 0;
}
inline int32_t DanmuComment::_internal_size() const {
  return _impl_.size_;
}
inline int32_t DanmuComment::size() const {
  // @@protoc_insertion_point(field_get:kservice.DanmuComment.size)
  return _internal_size();
}
inline void DanmuComment::_internal_set_size(int32_t value) {
  
  _impl_.size_ = value;
}
inline void DanmuComment::set_size(int32_t value) {
  _internal_set_size(value);
  // @@protoc_insertion_point(field_set:kservice.DanmuComment.size)
}

// int64 timestamp = 7;
inline void DanmuComment::clear_timestamp() {
  _impl_.timestamp_ = int64_t{0};
}
inline int64_t DanmuComment::_internal_timestamp() const {
  return _impl_.timestamp_;
}
inline int64_t DanmuComment::timestamp() const {
  // @@protoc_insertion_point(field_get:kservice.DanmuComment.timestamp)
  return _internal_timestamp();
}
inline void DanmuComment::_internal_set_timestamp(int64_t value) {
  
  _impl_.timestamp_ = value;
}
inline void DanmuComment::set_timestamp(int64_t value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:kservice.DanmuComment.timestamp)
}

// -------------------------------------------------------------------

// LaunchRequest

// .kservice.EventHeader header = 1;
inline bool LaunchRequest::_internal_has_header() const {
  return this != internal_default_instance() && _impl_.header_ != nullptr;
}
inline bool LaunchRequest::has_header() const {
  return _internal_has_header();
}
inline void LaunchRequest::clear_header() {
  if (GetArenaForAllocation() == nullptr && _impl_.header_ != nullptr) {
    delete _impl_.header_;
  }
  _impl_.header_ = nullptr;
}
inline const ::kservice::EventHeader& LaunchRequest::_internal_header() const {
  const ::kservice::EventHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::kservice::EventHeader&>(
      ::kservice::_EventHeader_default_instance_);
}
inline const ::kservice::EventHeader& LaunchRequest::header() const {
  // @@protoc_insertion_point(field_get:kservice.LaunchRequest.header)
  return _internal_header();
}
inline void LaunchRequest::unsafe_arena_set_allocated_header(
    ::kservice::EventHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kservice.LaunchRequest.header)
}
inline ::kservice::EventHeader* LaunchRequest::release_header() {
  
  ::kservice::EventHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::kservice::EventHeader* LaunchRequest::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:kservice.LaunchRequest.header)
  
  ::kservice::EventHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::kservice::EventHeader* LaunchRequest::_internal_mutable_header() {
  
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::kservice::EventHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::kservice::EventHeader* LaunchRequest::mutable_header() {
  ::kservice::EventHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:kservice.LaunchRequest.header)
  return _msg;
}
inline void LaunchRequest::set_allocated_header(::kservice::EventHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.header_;
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(header);
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:kservice.LaunchRequest.header)
}

// .kservice.Pool poolInfo = 2;
inline bool LaunchRequest::_internal_has_poolinfo() const {
  return this != internal_default_instance() && _impl_.poolinfo_ != nullptr;
}
inline bool LaunchRequest::has_poolinfo() const {
  return _internal_has_poolinfo();
}
inline void LaunchRequest::clear_poolinfo() {
  if (GetArenaForAllocation() == nullptr && _impl_.poolinfo_ != nullptr) {
    delete _impl_.poolinfo_;
  }
  _impl_.poolinfo_ = nullptr;
}
inline const ::kservice::Pool& LaunchRequest::_internal_poolinfo() const {
  const ::kservice::Pool* p = _impl_.poolinfo_;
  return p != nullptr ? *p : reinterpret_cast<const ::kservice::Pool&>(
      ::kservice::_Pool_default_instance_);
}
inline const ::kservice::Pool& LaunchRequest::poolinfo() const {
  // @@protoc_insertion_point(field_get:kservice.LaunchRequest.poolInfo)
  return _internal_poolinfo();
}
inline void LaunchRequest::unsafe_arena_set_allocated_poolinfo(
    ::kservice::Pool* poolinfo) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.poolinfo_);
  }
  _impl_.poolinfo_ = poolinfo;
  if (poolinfo) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kservice.LaunchRequest.poolInfo)
}
inline ::kservice::Pool* LaunchRequest::release_poolinfo() {
  
  ::kservice::Pool* temp = _impl_.poolinfo_;
  _impl_.poolinfo_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::kservice::Pool* LaunchRequest::unsafe_arena_release_poolinfo() {
  // @@protoc_insertion_point(field_release:kservice.LaunchRequest.poolInfo)
  
  ::kservice::Pool* temp = _impl_.poolinfo_;
  _impl_.poolinfo_ = nullptr;
  return temp;
}
inline ::kservice::Pool* LaunchRequest::_internal_mutable_poolinfo() {
  
  if (_impl_.poolinfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::kservice::Pool>(GetArenaForAllocation());
    _impl_.poolinfo_ = p;
  }
  return _impl_.poolinfo_;
}
inline ::kservice::Pool* LaunchRequest::mutable_poolinfo() {
  ::kservice::Pool* _msg = _internal_mutable_poolinfo();
  // @@protoc_insertion_point(field_mutable:kservice.LaunchRequest.poolInfo)
  return _msg;
}
inline void LaunchRequest::set_allocated_poolinfo(::kservice::Pool* poolinfo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.poolinfo_;
  }
  if (poolinfo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(poolinfo);
    if (message_arena != submessage_arena) {
      poolinfo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, poolinfo, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.poolinfo_ = poolinfo;
  // @@protoc_insertion_point(field_set_allocated:kservice.LaunchRequest.poolInfo)
}

// .kservice.KFileInfo fileInfo = 3;
inline bool LaunchRequest::_internal_has_fileinfo() const {
  return this != internal_default_instance() && _impl_.fileinfo_ != nullptr;
}
inline bool LaunchRequest::has_fileinfo() const {
  return _internal_has_fileinfo();
}
inline void LaunchRequest::clear_fileinfo() {
  if (GetArenaForAllocation() == nullptr && _impl_.fileinfo_ != nullptr) {
    delete _impl_.fileinfo_;
  }
  _impl_.fileinfo_ = nullptr;
}
inline const ::kservice::KFileInfo& LaunchRequest::_internal_fileinfo() const {
  const ::kservice::KFileInfo* p = _impl_.fileinfo_;
  return p != nullptr ? *p : reinterpret_cast<const ::kservice::KFileInfo&>(
      ::kservice::_KFileInfo_default_instance_);
}
inline const ::kservice::KFileInfo& LaunchRequest::fileinfo() const {
  // @@protoc_insertion_point(field_get:kservice.LaunchRequest.fileInfo)
  return _internal_fileinfo();
}
inline void LaunchRequest::unsafe_arena_set_allocated_fileinfo(
    ::kservice::KFileInfo* fileinfo) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.fileinfo_);
  }
  _impl_.fileinfo_ = fileinfo;
  if (fileinfo) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kservice.LaunchRequest.fileInfo)
}
inline ::kservice::KFileInfo* LaunchRequest::release_fileinfo() {
  
  ::kservice::KFileInfo* temp = _impl_.fileinfo_;
  _impl_.fileinfo_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::kservice::KFileInfo* LaunchRequest::unsafe_arena_release_fileinfo() {
  // @@protoc_insertion_point(field_release:kservice.LaunchRequest.fileInfo)
  
  ::kservice::KFileInfo* temp = _impl_.fileinfo_;
  _impl_.fileinfo_ = nullptr;
  return temp;
}
inline ::kservice::KFileInfo* LaunchRequest::_internal_mutable_fileinfo() {
  
  if (_impl_.fileinfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::kservice::KFileInfo>(GetArenaForAllocation());
    _impl_.fileinfo_ = p;
  }
  return _impl_.fileinfo_;
}
inline ::kservice::KFileInfo* LaunchRequest::mutable_fileinfo() {
  ::kservice::KFileInfo* _msg = _internal_mutable_fileinfo();
  // @@protoc_insertion_point(field_mutable:kservice.LaunchRequest.fileInfo)
  return _msg;
}
inline void LaunchRequest::set_allocated_fileinfo(::kservice::KFileInfo* fileinfo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.fileinfo_;
  }
  if (fileinfo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(fileinfo);
    if (message_arena != submessage_arena) {
      fileinfo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, fileinfo, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.fileinfo_ = fileinfo;
  // @@protoc_insertion_point(field_set_allocated:kservice.LaunchRequest.fileInfo)
}

// .kservice.DanmuComment comment = 4;
inline bool LaunchRequest::_internal_has_comment() const {
  return this != internal_default_instance() && _impl_.comment_ != nullptr;
}
inline bool LaunchRequest::has_comment() const {
  return _internal_has_comment();
}
inline void LaunchRequest::clear_comment() {
  if (GetArenaForAllocation() == nullptr && _impl_.comment_ != nullptr) {
    delete _impl_.comment_;
  }
  _impl_.comment_ = nullptr;
}
inline const ::kservice::DanmuComment& LaunchRequest::_internal_comment() const {
  const ::kservice::DanmuComment* p = _impl_.comment_;
  return p != nullptr ? *p : reinterpret_cast<const ::kservice::DanmuComment&>(
      ::kservice::_DanmuComment_default_instance_);
}
inline const ::kservice::DanmuComment& LaunchRequest::comment() const {
  // @@protoc_insertion_point(field_get:kservice.LaunchRequest.comment)
  return _internal_comment();
}
inline void LaunchRequest::unsafe_arena_set_allocated_comment(
    ::kservice::DanmuComment* comment) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.comment_);
  }
  _impl_.comment_ = comment;
  if (comment) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kservice.LaunchRequest.comment)
}
inline ::kservice::DanmuComment* LaunchRequest::release_comment() {
  
  ::kservice::DanmuComment* temp = _impl_.comment_;
  _impl_.comment_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::kservice::DanmuComment* LaunchRequest::unsafe_arena_release_comment() {
  // @@protoc_insertion_point(field_release:kservice.LaunchRequest.comment)
  
  ::kservice::DanmuComment* temp = _impl_.comment_;
  _impl_.comment_ = nullptr;
  return temp;
}
inline ::kservice::DanmuComment* LaunchRequest::_internal_mutable_comment() {
  
  if (_impl_.comment_ == nullptr) {
    auto* p = CreateMaybeMessage<::kservice::DanmuComment>(GetArenaForAllocation());
    _impl_.comment_ = p;
  }
  return _impl_.comment_;
}
inline ::kservice::DanmuComment* LaunchRequest::mutable_comment() {
  ::kservice::DanmuComment* _msg = _internal_mutable_comment();
  // @@protoc_insertion_point(field_mutable:kservice.LaunchRequest.comment)
  return _msg;
}
inline void LaunchRequest::set_allocated_comment(::kservice::DanmuComment* comment) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.comment_;
  }
  if (comment) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(comment);
    if (message_arena != submessage_arena) {
      comment = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, comment, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.comment_ = comment;
  // @@protoc_insertion_point(field_set_allocated:kservice.LaunchRequest.comment)
}

// -------------------------------------------------------------------

// LaunchResponse

// .kservice.ResponseHeader header = 1;
inline bool LaunchResponse::_internal_has_header() const {
  return this != internal_default_instance() && _impl_.header_ != nullptr;
}
inline bool LaunchResponse::has_header() const {
  return _internal_has_header();
}
inline void LaunchResponse::clear_header() {
  if (GetArenaForAllocation() == nullptr && _impl_.header_ != nullptr) {
    delete _impl_.header_;
  }
  _impl_.header_ = nullptr;
}
inline const ::kservice::ResponseHeader& LaunchResponse::_internal_header() const {
  const ::kservice::ResponseHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::kservice::ResponseHeader&>(
      ::kservice::_ResponseHeader_default_instance_);
}
inline const ::kservice::ResponseHeader& LaunchResponse::header() const {
  // @@protoc_insertion_point(field_get:kservice.LaunchResponse.header)
  return _internal_header();
}
inline void LaunchResponse::unsafe_arena_set_allocated_header(
    ::kservice::ResponseHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kservice.LaunchResponse.header)
}
inline ::kservice::ResponseHeader* LaunchResponse::release_header() {
  
  ::kservice::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::kservice::ResponseHeader* LaunchResponse::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:kservice.LaunchResponse.header)
  
  ::kservice::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::kservice::ResponseHeader* LaunchResponse::_internal_mutable_header() {
  
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::kservice::ResponseHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::kservice::ResponseHeader* LaunchResponse::mutable_header() {
  ::kservice::ResponseHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:kservice.LaunchResponse.header)
  return _msg;
}
inline void LaunchResponse::set_allocated_header(::kservice::ResponseHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.header_;
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(header);
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:kservice.LaunchResponse.header)
}

// string poolId = 2;
inline void LaunchResponse::clear_poolid() {
  _impl_.poolid_.ClearToEmpty();
}
inline const std::string& LaunchResponse::poolid() const {
  // @@protoc_insertion_point(field_get:kservice.LaunchResponse.poolId)
  return _internal_poolid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LaunchResponse::set_poolid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.poolid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:kservice.LaunchResponse.poolId)
}
inline std::string* LaunchResponse::mutable_poolid() {
  std::string* _s = _internal_mutable_poolid();
  // @@protoc_insertion_point(field_mutable:kservice.LaunchResponse.poolId)
  return _s;
}
inline const std::string& LaunchResponse::_internal_poolid() const {
  return _impl_.poolid_.Get();
}
inline void LaunchResponse::_internal_set_poolid(const std::string& value) {
  
  _impl_.poolid_.Set(value, GetArenaForAllocation());
}
inline std::string* LaunchResponse::_internal_mutable_poolid() {
  
  return _impl_.poolid_.Mutable(GetArenaForAllocation());
}
inline std::string* LaunchResponse::release_poolid() {
  // @@protoc_insertion_point(field_release:kservice.LaunchResponse.poolId)
  return _impl_.poolid_.Release();
}
inline void LaunchResponse::set_allocated_poolid(std::string* poolid) {
  if (poolid != nullptr) {
    
  } else {
    
  }
  _impl_.poolid_.SetAllocated(poolid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.poolid_.IsDefault()) {
    _impl_.poolid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:kservice.LaunchResponse.poolId)
}

// .kservice.DanmuSource danmuSource = 3;
inline bool LaunchResponse::_internal_has_danmusource() const {
  return this != internal_default_instance() && _impl_.danmusource_ != nullptr;
}
inline bool LaunchResponse::has_danmusource() const {
  return _internal_has_danmusource();
}
inline void LaunchResponse::clear_danmusource() {
  if (GetArenaForAllocation() == nullptr && _impl_.danmusource_ != nullptr) {
    delete _impl_.danmusource_;
  }
  _impl_.danmusource_ = nullptr;
}
inline const ::kservice::DanmuSource& LaunchResponse::_internal_danmusource() const {
  const ::kservice::DanmuSource* p = _impl_.danmusource_;
  return p != nullptr ? *p : reinterpret_cast<const ::kservice::DanmuSource&>(
      ::kservice::_DanmuSource_default_instance_);
}
inline const ::kservice::DanmuSource& LaunchResponse::danmusource() const {
  // @@protoc_insertion_point(field_get:kservice.LaunchResponse.danmuSource)
  return _internal_danmusource();
}
inline void LaunchResponse::unsafe_arena_set_allocated_danmusource(
    ::kservice::DanmuSource* danmusource) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.danmusource_);
  }
  _impl_.danmusource_ = danmusource;
  if (danmusource) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kservice.LaunchResponse.danmuSource)
}
inline ::kservice::DanmuSource* LaunchResponse::release_danmusource() {
  
  ::kservice::DanmuSource* temp = _impl_.danmusource_;
  _impl_.danmusource_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::kservice::DanmuSource* LaunchResponse::unsafe_arena_release_danmusource() {
  // @@protoc_insertion_point(field_release:kservice.LaunchResponse.danmuSource)
  
  ::kservice::DanmuSource* temp = _impl_.danmusource_;
  _impl_.danmusource_ = nullptr;
  return temp;
}
inline ::kservice::DanmuSource* LaunchResponse::_internal_mutable_danmusource() {
  
  if (_impl_.danmusource_ == nullptr) {
    auto* p = CreateMaybeMessage<::kservice::DanmuSource>(GetArenaForAllocation());
    _impl_.danmusource_ = p;
  }
  return _impl_.danmusource_;
}
inline ::kservice::DanmuSource* LaunchResponse::mutable_danmusource() {
  ::kservice::DanmuSource* _msg = _internal_mutable_danmusource();
  // @@protoc_insertion_point(field_mutable:kservice.LaunchResponse.danmuSource)
  return _msg;
}
inline void LaunchResponse::set_allocated_danmusource(::kservice::DanmuSource* danmusource) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.danmusource_;
  }
  if (danmusource) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(danmusource);
    if (message_arena != submessage_arena) {
      danmusource = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, danmusource, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.danmusource_ = danmusource;
  // @@protoc_insertion_point(field_set_allocated:kservice.LaunchResponse.danmuSource)
}

// .kservice.DanmuComment comment = 4;
inline bool LaunchResponse::_internal_has_comment() const {
  return this != internal_default_instance() && _impl_.comment_ != nullptr;
}
inline bool LaunchResponse::has_comment() const {
  return _internal_has_comment();
}
inline void LaunchResponse::clear_comment() {
  if (GetArenaForAllocation() == nullptr && _impl_.comment_ != nullptr) {
    delete _impl_.comment_;
  }
  _impl_.comment_ = nullptr;
}
inline const ::kservice::DanmuComment& LaunchResponse::_internal_comment() const {
  const ::kservice::DanmuComment* p = _impl_.comment_;
  return p != nullptr ? *p : reinterpret_cast<const ::kservice::DanmuComment&>(
      ::kservice::_DanmuComment_default_instance_);
}
inline const ::kservice::DanmuComment& LaunchResponse::comment() const {
  // @@protoc_insertion_point(field_get:kservice.LaunchResponse.comment)
  return _internal_comment();
}
inline void LaunchResponse::unsafe_arena_set_allocated_comment(
    ::kservice::DanmuComment* comment) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.comment_);
  }
  _impl_.comment_ = comment;
  if (comment) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kservice.LaunchResponse.comment)
}
inline ::kservice::DanmuComment* LaunchResponse::release_comment() {
  
  ::kservice::DanmuComment* temp = _impl_.comment_;
  _impl_.comment_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::kservice::DanmuComment* LaunchResponse::unsafe_arena_release_comment() {
  // @@protoc_insertion_point(field_release:kservice.LaunchResponse.comment)
  
  ::kservice::DanmuComment* temp = _impl_.comment_;
  _impl_.comment_ = nullptr;
  return temp;
}
inline ::kservice::DanmuComment* LaunchResponse::_internal_mutable_comment() {
  
  if (_impl_.comment_ == nullptr) {
    auto* p = CreateMaybeMessage<::kservice::DanmuComment>(GetArenaForAllocation());
    _impl_.comment_ = p;
  }
  return _impl_.comment_;
}
inline ::kservice::DanmuComment* LaunchResponse::mutable_comment() {
  ::kservice::DanmuComment* _msg = _internal_mutable_comment();
  // @@protoc_insertion_point(field_mutable:kservice.LaunchResponse.comment)
  return _msg;
}
inline void LaunchResponse::set_allocated_comment(::kservice::DanmuComment* comment) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.comment_;
  }
  if (comment) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(comment);
    if (message_arena != submessage_arena) {
      comment = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, comment, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.comment_ = comment;
  // @@protoc_insertion_point(field_set_allocated:kservice.LaunchResponse.comment)
}

// -------------------------------------------------------------------

// KikoDanmuRequest

// .kservice.EventHeader header = 1;
inline bool KikoDanmuRequest::_internal_has_header() const {
  return this != internal_default_instance() && _impl_.header_ != nullptr;
}
inline bool KikoDanmuRequest::has_header() const {
  return _internal_has_header();
}
inline void KikoDanmuRequest::clear_header() {
  if (GetArenaForAllocation() == nullptr && _impl_.header_ != nullptr) {
    delete _impl_.header_;
  }
  _impl_.header_ = nullptr;
}
inline const ::kservice::EventHeader& KikoDanmuRequest::_internal_header() const {
  const ::kservice::EventHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::kservice::EventHeader&>(
      ::kservice::_EventHeader_default_instance_);
}
inline const ::kservice::EventHeader& KikoDanmuRequest::header() const {
  // @@protoc_insertion_point(field_get:kservice.KikoDanmuRequest.header)
  return _internal_header();
}
inline void KikoDanmuRequest::unsafe_arena_set_allocated_header(
    ::kservice::EventHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kservice.KikoDanmuRequest.header)
}
inline ::kservice::EventHeader* KikoDanmuRequest::release_header() {
  
  ::kservice::EventHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::kservice::EventHeader* KikoDanmuRequest::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:kservice.KikoDanmuRequest.header)
  
  ::kservice::EventHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::kservice::EventHeader* KikoDanmuRequest::_internal_mutable_header() {
  
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::kservice::EventHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::kservice::EventHeader* KikoDanmuRequest::mutable_header() {
  ::kservice::EventHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:kservice.KikoDanmuRequest.header)
  return _msg;
}
inline void KikoDanmuRequest::set_allocated_header(::kservice::EventHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.header_;
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(header);
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:kservice.KikoDanmuRequest.header)
}

// .kservice.Pool poolInfo = 2;
inline bool KikoDanmuRequest::_internal_has_poolinfo() const {
  return this != internal_default_instance() && _impl_.poolinfo_ != nullptr;
}
inline bool KikoDanmuRequest::has_poolinfo() const {
  return _internal_has_poolinfo();
}
inline void KikoDanmuRequest::clear_poolinfo() {
  if (GetArenaForAllocation() == nullptr && _impl_.poolinfo_ != nullptr) {
    delete _impl_.poolinfo_;
  }
  _impl_.poolinfo_ = nullptr;
}
inline const ::kservice::Pool& KikoDanmuRequest::_internal_poolinfo() const {
  const ::kservice::Pool* p = _impl_.poolinfo_;
  return p != nullptr ? *p : reinterpret_cast<const ::kservice::Pool&>(
      ::kservice::_Pool_default_instance_);
}
inline const ::kservice::Pool& KikoDanmuRequest::poolinfo() const {
  // @@protoc_insertion_point(field_get:kservice.KikoDanmuRequest.poolInfo)
  return _internal_poolinfo();
}
inline void KikoDanmuRequest::unsafe_arena_set_allocated_poolinfo(
    ::kservice::Pool* poolinfo) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.poolinfo_);
  }
  _impl_.poolinfo_ = poolinfo;
  if (poolinfo) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kservice.KikoDanmuRequest.poolInfo)
}
inline ::kservice::Pool* KikoDanmuRequest::release_poolinfo() {
  
  ::kservice::Pool* temp = _impl_.poolinfo_;
  _impl_.poolinfo_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::kservice::Pool* KikoDanmuRequest::unsafe_arena_release_poolinfo() {
  // @@protoc_insertion_point(field_release:kservice.KikoDanmuRequest.poolInfo)
  
  ::kservice::Pool* temp = _impl_.poolinfo_;
  _impl_.poolinfo_ = nullptr;
  return temp;
}
inline ::kservice::Pool* KikoDanmuRequest::_internal_mutable_poolinfo() {
  
  if (_impl_.poolinfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::kservice::Pool>(GetArenaForAllocation());
    _impl_.poolinfo_ = p;
  }
  return _impl_.poolinfo_;
}
inline ::kservice::Pool* KikoDanmuRequest::mutable_poolinfo() {
  ::kservice::Pool* _msg = _internal_mutable_poolinfo();
  // @@protoc_insertion_point(field_mutable:kservice.KikoDanmuRequest.poolInfo)
  return _msg;
}
inline void KikoDanmuRequest::set_allocated_poolinfo(::kservice::Pool* poolinfo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.poolinfo_;
  }
  if (poolinfo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(poolinfo);
    if (message_arena != submessage_arena) {
      poolinfo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, poolinfo, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.poolinfo_ = poolinfo;
  // @@protoc_insertion_point(field_set_allocated:kservice.KikoDanmuRequest.poolInfo)
}

// int32 duration = 3;
inline void KikoDanmuRequest::clear_duration() {
  _impl_.duration_ = 0;
}
inline int32_t KikoDanmuRequest::_internal_duration() const {
  return _impl_.duration_;
}
inline int32_t KikoDanmuRequest::duration() const {
  // @@protoc_insertion_point(field_get:kservice.KikoDanmuRequest.duration)
  return _internal_duration();
}
inline void KikoDanmuRequest::_internal_set_duration(int32_t value) {
  
  _impl_.duration_ = value;
}
inline void KikoDanmuRequest::set_duration(int32_t value) {
  _internal_set_duration(value);
  // @@protoc_insertion_point(field_set:kservice.KikoDanmuRequest.duration)
}

// -------------------------------------------------------------------

// KikoDanmuResponse_DanmuSourceComments

// .kservice.DanmuSource source = 1;
inline bool KikoDanmuResponse_DanmuSourceComments::_internal_has_source() const {
  return this != internal_default_instance() && _impl_.source_ != nullptr;
}
inline bool KikoDanmuResponse_DanmuSourceComments::has_source() const {
  return _internal_has_source();
}
inline void KikoDanmuResponse_DanmuSourceComments::clear_source() {
  if (GetArenaForAllocation() == nullptr && _impl_.source_ != nullptr) {
    delete _impl_.source_;
  }
  _impl_.source_ = nullptr;
}
inline const ::kservice::DanmuSource& KikoDanmuResponse_DanmuSourceComments::_internal_source() const {
  const ::kservice::DanmuSource* p = _impl_.source_;
  return p != nullptr ? *p : reinterpret_cast<const ::kservice::DanmuSource&>(
      ::kservice::_DanmuSource_default_instance_);
}
inline const ::kservice::DanmuSource& KikoDanmuResponse_DanmuSourceComments::source() const {
  // @@protoc_insertion_point(field_get:kservice.KikoDanmuResponse.DanmuSourceComments.source)
  return _internal_source();
}
inline void KikoDanmuResponse_DanmuSourceComments::unsafe_arena_set_allocated_source(
    ::kservice::DanmuSource* source) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.source_);
  }
  _impl_.source_ = source;
  if (source) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kservice.KikoDanmuResponse.DanmuSourceComments.source)
}
inline ::kservice::DanmuSource* KikoDanmuResponse_DanmuSourceComments::release_source() {
  
  ::kservice::DanmuSource* temp = _impl_.source_;
  _impl_.source_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::kservice::DanmuSource* KikoDanmuResponse_DanmuSourceComments::unsafe_arena_release_source() {
  // @@protoc_insertion_point(field_release:kservice.KikoDanmuResponse.DanmuSourceComments.source)
  
  ::kservice::DanmuSource* temp = _impl_.source_;
  _impl_.source_ = nullptr;
  return temp;
}
inline ::kservice::DanmuSource* KikoDanmuResponse_DanmuSourceComments::_internal_mutable_source() {
  
  if (_impl_.source_ == nullptr) {
    auto* p = CreateMaybeMessage<::kservice::DanmuSource>(GetArenaForAllocation());
    _impl_.source_ = p;
  }
  return _impl_.source_;
}
inline ::kservice::DanmuSource* KikoDanmuResponse_DanmuSourceComments::mutable_source() {
  ::kservice::DanmuSource* _msg = _internal_mutable_source();
  // @@protoc_insertion_point(field_mutable:kservice.KikoDanmuResponse.DanmuSourceComments.source)
  return _msg;
}
inline void KikoDanmuResponse_DanmuSourceComments::set_allocated_source(::kservice::DanmuSource* source) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.source_;
  }
  if (source) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(source);
    if (message_arena != submessage_arena) {
      source = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, source, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.source_ = source;
  // @@protoc_insertion_point(field_set_allocated:kservice.KikoDanmuResponse.DanmuSourceComments.source)
}

// repeated .kservice.DanmuComment danmuComments = 2;
inline int KikoDanmuResponse_DanmuSourceComments::_internal_danmucomments_size() const {
  return _impl_.danmucomments_.size();
}
inline int KikoDanmuResponse_DanmuSourceComments::danmucomments_size() const {
  return _internal_danmucomments_size();
}
inline void KikoDanmuResponse_DanmuSourceComments::clear_danmucomments() {
  _impl_.danmucomments_.Clear();
}
inline ::kservice::DanmuComment* KikoDanmuResponse_DanmuSourceComments::mutable_danmucomments(int index) {
  // @@protoc_insertion_point(field_mutable:kservice.KikoDanmuResponse.DanmuSourceComments.danmuComments)
  return _impl_.danmucomments_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::kservice::DanmuComment >*
KikoDanmuResponse_DanmuSourceComments::mutable_danmucomments() {
  // @@protoc_insertion_point(field_mutable_list:kservice.KikoDanmuResponse.DanmuSourceComments.danmuComments)
  return &_impl_.danmucomments_;
}
inline const ::kservice::DanmuComment& KikoDanmuResponse_DanmuSourceComments::_internal_danmucomments(int index) const {
  return _impl_.danmucomments_.Get(index);
}
inline const ::kservice::DanmuComment& KikoDanmuResponse_DanmuSourceComments::danmucomments(int index) const {
  // @@protoc_insertion_point(field_get:kservice.KikoDanmuResponse.DanmuSourceComments.danmuComments)
  return _internal_danmucomments(index);
}
inline ::kservice::DanmuComment* KikoDanmuResponse_DanmuSourceComments::_internal_add_danmucomments() {
  return _impl_.danmucomments_.Add();
}
inline ::kservice::DanmuComment* KikoDanmuResponse_DanmuSourceComments::add_danmucomments() {
  ::kservice::DanmuComment* _add = _internal_add_danmucomments();
  // @@protoc_insertion_point(field_add:kservice.KikoDanmuResponse.DanmuSourceComments.danmuComments)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::kservice::DanmuComment >&
KikoDanmuResponse_DanmuSourceComments::danmucomments() const {
  // @@protoc_insertion_point(field_list:kservice.KikoDanmuResponse.DanmuSourceComments.danmuComments)
  return _impl_.danmucomments_;
}

// -------------------------------------------------------------------

// KikoDanmuResponse

// .kservice.ResponseHeader header = 1;
inline bool KikoDanmuResponse::_internal_has_header() const {
  return this != internal_default_instance() && _impl_.header_ != nullptr;
}
inline bool KikoDanmuResponse::has_header() const {
  return _internal_has_header();
}
inline void KikoDanmuResponse::clear_header() {
  if (GetArenaForAllocation() == nullptr && _impl_.header_ != nullptr) {
    delete _impl_.header_;
  }
  _impl_.header_ = nullptr;
}
inline const ::kservice::ResponseHeader& KikoDanmuResponse::_internal_header() const {
  const ::kservice::ResponseHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::kservice::ResponseHeader&>(
      ::kservice::_ResponseHeader_default_instance_);
}
inline const ::kservice::ResponseHeader& KikoDanmuResponse::header() const {
  // @@protoc_insertion_point(field_get:kservice.KikoDanmuResponse.header)
  return _internal_header();
}
inline void KikoDanmuResponse::unsafe_arena_set_allocated_header(
    ::kservice::ResponseHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kservice.KikoDanmuResponse.header)
}
inline ::kservice::ResponseHeader* KikoDanmuResponse::release_header() {
  
  ::kservice::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::kservice::ResponseHeader* KikoDanmuResponse::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:kservice.KikoDanmuResponse.header)
  
  ::kservice::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::kservice::ResponseHeader* KikoDanmuResponse::_internal_mutable_header() {
  
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::kservice::ResponseHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::kservice::ResponseHeader* KikoDanmuResponse::mutable_header() {
  ::kservice::ResponseHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:kservice.KikoDanmuResponse.header)
  return _msg;
}
inline void KikoDanmuResponse::set_allocated_header(::kservice::ResponseHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.header_;
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(header);
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:kservice.KikoDanmuResponse.header)
}

// .kservice.Pool poolInfo = 2;
inline bool KikoDanmuResponse::_internal_has_poolinfo() const {
  return this != internal_default_instance() && _impl_.poolinfo_ != nullptr;
}
inline bool KikoDanmuResponse::has_poolinfo() const {
  return _internal_has_poolinfo();
}
inline void KikoDanmuResponse::clear_poolinfo() {
  if (GetArenaForAllocation() == nullptr && _impl_.poolinfo_ != nullptr) {
    delete _impl_.poolinfo_;
  }
  _impl_.poolinfo_ = nullptr;
}
inline const ::kservice::Pool& KikoDanmuResponse::_internal_poolinfo() const {
  const ::kservice::Pool* p = _impl_.poolinfo_;
  return p != nullptr ? *p : reinterpret_cast<const ::kservice::Pool&>(
      ::kservice::_Pool_default_instance_);
}
inline const ::kservice::Pool& KikoDanmuResponse::poolinfo() const {
  // @@protoc_insertion_point(field_get:kservice.KikoDanmuResponse.poolInfo)
  return _internal_poolinfo();
}
inline void KikoDanmuResponse::unsafe_arena_set_allocated_poolinfo(
    ::kservice::Pool* poolinfo) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.poolinfo_);
  }
  _impl_.poolinfo_ = poolinfo;
  if (poolinfo) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kservice.KikoDanmuResponse.poolInfo)
}
inline ::kservice::Pool* KikoDanmuResponse::release_poolinfo() {
  
  ::kservice::Pool* temp = _impl_.poolinfo_;
  _impl_.poolinfo_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::kservice::Pool* KikoDanmuResponse::unsafe_arena_release_poolinfo() {
  // @@protoc_insertion_point(field_release:kservice.KikoDanmuResponse.poolInfo)
  
  ::kservice::Pool* temp = _impl_.poolinfo_;
  _impl_.poolinfo_ = nullptr;
  return temp;
}
inline ::kservice::Pool* KikoDanmuResponse::_internal_mutable_poolinfo() {
  
  if (_impl_.poolinfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::kservice::Pool>(GetArenaForAllocation());
    _impl_.poolinfo_ = p;
  }
  return _impl_.poolinfo_;
}
inline ::kservice::Pool* KikoDanmuResponse::mutable_poolinfo() {
  ::kservice::Pool* _msg = _internal_mutable_poolinfo();
  // @@protoc_insertion_point(field_mutable:kservice.KikoDanmuResponse.poolInfo)
  return _msg;
}
inline void KikoDanmuResponse::set_allocated_poolinfo(::kservice::Pool* poolinfo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.poolinfo_;
  }
  if (poolinfo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(poolinfo);
    if (message_arena != submessage_arena) {
      poolinfo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, poolinfo, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.poolinfo_ = poolinfo;
  // @@protoc_insertion_point(field_set_allocated:kservice.KikoDanmuResponse.poolInfo)
}

// repeated .kservice.KikoDanmuResponse.DanmuSourceComments danmuSources = 3;
inline int KikoDanmuResponse::_internal_danmusources_size() const {
  return _impl_.danmusources_.size();
}
inline int KikoDanmuResponse::danmusources_size() const {
  return _internal_danmusources_size();
}
inline void KikoDanmuResponse::clear_danmusources() {
  _impl_.danmusources_.Clear();
}
inline ::kservice::KikoDanmuResponse_DanmuSourceComments* KikoDanmuResponse::mutable_danmusources(int index) {
  // @@protoc_insertion_point(field_mutable:kservice.KikoDanmuResponse.danmuSources)
  return _impl_.danmusources_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::kservice::KikoDanmuResponse_DanmuSourceComments >*
KikoDanmuResponse::mutable_danmusources() {
  // @@protoc_insertion_point(field_mutable_list:kservice.KikoDanmuResponse.danmuSources)
  return &_impl_.danmusources_;
}
inline const ::kservice::KikoDanmuResponse_DanmuSourceComments& KikoDanmuResponse::_internal_danmusources(int index) const {
  return _impl_.danmusources_.Get(index);
}
inline const ::kservice::KikoDanmuResponse_DanmuSourceComments& KikoDanmuResponse::danmusources(int index) const {
  // @@protoc_insertion_point(field_get:kservice.KikoDanmuResponse.danmuSources)
  return _internal_danmusources(index);
}
inline ::kservice::KikoDanmuResponse_DanmuSourceComments* KikoDanmuResponse::_internal_add_danmusources() {
  return _impl_.danmusources_.Add();
}
inline ::kservice::KikoDanmuResponse_DanmuSourceComments* KikoDanmuResponse::add_danmusources() {
  ::kservice::KikoDanmuResponse_DanmuSourceComments* _add = _internal_add_danmusources();
  // @@protoc_insertion_point(field_add:kservice.KikoDanmuResponse.danmuSources)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::kservice::KikoDanmuResponse_DanmuSourceComments >&
KikoDanmuResponse::danmusources() const {
  // @@protoc_insertion_point(field_list:kservice.KikoDanmuResponse.danmuSources)
  return _impl_.danmusources_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace kservice

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::kservice::EpType> : ::std::true_type {};
template <> struct is_proto_enum< ::kservice::DanmuSourceType> : ::std::true_type {};
template <> struct is_proto_enum< ::kservice::InfoSourceType> : ::std::true_type {};

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_Service_2fpb_2fservice_2eproto
