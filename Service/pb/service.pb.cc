// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Service/pb/service.proto

#include "Service/pb/service.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/io/zero_copy_stream_impl_lite.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

namespace kservice {
PROTOBUF_CONSTEXPR EventHeader::EventHeader(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.event_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.os_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.did_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.uid_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.timestamp_)*/int64_t{0}
  , /*decltype(_impl_.version_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct EventHeaderDefaultTypeInternal {
  PROTOBUF_CONSTEXPR EventHeaderDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~EventHeaderDefaultTypeInternal() {}
  union {
    EventHeader _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 EventHeaderDefaultTypeInternal _EventHeader_default_instance_;
PROTOBUF_CONSTEXPR CommonEvent::CommonEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.extra_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.header_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct CommonEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CommonEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CommonEventDefaultTypeInternal() {}
  union {
    CommonEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CommonEventDefaultTypeInternal _CommonEvent_default_instance_;
PROTOBUF_CONSTEXPR ResponseHeader::ResponseHeader(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.err_msg_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.status_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ResponseHeaderDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ResponseHeaderDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ResponseHeaderDefaultTypeInternal() {}
  union {
    ResponseHeader _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ResponseHeaderDefaultTypeInternal _ResponseHeader_default_instance_;
PROTOBUF_CONSTEXPR RegisterRequest::RegisterRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.username_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.password_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.email_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.verification_code_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.header_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct RegisterRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR RegisterRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~RegisterRequestDefaultTypeInternal() {}
  union {
    RegisterRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 RegisterRequestDefaultTypeInternal _RegisterRequest_default_instance_;
PROTOBUF_CONSTEXPR RegisterResponse::RegisterResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.uid_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.username_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.email_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.header_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct RegisterResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR RegisterResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~RegisterResponseDefaultTypeInternal() {}
  union {
    RegisterResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 RegisterResponseDefaultTypeInternal _RegisterResponse_default_instance_;
PROTOBUF_CONSTEXPR LoginRequest::LoginRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.email_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.password_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.header_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct LoginRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR LoginRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~LoginRequestDefaultTypeInternal() {}
  union {
    LoginRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LoginRequestDefaultTypeInternal _LoginRequest_default_instance_;
PROTOBUF_CONSTEXPR LoginResponse::LoginResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.uid_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.username_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.email_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.access_token_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.refresh_token_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.header_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct LoginResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR LoginResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~LoginResponseDefaultTypeInternal() {}
  union {
    LoginResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LoginResponseDefaultTypeInternal _LoginResponse_default_instance_;
PROTOBUF_CONSTEXPR RefreshRequest::RefreshRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.header_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct RefreshRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR RefreshRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~RefreshRequestDefaultTypeInternal() {}
  union {
    RefreshRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 RefreshRequestDefaultTypeInternal _RefreshRequest_default_instance_;
PROTOBUF_CONSTEXPR RefreshResponse::RefreshResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.uid_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.access_token_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.header_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct RefreshResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR RefreshResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~RefreshResponseDefaultTypeInternal() {}
  union {
    RefreshResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 RefreshResponseDefaultTypeInternal _RefreshResponse_default_instance_;
PROTOBUF_CONSTEXPR SendVerificationRequest::SendVerificationRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.email_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.header_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct SendVerificationRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SendVerificationRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SendVerificationRequestDefaultTypeInternal() {}
  union {
    SendVerificationRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SendVerificationRequestDefaultTypeInternal _SendVerificationRequest_default_instance_;
PROTOBUF_CONSTEXPR SendVerificationResponse::SendVerificationResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.header_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct SendVerificationResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SendVerificationResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SendVerificationResponseDefaultTypeInternal() {}
  union {
    SendVerificationResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SendVerificationResponseDefaultTypeInternal _SendVerificationResponse_default_instance_;
PROTOBUF_CONSTEXPR UVEvent_StepTime::UVEvent_StepTime(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.step_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.time_)*/int64_t{0}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct UVEvent_StepTimeDefaultTypeInternal {
  PROTOBUF_CONSTEXPR UVEvent_StepTimeDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~UVEvent_StepTimeDefaultTypeInternal() {}
  union {
    UVEvent_StepTime _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 UVEvent_StepTimeDefaultTypeInternal _UVEvent_StepTime_default_instance_;
PROTOBUF_CONSTEXPR UVEvent::UVEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.steptimes_)*/{}
  , /*decltype(_impl_.header_)*/nullptr
  , /*decltype(_impl_.startupts_)*/int64_t{0}
  , /*decltype(_impl_.isstartup_)*/false
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct UVEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR UVEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~UVEventDefaultTypeInternal() {}
  union {
    UVEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 UVEventDefaultTypeInternal _UVEvent_default_instance_;
PROTOBUF_CONSTEXPR UVEventResponse_LatestVersion::UVEventResponse_LatestVersion(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.url_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.info_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.version_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct UVEventResponse_LatestVersionDefaultTypeInternal {
  PROTOBUF_CONSTEXPR UVEventResponse_LatestVersionDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~UVEventResponse_LatestVersionDefaultTypeInternal() {}
  union {
    UVEventResponse_LatestVersion _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 UVEventResponse_LatestVersionDefaultTypeInternal _UVEventResponse_LatestVersion_default_instance_;
PROTOBUF_CONSTEXPR UVEventResponse::UVEventResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.header_)*/nullptr
  , /*decltype(_impl_.latestversioninfo_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct UVEventResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR UVEventResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~UVEventResponseDefaultTypeInternal() {}
  union {
    UVEventResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 UVEventResponseDefaultTypeInternal _UVEventResponse_default_instance_;
PROTOBUF_CONSTEXPR KFileInfo::KFileInfo(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.filename_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.fullpath_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.hash32_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.torrenthash_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.url_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.durationms_)*/int64_t{0}
  , /*decltype(_impl_.filesize_)*/int64_t{0}
  , /*decltype(_impl_.islocal_)*/false
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct KFileInfoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR KFileInfoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~KFileInfoDefaultTypeInternal() {}
  union {
    KFileInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 KFileInfoDefaultTypeInternal _KFileInfo_default_instance_;
PROTOBUF_CONSTEXPR RecoRequest::RecoRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.header_)*/nullptr
  , /*decltype(_impl_.fileinfo_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct RecoRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR RecoRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~RecoRequestDefaultTypeInternal() {}
  union {
    RecoRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 RecoRequestDefaultTypeInternal _RecoRequest_default_instance_;
PROTOBUF_CONSTEXPR DanmuSource::DanmuSource(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.title_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.scriptid_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.scriptdata_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.type_)*/0
  , /*decltype(_impl_.durationseconds_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct DanmuSourceDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DanmuSourceDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DanmuSourceDefaultTypeInternal() {}
  union {
    DanmuSource _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DanmuSourceDefaultTypeInternal _DanmuSource_default_instance_;
PROTOBUF_CONSTEXPR InfoSource::InfoSource(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.scriptid_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.scriptdata_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.type_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct InfoSourceDefaultTypeInternal {
  PROTOBUF_CONSTEXPR InfoSourceDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~InfoSourceDefaultTypeInternal() {}
  union {
    InfoSource _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 InfoSourceDefaultTypeInternal _InfoSource_default_instance_;
PROTOBUF_CONSTEXPR Pool::Pool(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.epname_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.poolid_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.epindex_)*/0
  , /*decltype(_impl_.eptype_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct PoolDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PoolDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~PoolDefaultTypeInternal() {}
  union {
    Pool _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PoolDefaultTypeInternal _Pool_default_instance_;
PROTOBUF_CONSTEXPR RecoResponse::RecoResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.infosources_)*/{}
  , /*decltype(_impl_.danmusources_)*/{}
  , /*decltype(_impl_.header_)*/nullptr
  , /*decltype(_impl_.matchresult_)*/nullptr
  , /*decltype(_impl_.recoby_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct RecoResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR RecoResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~RecoResponseDefaultTypeInternal() {}
  union {
    RecoResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 RecoResponseDefaultTypeInternal _RecoResponse_default_instance_;
PROTOBUF_CONSTEXPR MatchEvent_Match::MatchEvent_Match(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.infosources_)*/{}
  , /*decltype(_impl_.fileinfo_)*/nullptr
  , /*decltype(_impl_.poolinfo_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct MatchEvent_MatchDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MatchEvent_MatchDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~MatchEvent_MatchDefaultTypeInternal() {}
  union {
    MatchEvent_Match _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MatchEvent_MatchDefaultTypeInternal _MatchEvent_Match_default_instance_;
PROTOBUF_CONSTEXPR MatchEvent::MatchEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.matches_)*/{}
  , /*decltype(_impl_.header_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct MatchEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MatchEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~MatchEventDefaultTypeInternal() {}
  union {
    MatchEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MatchEventDefaultTypeInternal _MatchEvent_default_instance_;
PROTOBUF_CONSTEXPR AddDanmuSourceEvent_DanmuPoolSource::AddDanmuSourceEvent_DanmuPoolSource(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.danmusources_)*/{}
  , /*decltype(_impl_.infosources_)*/{}
  , /*decltype(_impl_.poolinfo_)*/nullptr
  , /*decltype(_impl_.fileinfo_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct AddDanmuSourceEvent_DanmuPoolSourceDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AddDanmuSourceEvent_DanmuPoolSourceDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~AddDanmuSourceEvent_DanmuPoolSourceDefaultTypeInternal() {}
  union {
    AddDanmuSourceEvent_DanmuPoolSource _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AddDanmuSourceEvent_DanmuPoolSourceDefaultTypeInternal _AddDanmuSourceEvent_DanmuPoolSource_default_instance_;
PROTOBUF_CONSTEXPR AddDanmuSourceEvent::AddDanmuSourceEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.danmupoolsources_)*/{}
  , /*decltype(_impl_.header_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct AddDanmuSourceEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AddDanmuSourceEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~AddDanmuSourceEventDefaultTypeInternal() {}
  union {
    AddDanmuSourceEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AddDanmuSourceEventDefaultTypeInternal _AddDanmuSourceEvent_default_instance_;
PROTOBUF_CONSTEXPR DanmuComment::DanmuComment(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.senderid_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.text_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.color_)*/0
  , /*decltype(_impl_.time_)*/0
  , /*decltype(_impl_.mode_)*/0
  , /*decltype(_impl_.size_)*/0
  , /*decltype(_impl_.timestamp_)*/int64_t{0}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct DanmuCommentDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DanmuCommentDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DanmuCommentDefaultTypeInternal() {}
  union {
    DanmuComment _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DanmuCommentDefaultTypeInternal _DanmuComment_default_instance_;
PROTOBUF_CONSTEXPR LaunchRequest::LaunchRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.header_)*/nullptr
  , /*decltype(_impl_.poolinfo_)*/nullptr
  , /*decltype(_impl_.fileinfo_)*/nullptr
  , /*decltype(_impl_.comment_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct LaunchRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR LaunchRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~LaunchRequestDefaultTypeInternal() {}
  union {
    LaunchRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LaunchRequestDefaultTypeInternal _LaunchRequest_default_instance_;
PROTOBUF_CONSTEXPR LaunchResponse::LaunchResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.poolid_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.header_)*/nullptr
  , /*decltype(_impl_.danmusource_)*/nullptr
  , /*decltype(_impl_.comment_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct LaunchResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR LaunchResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~LaunchResponseDefaultTypeInternal() {}
  union {
    LaunchResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LaunchResponseDefaultTypeInternal _LaunchResponse_default_instance_;
PROTOBUF_CONSTEXPR KikoDanmuRequest::KikoDanmuRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.header_)*/nullptr
  , /*decltype(_impl_.poolinfo_)*/nullptr
  , /*decltype(_impl_.duration_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct KikoDanmuRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR KikoDanmuRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~KikoDanmuRequestDefaultTypeInternal() {}
  union {
    KikoDanmuRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 KikoDanmuRequestDefaultTypeInternal _KikoDanmuRequest_default_instance_;
PROTOBUF_CONSTEXPR KikoDanmuResponse_DanmuSourceComments::KikoDanmuResponse_DanmuSourceComments(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.danmucomments_)*/{}
  , /*decltype(_impl_.source_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct KikoDanmuResponse_DanmuSourceCommentsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR KikoDanmuResponse_DanmuSourceCommentsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~KikoDanmuResponse_DanmuSourceCommentsDefaultTypeInternal() {}
  union {
    KikoDanmuResponse_DanmuSourceComments _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 KikoDanmuResponse_DanmuSourceCommentsDefaultTypeInternal _KikoDanmuResponse_DanmuSourceComments_default_instance_;
PROTOBUF_CONSTEXPR KikoDanmuResponse::KikoDanmuResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.danmusources_)*/{}
  , /*decltype(_impl_.header_)*/nullptr
  , /*decltype(_impl_.poolinfo_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct KikoDanmuResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR KikoDanmuResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~KikoDanmuResponseDefaultTypeInternal() {}
  union {
    KikoDanmuResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 KikoDanmuResponseDefaultTypeInternal _KikoDanmuResponse_default_instance_;
}  // namespace kservice
namespace kservice {
bool EpType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> EpType_strings[8] = {};

static const char EpType_names[] =
  "ED"
  "EP"
  "MAD"
  "OP"
  "Other"
  "SP"
  "Trailer"
  "UNKNOWN_EP";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry EpType_entries[] = {
  { {EpType_names + 0, 2}, 4 },
  { {EpType_names + 2, 2}, 1 },
  { {EpType_names + 4, 3}, 6 },
  { {EpType_names + 7, 2}, 3 },
  { {EpType_names + 9, 5}, 7 },
  { {EpType_names + 14, 2}, 2 },
  { {EpType_names + 16, 7}, 5 },
  { {EpType_names + 23, 10}, 0 },
};

static const int EpType_entries_by_number[] = {
  7, // 0 -> UNKNOWN_EP
  1, // 1 -> EP
  5, // 2 -> SP
  3, // 3 -> OP
  0, // 4 -> ED
  6, // 5 -> Trailer
  2, // 6 -> MAD
  4, // 7 -> Other
};

const std::string& EpType_Name(
    EpType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          EpType_entries,
          EpType_entries_by_number,
          8, EpType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      EpType_entries,
      EpType_entries_by_number,
      8, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     EpType_strings[idx].get();
}
bool EpType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, EpType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      EpType_entries, 8, name, &int_value);
  if (success) {
    *value = static_cast<EpType>(int_value);
  }
  return success;
}
bool DanmuSourceType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> DanmuSourceType_strings[11] = {};

static const char DanmuSourceType_names[] =
  "ACFUN"
  "BILIBILI"
  "GAMER"
  "IQIYI"
  "KIKO"
  "MGTV"
  "TENCENT"
  "TUCAO"
  "UNKNOWN_DM_SRC"
  "YOUKU"
  "YSJ";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry DanmuSourceType_entries[] = {
  { {DanmuSourceType_names + 0, 5}, 9 },
  { {DanmuSourceType_names + 5, 8}, 2 },
  { {DanmuSourceType_names + 13, 5}, 3 },
  { {DanmuSourceType_names + 18, 5}, 4 },
  { {DanmuSourceType_names + 23, 4}, 1 },
  { {DanmuSourceType_names + 27, 4}, 7 },
  { {DanmuSourceType_names + 31, 7}, 5 },
  { {DanmuSourceType_names + 38, 5}, 8 },
  { {DanmuSourceType_names + 43, 14}, 0 },
  { {DanmuSourceType_names + 57, 5}, 6 },
  { {DanmuSourceType_names + 62, 3}, 10 },
};

static const int DanmuSourceType_entries_by_number[] = {
  8, // 0 -> UNKNOWN_DM_SRC
  4, // 1 -> KIKO
  1, // 2 -> BILIBILI
  2, // 3 -> GAMER
  3, // 4 -> IQIYI
  6, // 5 -> TENCENT
  9, // 6 -> YOUKU
  5, // 7 -> MGTV
  7, // 8 -> TUCAO
  0, // 9 -> ACFUN
  10, // 10 -> YSJ
};

const std::string& DanmuSourceType_Name(
    DanmuSourceType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          DanmuSourceType_entries,
          DanmuSourceType_entries_by_number,
          11, DanmuSourceType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      DanmuSourceType_entries,
      DanmuSourceType_entries_by_number,
      11, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     DanmuSourceType_strings[idx].get();
}
bool DanmuSourceType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, DanmuSourceType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      DanmuSourceType_entries, 11, name, &int_value);
  if (success) {
    *value = static_cast<DanmuSourceType>(int_value);
  }
  return success;
}
bool InfoSourceType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> InfoSourceType_strings[3] = {};

static const char InfoSourceType_names[] =
  "BGM"
  "DOUBAN"
  "UNKNOWN_INFO_SRC";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry InfoSourceType_entries[] = {
  { {InfoSourceType_names + 0, 3}, 1 },
  { {InfoSourceType_names + 3, 6}, 2 },
  { {InfoSourceType_names + 9, 16}, 0 },
};

static const int InfoSourceType_entries_by_number[] = {
  2, // 0 -> UNKNOWN_INFO_SRC
  0, // 1 -> BGM
  1, // 2 -> DOUBAN
};

const std::string& InfoSourceType_Name(
    InfoSourceType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          InfoSourceType_entries,
          InfoSourceType_entries_by_number,
          3, InfoSourceType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      InfoSourceType_entries,
      InfoSourceType_entries_by_number,
      3, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     InfoSourceType_strings[idx].get();
}
bool InfoSourceType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, InfoSourceType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      InfoSourceType_entries, 3, name, &int_value);
  if (success) {
    *value = static_cast<InfoSourceType>(int_value);
  }
  return success;
}
bool RecoBy_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> RecoBy_strings[4] = {};

static const char RecoBy_names[] =
  "R_FILENAME"
  "R_HASH32"
  "R_INFOHASH"
  "R_NONE";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry RecoBy_entries[] = {
  { {RecoBy_names + 0, 10}, 3 },
  { {RecoBy_names + 10, 8}, 1 },
  { {RecoBy_names + 18, 10}, 2 },
  { {RecoBy_names + 28, 6}, 0 },
};

static const int RecoBy_entries_by_number[] = {
  3, // 0 -> R_NONE
  1, // 1 -> R_HASH32
  2, // 2 -> R_INFOHASH
  0, // 3 -> R_FILENAME
};

const std::string& RecoBy_Name(
    RecoBy value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          RecoBy_entries,
          RecoBy_entries_by_number,
          4, RecoBy_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      RecoBy_entries,
      RecoBy_entries_by_number,
      4, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     RecoBy_strings[idx].get();
}
bool RecoBy_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, RecoBy* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      RecoBy_entries, 4, name, &int_value);
  if (success) {
    *value = static_cast<RecoBy>(int_value);
  }
  return success;
}

// ===================================================================

class EventHeader::_Internal {
 public:
};

EventHeader::EventHeader(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:kservice.EventHeader)
}
EventHeader::EventHeader(const EventHeader& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  EventHeader* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.event_){}
    , decltype(_impl_.os_){}
    , decltype(_impl_.did_){}
    , decltype(_impl_.uid_){}
    , decltype(_impl_.timestamp_){}
    , decltype(_impl_.version_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.event_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.event_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_event().empty()) {
    _this->_impl_.event_.Set(from._internal_event(), 
      _this->GetArenaForAllocation());
  }
  _impl_.os_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.os_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_os().empty()) {
    _this->_impl_.os_.Set(from._internal_os(), 
      _this->GetArenaForAllocation());
  }
  _impl_.did_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.did_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_did().empty()) {
    _this->_impl_.did_.Set(from._internal_did(), 
      _this->GetArenaForAllocation());
  }
  _impl_.uid_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.uid_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_uid().empty()) {
    _this->_impl_.uid_.Set(from._internal_uid(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.timestamp_, &from._impl_.timestamp_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.version_) -
    reinterpret_cast<char*>(&_impl_.timestamp_)) + sizeof(_impl_.version_));
  // @@protoc_insertion_point(copy_constructor:kservice.EventHeader)
}

inline void EventHeader::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.event_){}
    , decltype(_impl_.os_){}
    , decltype(_impl_.did_){}
    , decltype(_impl_.uid_){}
    , decltype(_impl_.timestamp_){int64_t{0}}
    , decltype(_impl_.version_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.event_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.event_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.os_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.os_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.did_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.did_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.uid_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.uid_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

EventHeader::~EventHeader() {
  // @@protoc_insertion_point(destructor:kservice.EventHeader)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void EventHeader::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.event_.Destroy();
  _impl_.os_.Destroy();
  _impl_.did_.Destroy();
  _impl_.uid_.Destroy();
}

void EventHeader::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void EventHeader::Clear() {
// @@protoc_insertion_point(message_clear_start:kservice.EventHeader)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.event_.ClearToEmpty();
  _impl_.os_.ClearToEmpty();
  _impl_.did_.ClearToEmpty();
  _impl_.uid_.ClearToEmpty();
  ::memset(&_impl_.timestamp_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.version_) -
      reinterpret_cast<char*>(&_impl_.timestamp_)) + sizeof(_impl_.version_));
  _internal_metadata_.Clear<std::string>();
}

const char* EventHeader::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int64 timestamp = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.timestamp_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string event = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_event();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else
          goto handle_unusual;
        continue;
      // string os = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_os();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else
          goto handle_unusual;
        continue;
      // int32 version = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _impl_.version_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string did = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_did();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else
          goto handle_unusual;
        continue;
      // string uid = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          auto str = _internal_mutable_uid();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* EventHeader::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:kservice.EventHeader)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // int64 timestamp = 1;
  if (this->_internal_timestamp() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(1, this->_internal_timestamp(), target);
  }

  // string event = 2;
  if (!this->_internal_event().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_event().data(), static_cast<int>(this->_internal_event().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "kservice.EventHeader.event");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_event(), target);
  }

  // string os = 3;
  if (!this->_internal_os().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_os().data(), static_cast<int>(this->_internal_os().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "kservice.EventHeader.os");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_os(), target);
  }

  // int32 version = 4;
  if (this->_internal_version() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(4, this->_internal_version(), target);
  }

  // string did = 5;
  if (!this->_internal_did().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_did().data(), static_cast<int>(this->_internal_did().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "kservice.EventHeader.did");
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_did(), target);
  }

  // string uid = 6;
  if (!this->_internal_uid().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_uid().data(), static_cast<int>(this->_internal_uid().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "kservice.EventHeader.uid");
    target = stream->WriteStringMaybeAliased(
        6, this->_internal_uid(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:kservice.EventHeader)
  return target;
}

size_t EventHeader::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:kservice.EventHeader)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string event = 2;
  if (!this->_internal_event().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_event());
  }

  // string os = 3;
  if (!this->_internal_os().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_os());
  }

  // string did = 5;
  if (!this->_internal_did().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_did());
  }

  // string uid = 6;
  if (!this->_internal_uid().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_uid());
  }

  // int64 timestamp = 1;
  if (this->_internal_timestamp() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_timestamp());
  }

  // int32 version = 4;
  if (this->_internal_version() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_version());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void EventHeader::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const EventHeader*>(
      &from));
}

void EventHeader::MergeFrom(const EventHeader& from) {
  EventHeader* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:kservice.EventHeader)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_event().empty()) {
    _this->_internal_set_event(from._internal_event());
  }
  if (!from._internal_os().empty()) {
    _this->_internal_set_os(from._internal_os());
  }
  if (!from._internal_did().empty()) {
    _this->_internal_set_did(from._internal_did());
  }
  if (!from._internal_uid().empty()) {
    _this->_internal_set_uid(from._internal_uid());
  }
  if (from._internal_timestamp() != 0) {
    _this->_internal_set_timestamp(from._internal_timestamp());
  }
  if (from._internal_version() != 0) {
    _this->_internal_set_version(from._internal_version());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void EventHeader::CopyFrom(const EventHeader& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:kservice.EventHeader)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EventHeader::IsInitialized() const {
  return true;
}

void EventHeader::InternalSwap(EventHeader* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.event_, lhs_arena,
      &other->_impl_.event_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.os_, lhs_arena,
      &other->_impl_.os_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.did_, lhs_arena,
      &other->_impl_.did_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.uid_, lhs_arena,
      &other->_impl_.uid_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(EventHeader, _impl_.version_)
      + sizeof(EventHeader::_impl_.version_)
      - PROTOBUF_FIELD_OFFSET(EventHeader, _impl_.timestamp_)>(
          reinterpret_cast<char*>(&_impl_.timestamp_),
          reinterpret_cast<char*>(&other->_impl_.timestamp_));
}

std::string EventHeader::GetTypeName() const {
  return "kservice.EventHeader";
}


// ===================================================================

class CommonEvent::_Internal {
 public:
  static const ::kservice::EventHeader& header(const CommonEvent* msg);
};

const ::kservice::EventHeader&
CommonEvent::_Internal::header(const CommonEvent* msg) {
  return *msg->_impl_.header_;
}
CommonEvent::CommonEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:kservice.CommonEvent)
}
CommonEvent::CommonEvent(const CommonEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  CommonEvent* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.extra_){}
    , decltype(_impl_.header_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.extra_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.extra_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_extra().empty()) {
    _this->_impl_.extra_.Set(from._internal_extra(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_header()) {
    _this->_impl_.header_ = new ::kservice::EventHeader(*from._impl_.header_);
  }
  // @@protoc_insertion_point(copy_constructor:kservice.CommonEvent)
}

inline void CommonEvent::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.extra_){}
    , decltype(_impl_.header_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.extra_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.extra_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CommonEvent::~CommonEvent() {
  // @@protoc_insertion_point(destructor:kservice.CommonEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CommonEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.extra_.Destroy();
  if (this != internal_default_instance()) delete _impl_.header_;
}

void CommonEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CommonEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:kservice.CommonEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.extra_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && _impl_.header_ != nullptr) {
    delete _impl_.header_;
  }
  _impl_.header_ = nullptr;
  _internal_metadata_.Clear<std::string>();
}

const char* CommonEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .kservice.EventHeader header = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_header(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string extra = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_extra();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CommonEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:kservice.CommonEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .kservice.EventHeader header = 1;
  if (this->_internal_has_header()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::header(this),
        _Internal::header(this).GetCachedSize(), target, stream);
  }

  // string extra = 2;
  if (!this->_internal_extra().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_extra().data(), static_cast<int>(this->_internal_extra().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "kservice.CommonEvent.extra");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_extra(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:kservice.CommonEvent)
  return target;
}

size_t CommonEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:kservice.CommonEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string extra = 2;
  if (!this->_internal_extra().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_extra());
  }

  // .kservice.EventHeader header = 1;
  if (this->_internal_has_header()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.header_);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CommonEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const CommonEvent*>(
      &from));
}

void CommonEvent::MergeFrom(const CommonEvent& from) {
  CommonEvent* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:kservice.CommonEvent)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_extra().empty()) {
    _this->_internal_set_extra(from._internal_extra());
  }
  if (from._internal_has_header()) {
    _this->_internal_mutable_header()->::kservice::EventHeader::MergeFrom(
        from._internal_header());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CommonEvent::CopyFrom(const CommonEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:kservice.CommonEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CommonEvent::IsInitialized() const {
  return true;
}

void CommonEvent::InternalSwap(CommonEvent* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.extra_, lhs_arena,
      &other->_impl_.extra_, rhs_arena
  );
  swap(_impl_.header_, other->_impl_.header_);
}

std::string CommonEvent::GetTypeName() const {
  return "kservice.CommonEvent";
}


// ===================================================================

class ResponseHeader::_Internal {
 public:
};

ResponseHeader::ResponseHeader(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:kservice.ResponseHeader)
}
ResponseHeader::ResponseHeader(const ResponseHeader& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  ResponseHeader* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.err_msg_){}
    , decltype(_impl_.status_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.err_msg_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.err_msg_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_err_msg().empty()) {
    _this->_impl_.err_msg_.Set(from._internal_err_msg(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.status_ = from._impl_.status_;
  // @@protoc_insertion_point(copy_constructor:kservice.ResponseHeader)
}

inline void ResponseHeader::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.err_msg_){}
    , decltype(_impl_.status_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.err_msg_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.err_msg_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ResponseHeader::~ResponseHeader() {
  // @@protoc_insertion_point(destructor:kservice.ResponseHeader)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ResponseHeader::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.err_msg_.Destroy();
}

void ResponseHeader::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ResponseHeader::Clear() {
// @@protoc_insertion_point(message_clear_start:kservice.ResponseHeader)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.err_msg_.ClearToEmpty();
  _impl_.status_ = 0;
  _internal_metadata_.Clear<std::string>();
}

const char* ResponseHeader::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int32 status = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.status_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string err_msg = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_err_msg();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ResponseHeader::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:kservice.ResponseHeader)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // int32 status = 1;
  if (this->_internal_status() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_status(), target);
  }

  // string err_msg = 2;
  if (!this->_internal_err_msg().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_err_msg().data(), static_cast<int>(this->_internal_err_msg().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "kservice.ResponseHeader.err_msg");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_err_msg(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:kservice.ResponseHeader)
  return target;
}

size_t ResponseHeader::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:kservice.ResponseHeader)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string err_msg = 2;
  if (!this->_internal_err_msg().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_err_msg());
  }

  // int32 status = 1;
  if (this->_internal_status() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_status());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ResponseHeader::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const ResponseHeader*>(
      &from));
}

void ResponseHeader::MergeFrom(const ResponseHeader& from) {
  ResponseHeader* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:kservice.ResponseHeader)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_err_msg().empty()) {
    _this->_internal_set_err_msg(from._internal_err_msg());
  }
  if (from._internal_status() != 0) {
    _this->_internal_set_status(from._internal_status());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ResponseHeader::CopyFrom(const ResponseHeader& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:kservice.ResponseHeader)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ResponseHeader::IsInitialized() const {
  return true;
}

void ResponseHeader::InternalSwap(ResponseHeader* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.err_msg_, lhs_arena,
      &other->_impl_.err_msg_, rhs_arena
  );
  swap(_impl_.status_, other->_impl_.status_);
}

std::string ResponseHeader::GetTypeName() const {
  return "kservice.ResponseHeader";
}


// ===================================================================

class RegisterRequest::_Internal {
 public:
  static const ::kservice::EventHeader& header(const RegisterRequest* msg);
};

const ::kservice::EventHeader&
RegisterRequest::_Internal::header(const RegisterRequest* msg) {
  return *msg->_impl_.header_;
}
RegisterRequest::RegisterRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:kservice.RegisterRequest)
}
RegisterRequest::RegisterRequest(const RegisterRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  RegisterRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.username_){}
    , decltype(_impl_.password_){}
    , decltype(_impl_.email_){}
    , decltype(_impl_.verification_code_){}
    , decltype(_impl_.header_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.username_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.username_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_username().empty()) {
    _this->_impl_.username_.Set(from._internal_username(), 
      _this->GetArenaForAllocation());
  }
  _impl_.password_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.password_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_password().empty()) {
    _this->_impl_.password_.Set(from._internal_password(), 
      _this->GetArenaForAllocation());
  }
  _impl_.email_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.email_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_email().empty()) {
    _this->_impl_.email_.Set(from._internal_email(), 
      _this->GetArenaForAllocation());
  }
  _impl_.verification_code_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.verification_code_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_verification_code().empty()) {
    _this->_impl_.verification_code_.Set(from._internal_verification_code(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_header()) {
    _this->_impl_.header_ = new ::kservice::EventHeader(*from._impl_.header_);
  }
  // @@protoc_insertion_point(copy_constructor:kservice.RegisterRequest)
}

inline void RegisterRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.username_){}
    , decltype(_impl_.password_){}
    , decltype(_impl_.email_){}
    , decltype(_impl_.verification_code_){}
    , decltype(_impl_.header_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.username_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.username_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.password_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.password_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.email_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.email_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.verification_code_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.verification_code_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

RegisterRequest::~RegisterRequest() {
  // @@protoc_insertion_point(destructor:kservice.RegisterRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void RegisterRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.username_.Destroy();
  _impl_.password_.Destroy();
  _impl_.email_.Destroy();
  _impl_.verification_code_.Destroy();
  if (this != internal_default_instance()) delete _impl_.header_;
}

void RegisterRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void RegisterRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:kservice.RegisterRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.username_.ClearToEmpty();
  _impl_.password_.ClearToEmpty();
  _impl_.email_.ClearToEmpty();
  _impl_.verification_code_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && _impl_.header_ != nullptr) {
    delete _impl_.header_;
  }
  _impl_.header_ = nullptr;
  _internal_metadata_.Clear<std::string>();
}

const char* RegisterRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .kservice.EventHeader header = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_header(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string username = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_username();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else
          goto handle_unusual;
        continue;
      // string password = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_password();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else
          goto handle_unusual;
        continue;
      // string email = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_email();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else
          goto handle_unusual;
        continue;
      // string verification_code = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_verification_code();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* RegisterRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:kservice.RegisterRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .kservice.EventHeader header = 1;
  if (this->_internal_has_header()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::header(this),
        _Internal::header(this).GetCachedSize(), target, stream);
  }

  // string username = 2;
  if (!this->_internal_username().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_username().data(), static_cast<int>(this->_internal_username().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "kservice.RegisterRequest.username");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_username(), target);
  }

  // string password = 3;
  if (!this->_internal_password().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_password().data(), static_cast<int>(this->_internal_password().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "kservice.RegisterRequest.password");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_password(), target);
  }

  // string email = 4;
  if (!this->_internal_email().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_email().data(), static_cast<int>(this->_internal_email().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "kservice.RegisterRequest.email");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_email(), target);
  }

  // string verification_code = 5;
  if (!this->_internal_verification_code().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_verification_code().data(), static_cast<int>(this->_internal_verification_code().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "kservice.RegisterRequest.verification_code");
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_verification_code(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:kservice.RegisterRequest)
  return target;
}

size_t RegisterRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:kservice.RegisterRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string username = 2;
  if (!this->_internal_username().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_username());
  }

  // string password = 3;
  if (!this->_internal_password().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_password());
  }

  // string email = 4;
  if (!this->_internal_email().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_email());
  }

  // string verification_code = 5;
  if (!this->_internal_verification_code().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_verification_code());
  }

  // .kservice.EventHeader header = 1;
  if (this->_internal_has_header()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.header_);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void RegisterRequest::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const RegisterRequest*>(
      &from));
}

void RegisterRequest::MergeFrom(const RegisterRequest& from) {
  RegisterRequest* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:kservice.RegisterRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_username().empty()) {
    _this->_internal_set_username(from._internal_username());
  }
  if (!from._internal_password().empty()) {
    _this->_internal_set_password(from._internal_password());
  }
  if (!from._internal_email().empty()) {
    _this->_internal_set_email(from._internal_email());
  }
  if (!from._internal_verification_code().empty()) {
    _this->_internal_set_verification_code(from._internal_verification_code());
  }
  if (from._internal_has_header()) {
    _this->_internal_mutable_header()->::kservice::EventHeader::MergeFrom(
        from._internal_header());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void RegisterRequest::CopyFrom(const RegisterRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:kservice.RegisterRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RegisterRequest::IsInitialized() const {
  return true;
}

void RegisterRequest::InternalSwap(RegisterRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.username_, lhs_arena,
      &other->_impl_.username_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.password_, lhs_arena,
      &other->_impl_.password_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.email_, lhs_arena,
      &other->_impl_.email_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.verification_code_, lhs_arena,
      &other->_impl_.verification_code_, rhs_arena
  );
  swap(_impl_.header_, other->_impl_.header_);
}

std::string RegisterRequest::GetTypeName() const {
  return "kservice.RegisterRequest";
}


// ===================================================================

class RegisterResponse::_Internal {
 public:
  static const ::kservice::ResponseHeader& header(const RegisterResponse* msg);
};

const ::kservice::ResponseHeader&
RegisterResponse::_Internal::header(const RegisterResponse* msg) {
  return *msg->_impl_.header_;
}
RegisterResponse::RegisterResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:kservice.RegisterResponse)
}
RegisterResponse::RegisterResponse(const RegisterResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  RegisterResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.uid_){}
    , decltype(_impl_.username_){}
    , decltype(_impl_.email_){}
    , decltype(_impl_.header_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.uid_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.uid_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_uid().empty()) {
    _this->_impl_.uid_.Set(from._internal_uid(), 
      _this->GetArenaForAllocation());
  }
  _impl_.username_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.username_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_username().empty()) {
    _this->_impl_.username_.Set(from._internal_username(), 
      _this->GetArenaForAllocation());
  }
  _impl_.email_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.email_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_email().empty()) {
    _this->_impl_.email_.Set(from._internal_email(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_header()) {
    _this->_impl_.header_ = new ::kservice::ResponseHeader(*from._impl_.header_);
  }
  // @@protoc_insertion_point(copy_constructor:kservice.RegisterResponse)
}

inline void RegisterResponse::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.uid_){}
    , decltype(_impl_.username_){}
    , decltype(_impl_.email_){}
    , decltype(_impl_.header_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.uid_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.uid_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.username_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.username_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.email_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.email_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

RegisterResponse::~RegisterResponse() {
  // @@protoc_insertion_point(destructor:kservice.RegisterResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void RegisterResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.uid_.Destroy();
  _impl_.username_.Destroy();
  _impl_.email_.Destroy();
  if (this != internal_default_instance()) delete _impl_.header_;
}

void RegisterResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void RegisterResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:kservice.RegisterResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.uid_.ClearToEmpty();
  _impl_.username_.ClearToEmpty();
  _impl_.email_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && _impl_.header_ != nullptr) {
    delete _impl_.header_;
  }
  _impl_.header_ = nullptr;
  _internal_metadata_.Clear<std::string>();
}

const char* RegisterResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .kservice.ResponseHeader header = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_header(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string uid = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_uid();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else
          goto handle_unusual;
        continue;
      // string username = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_username();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else
          goto handle_unusual;
        continue;
      // string email = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_email();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* RegisterResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:kservice.RegisterResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .kservice.ResponseHeader header = 1;
  if (this->_internal_has_header()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::header(this),
        _Internal::header(this).GetCachedSize(), target, stream);
  }

  // string uid = 2;
  if (!this->_internal_uid().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_uid().data(), static_cast<int>(this->_internal_uid().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "kservice.RegisterResponse.uid");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_uid(), target);
  }

  // string username = 3;
  if (!this->_internal_username().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_username().data(), static_cast<int>(this->_internal_username().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "kservice.RegisterResponse.username");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_username(), target);
  }

  // string email = 4;
  if (!this->_internal_email().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_email().data(), static_cast<int>(this->_internal_email().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "kservice.RegisterResponse.email");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_email(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:kservice.RegisterResponse)
  return target;
}

size_t RegisterResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:kservice.RegisterResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string uid = 2;
  if (!this->_internal_uid().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_uid());
  }

  // string username = 3;
  if (!this->_internal_username().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_username());
  }

  // string email = 4;
  if (!this->_internal_email().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_email());
  }

  // .kservice.ResponseHeader header = 1;
  if (this->_internal_has_header()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.header_);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void RegisterResponse::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const RegisterResponse*>(
      &from));
}

void RegisterResponse::MergeFrom(const RegisterResponse& from) {
  RegisterResponse* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:kservice.RegisterResponse)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_uid().empty()) {
    _this->_internal_set_uid(from._internal_uid());
  }
  if (!from._internal_username().empty()) {
    _this->_internal_set_username(from._internal_username());
  }
  if (!from._internal_email().empty()) {
    _this->_internal_set_email(from._internal_email());
  }
  if (from._internal_has_header()) {
    _this->_internal_mutable_header()->::kservice::ResponseHeader::MergeFrom(
        from._internal_header());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void RegisterResponse::CopyFrom(const RegisterResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:kservice.RegisterResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RegisterResponse::IsInitialized() const {
  return true;
}

void RegisterResponse::InternalSwap(RegisterResponse* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.uid_, lhs_arena,
      &other->_impl_.uid_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.username_, lhs_arena,
      &other->_impl_.username_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.email_, lhs_arena,
      &other->_impl_.email_, rhs_arena
  );
  swap(_impl_.header_, other->_impl_.header_);
}

std::string RegisterResponse::GetTypeName() const {
  return "kservice.RegisterResponse";
}


// ===================================================================

class LoginRequest::_Internal {
 public:
  static const ::kservice::EventHeader& header(const LoginRequest* msg);
};

const ::kservice::EventHeader&
LoginRequest::_Internal::header(const LoginRequest* msg) {
  return *msg->_impl_.header_;
}
LoginRequest::LoginRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:kservice.LoginRequest)
}
LoginRequest::LoginRequest(const LoginRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  LoginRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.email_){}
    , decltype(_impl_.password_){}
    , decltype(_impl_.header_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.email_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.email_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_email().empty()) {
    _this->_impl_.email_.Set(from._internal_email(), 
      _this->GetArenaForAllocation());
  }
  _impl_.password_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.password_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_password().empty()) {
    _this->_impl_.password_.Set(from._internal_password(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_header()) {
    _this->_impl_.header_ = new ::kservice::EventHeader(*from._impl_.header_);
  }
  // @@protoc_insertion_point(copy_constructor:kservice.LoginRequest)
}

inline void LoginRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.email_){}
    , decltype(_impl_.password_){}
    , decltype(_impl_.header_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.email_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.email_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.password_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.password_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

LoginRequest::~LoginRequest() {
  // @@protoc_insertion_point(destructor:kservice.LoginRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void LoginRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.email_.Destroy();
  _impl_.password_.Destroy();
  if (this != internal_default_instance()) delete _impl_.header_;
}

void LoginRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void LoginRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:kservice.LoginRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.email_.ClearToEmpty();
  _impl_.password_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && _impl_.header_ != nullptr) {
    delete _impl_.header_;
  }
  _impl_.header_ = nullptr;
  _internal_metadata_.Clear<std::string>();
}

const char* LoginRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .kservice.EventHeader header = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_header(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string email = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_email();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else
          goto handle_unusual;
        continue;
      // string password = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_password();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* LoginRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:kservice.LoginRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .kservice.EventHeader header = 1;
  if (this->_internal_has_header()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::header(this),
        _Internal::header(this).GetCachedSize(), target, stream);
  }

  // string email = 2;
  if (!this->_internal_email().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_email().data(), static_cast<int>(this->_internal_email().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "kservice.LoginRequest.email");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_email(), target);
  }

  // string password = 3;
  if (!this->_internal_password().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_password().data(), static_cast<int>(this->_internal_password().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "kservice.LoginRequest.password");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_password(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:kservice.LoginRequest)
  return target;
}

size_t LoginRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:kservice.LoginRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string email = 2;
  if (!this->_internal_email().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_email());
  }

  // string password = 3;
  if (!this->_internal_password().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_password());
  }

  // .kservice.EventHeader header = 1;
  if (this->_internal_has_header()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.header_);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void LoginRequest::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const LoginRequest*>(
      &from));
}

void LoginRequest::MergeFrom(const LoginRequest& from) {
  LoginRequest* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:kservice.LoginRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_email().empty()) {
    _this->_internal_set_email(from._internal_email());
  }
  if (!from._internal_password().empty()) {
    _this->_internal_set_password(from._internal_password());
  }
  if (from._internal_has_header()) {
    _this->_internal_mutable_header()->::kservice::EventHeader::MergeFrom(
        from._internal_header());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void LoginRequest::CopyFrom(const LoginRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:kservice.LoginRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LoginRequest::IsInitialized() const {
  return true;
}

void LoginRequest::InternalSwap(LoginRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.email_, lhs_arena,
      &other->_impl_.email_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.password_, lhs_arena,
      &other->_impl_.password_, rhs_arena
  );
  swap(_impl_.header_, other->_impl_.header_);
}

std::string LoginRequest::GetTypeName() const {
  return "kservice.LoginRequest";
}


// ===================================================================

class LoginResponse::_Internal {
 public:
  static const ::kservice::ResponseHeader& header(const LoginResponse* msg);
};

const ::kservice::ResponseHeader&
LoginResponse::_Internal::header(const LoginResponse* msg) {
  return *msg->_impl_.header_;
}
LoginResponse::LoginResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:kservice.LoginResponse)
}
LoginResponse::LoginResponse(const LoginResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  LoginResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.uid_){}
    , decltype(_impl_.username_){}
    , decltype(_impl_.email_){}
    , decltype(_impl_.access_token_){}
    , decltype(_impl_.refresh_token_){}
    , decltype(_impl_.header_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.uid_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.uid_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_uid().empty()) {
    _this->_impl_.uid_.Set(from._internal_uid(), 
      _this->GetArenaForAllocation());
  }
  _impl_.username_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.username_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_username().empty()) {
    _this->_impl_.username_.Set(from._internal_username(), 
      _this->GetArenaForAllocation());
  }
  _impl_.email_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.email_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_email().empty()) {
    _this->_impl_.email_.Set(from._internal_email(), 
      _this->GetArenaForAllocation());
  }
  _impl_.access_token_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.access_token_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_access_token().empty()) {
    _this->_impl_.access_token_.Set(from._internal_access_token(), 
      _this->GetArenaForAllocation());
  }
  _impl_.refresh_token_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.refresh_token_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_refresh_token().empty()) {
    _this->_impl_.refresh_token_.Set(from._internal_refresh_token(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_header()) {
    _this->_impl_.header_ = new ::kservice::ResponseHeader(*from._impl_.header_);
  }
  // @@protoc_insertion_point(copy_constructor:kservice.LoginResponse)
}

inline void LoginResponse::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.uid_){}
    , decltype(_impl_.username_){}
    , decltype(_impl_.email_){}
    , decltype(_impl_.access_token_){}
    , decltype(_impl_.refresh_token_){}
    , decltype(_impl_.header_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.uid_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.uid_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.username_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.username_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.email_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.email_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.access_token_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.access_token_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.refresh_token_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.refresh_token_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

LoginResponse::~LoginResponse() {
  // @@protoc_insertion_point(destructor:kservice.LoginResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void LoginResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.uid_.Destroy();
  _impl_.username_.Destroy();
  _impl_.email_.Destroy();
  _impl_.access_token_.Destroy();
  _impl_.refresh_token_.Destroy();
  if (this != internal_default_instance()) delete _impl_.header_;
}

void LoginResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void LoginResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:kservice.LoginResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.uid_.ClearToEmpty();
  _impl_.username_.ClearToEmpty();
  _impl_.email_.ClearToEmpty();
  _impl_.access_token_.ClearToEmpty();
  _impl_.refresh_token_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && _impl_.header_ != nullptr) {
    delete _impl_.header_;
  }
  _impl_.header_ = nullptr;
  _internal_metadata_.Clear<std::string>();
}

const char* LoginResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .kservice.ResponseHeader header = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_header(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string uid = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_uid();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else
          goto handle_unusual;
        continue;
      // string username = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_username();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else
          goto handle_unusual;
        continue;
      // string email = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_email();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else
          goto handle_unusual;
        continue;
      // string access_token = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_access_token();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else
          goto handle_unusual;
        continue;
      // string refresh_token = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          auto str = _internal_mutable_refresh_token();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* LoginResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:kservice.LoginResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .kservice.ResponseHeader header = 1;
  if (this->_internal_has_header()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::header(this),
        _Internal::header(this).GetCachedSize(), target, stream);
  }

  // string uid = 2;
  if (!this->_internal_uid().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_uid().data(), static_cast<int>(this->_internal_uid().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "kservice.LoginResponse.uid");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_uid(), target);
  }

  // string username = 3;
  if (!this->_internal_username().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_username().data(), static_cast<int>(this->_internal_username().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "kservice.LoginResponse.username");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_username(), target);
  }

  // string email = 4;
  if (!this->_internal_email().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_email().data(), static_cast<int>(this->_internal_email().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "kservice.LoginResponse.email");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_email(), target);
  }

  // string access_token = 5;
  if (!this->_internal_access_token().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_access_token().data(), static_cast<int>(this->_internal_access_token().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "kservice.LoginResponse.access_token");
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_access_token(), target);
  }

  // string refresh_token = 6;
  if (!this->_internal_refresh_token().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_refresh_token().data(), static_cast<int>(this->_internal_refresh_token().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "kservice.LoginResponse.refresh_token");
    target = stream->WriteStringMaybeAliased(
        6, this->_internal_refresh_token(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:kservice.LoginResponse)
  return target;
}

size_t LoginResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:kservice.LoginResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string uid = 2;
  if (!this->_internal_uid().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_uid());
  }

  // string username = 3;
  if (!this->_internal_username().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_username());
  }

  // string email = 4;
  if (!this->_internal_email().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_email());
  }

  // string access_token = 5;
  if (!this->_internal_access_token().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_access_token());
  }

  // string refresh_token = 6;
  if (!this->_internal_refresh_token().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_refresh_token());
  }

  // .kservice.ResponseHeader header = 1;
  if (this->_internal_has_header()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.header_);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void LoginResponse::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const LoginResponse*>(
      &from));
}

void LoginResponse::MergeFrom(const LoginResponse& from) {
  LoginResponse* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:kservice.LoginResponse)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_uid().empty()) {
    _this->_internal_set_uid(from._internal_uid());
  }
  if (!from._internal_username().empty()) {
    _this->_internal_set_username(from._internal_username());
  }
  if (!from._internal_email().empty()) {
    _this->_internal_set_email(from._internal_email());
  }
  if (!from._internal_access_token().empty()) {
    _this->_internal_set_access_token(from._internal_access_token());
  }
  if (!from._internal_refresh_token().empty()) {
    _this->_internal_set_refresh_token(from._internal_refresh_token());
  }
  if (from._internal_has_header()) {
    _this->_internal_mutable_header()->::kservice::ResponseHeader::MergeFrom(
        from._internal_header());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void LoginResponse::CopyFrom(const LoginResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:kservice.LoginResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LoginResponse::IsInitialized() const {
  return true;
}

void LoginResponse::InternalSwap(LoginResponse* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.uid_, lhs_arena,
      &other->_impl_.uid_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.username_, lhs_arena,
      &other->_impl_.username_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.email_, lhs_arena,
      &other->_impl_.email_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.access_token_, lhs_arena,
      &other->_impl_.access_token_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.refresh_token_, lhs_arena,
      &other->_impl_.refresh_token_, rhs_arena
  );
  swap(_impl_.header_, other->_impl_.header_);
}

std::string LoginResponse::GetTypeName() const {
  return "kservice.LoginResponse";
}


// ===================================================================

class RefreshRequest::_Internal {
 public:
  static const ::kservice::EventHeader& header(const RefreshRequest* msg);
};

const ::kservice::EventHeader&
RefreshRequest::_Internal::header(const RefreshRequest* msg) {
  return *msg->_impl_.header_;
}
RefreshRequest::RefreshRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:kservice.RefreshRequest)
}
RefreshRequest::RefreshRequest(const RefreshRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  RefreshRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.header_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_header()) {
    _this->_impl_.header_ = new ::kservice::EventHeader(*from._impl_.header_);
  }
  // @@protoc_insertion_point(copy_constructor:kservice.RefreshRequest)
}

inline void RefreshRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.header_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

RefreshRequest::~RefreshRequest() {
  // @@protoc_insertion_point(destructor:kservice.RefreshRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void RefreshRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.header_;
}

void RefreshRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void RefreshRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:kservice.RefreshRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.header_ != nullptr) {
    delete _impl_.header_;
  }
  _impl_.header_ = nullptr;
  _internal_metadata_.Clear<std::string>();
}

const char* RefreshRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .kservice.EventHeader header = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_header(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* RefreshRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:kservice.RefreshRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .kservice.EventHeader header = 1;
  if (this->_internal_has_header()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::header(this),
        _Internal::header(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:kservice.RefreshRequest)
  return target;
}

size_t RefreshRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:kservice.RefreshRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .kservice.EventHeader header = 1;
  if (this->_internal_has_header()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.header_);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void RefreshRequest::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const RefreshRequest*>(
      &from));
}

void RefreshRequest::MergeFrom(const RefreshRequest& from) {
  RefreshRequest* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:kservice.RefreshRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_header()) {
    _this->_internal_mutable_header()->::kservice::EventHeader::MergeFrom(
        from._internal_header());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void RefreshRequest::CopyFrom(const RefreshRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:kservice.RefreshRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RefreshRequest::IsInitialized() const {
  return true;
}

void RefreshRequest::InternalSwap(RefreshRequest* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.header_, other->_impl_.header_);
}

std::string RefreshRequest::GetTypeName() const {
  return "kservice.RefreshRequest";
}


// ===================================================================

class RefreshResponse::_Internal {
 public:
  static const ::kservice::ResponseHeader& header(const RefreshResponse* msg);
};

const ::kservice::ResponseHeader&
RefreshResponse::_Internal::header(const RefreshResponse* msg) {
  return *msg->_impl_.header_;
}
RefreshResponse::RefreshResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:kservice.RefreshResponse)
}
RefreshResponse::RefreshResponse(const RefreshResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  RefreshResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.uid_){}
    , decltype(_impl_.access_token_){}
    , decltype(_impl_.header_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.uid_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.uid_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_uid().empty()) {
    _this->_impl_.uid_.Set(from._internal_uid(), 
      _this->GetArenaForAllocation());
  }
  _impl_.access_token_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.access_token_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_access_token().empty()) {
    _this->_impl_.access_token_.Set(from._internal_access_token(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_header()) {
    _this->_impl_.header_ = new ::kservice::ResponseHeader(*from._impl_.header_);
  }
  // @@protoc_insertion_point(copy_constructor:kservice.RefreshResponse)
}

inline void RefreshResponse::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.uid_){}
    , decltype(_impl_.access_token_){}
    , decltype(_impl_.header_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.uid_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.uid_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.access_token_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.access_token_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

RefreshResponse::~RefreshResponse() {
  // @@protoc_insertion_point(destructor:kservice.RefreshResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void RefreshResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.uid_.Destroy();
  _impl_.access_token_.Destroy();
  if (this != internal_default_instance()) delete _impl_.header_;
}

void RefreshResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void RefreshResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:kservice.RefreshResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.uid_.ClearToEmpty();
  _impl_.access_token_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && _impl_.header_ != nullptr) {
    delete _impl_.header_;
  }
  _impl_.header_ = nullptr;
  _internal_metadata_.Clear<std::string>();
}

const char* RefreshResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .kservice.ResponseHeader header = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_header(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string uid = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_uid();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else
          goto handle_unusual;
        continue;
      // string access_token = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_access_token();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* RefreshResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:kservice.RefreshResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .kservice.ResponseHeader header = 1;
  if (this->_internal_has_header()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::header(this),
        _Internal::header(this).GetCachedSize(), target, stream);
  }

  // string uid = 2;
  if (!this->_internal_uid().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_uid().data(), static_cast<int>(this->_internal_uid().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "kservice.RefreshResponse.uid");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_uid(), target);
  }

  // string access_token = 3;
  if (!this->_internal_access_token().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_access_token().data(), static_cast<int>(this->_internal_access_token().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "kservice.RefreshResponse.access_token");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_access_token(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:kservice.RefreshResponse)
  return target;
}

size_t RefreshResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:kservice.RefreshResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string uid = 2;
  if (!this->_internal_uid().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_uid());
  }

  // string access_token = 3;
  if (!this->_internal_access_token().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_access_token());
  }

  // .kservice.ResponseHeader header = 1;
  if (this->_internal_has_header()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.header_);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void RefreshResponse::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const RefreshResponse*>(
      &from));
}

void RefreshResponse::MergeFrom(const RefreshResponse& from) {
  RefreshResponse* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:kservice.RefreshResponse)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_uid().empty()) {
    _this->_internal_set_uid(from._internal_uid());
  }
  if (!from._internal_access_token().empty()) {
    _this->_internal_set_access_token(from._internal_access_token());
  }
  if (from._internal_has_header()) {
    _this->_internal_mutable_header()->::kservice::ResponseHeader::MergeFrom(
        from._internal_header());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void RefreshResponse::CopyFrom(const RefreshResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:kservice.RefreshResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RefreshResponse::IsInitialized() const {
  return true;
}

void RefreshResponse::InternalSwap(RefreshResponse* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.uid_, lhs_arena,
      &other->_impl_.uid_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.access_token_, lhs_arena,
      &other->_impl_.access_token_, rhs_arena
  );
  swap(_impl_.header_, other->_impl_.header_);
}

std::string RefreshResponse::GetTypeName() const {
  return "kservice.RefreshResponse";
}


// ===================================================================

class SendVerificationRequest::_Internal {
 public:
  static const ::kservice::EventHeader& header(const SendVerificationRequest* msg);
};

const ::kservice::EventHeader&
SendVerificationRequest::_Internal::header(const SendVerificationRequest* msg) {
  return *msg->_impl_.header_;
}
SendVerificationRequest::SendVerificationRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:kservice.SendVerificationRequest)
}
SendVerificationRequest::SendVerificationRequest(const SendVerificationRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  SendVerificationRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.email_){}
    , decltype(_impl_.header_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.email_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.email_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_email().empty()) {
    _this->_impl_.email_.Set(from._internal_email(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_header()) {
    _this->_impl_.header_ = new ::kservice::EventHeader(*from._impl_.header_);
  }
  // @@protoc_insertion_point(copy_constructor:kservice.SendVerificationRequest)
}

inline void SendVerificationRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.email_){}
    , decltype(_impl_.header_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.email_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.email_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

SendVerificationRequest::~SendVerificationRequest() {
  // @@protoc_insertion_point(destructor:kservice.SendVerificationRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SendVerificationRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.email_.Destroy();
  if (this != internal_default_instance()) delete _impl_.header_;
}

void SendVerificationRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SendVerificationRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:kservice.SendVerificationRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.email_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && _impl_.header_ != nullptr) {
    delete _impl_.header_;
  }
  _impl_.header_ = nullptr;
  _internal_metadata_.Clear<std::string>();
}

const char* SendVerificationRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .kservice.EventHeader header = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_header(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string email = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_email();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SendVerificationRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:kservice.SendVerificationRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .kservice.EventHeader header = 1;
  if (this->_internal_has_header()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::header(this),
        _Internal::header(this).GetCachedSize(), target, stream);
  }

  // string email = 2;
  if (!this->_internal_email().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_email().data(), static_cast<int>(this->_internal_email().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "kservice.SendVerificationRequest.email");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_email(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:kservice.SendVerificationRequest)
  return target;
}

size_t SendVerificationRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:kservice.SendVerificationRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string email = 2;
  if (!this->_internal_email().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_email());
  }

  // .kservice.EventHeader header = 1;
  if (this->_internal_has_header()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.header_);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void SendVerificationRequest::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const SendVerificationRequest*>(
      &from));
}

void SendVerificationRequest::MergeFrom(const SendVerificationRequest& from) {
  SendVerificationRequest* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:kservice.SendVerificationRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_email().empty()) {
    _this->_internal_set_email(from._internal_email());
  }
  if (from._internal_has_header()) {
    _this->_internal_mutable_header()->::kservice::EventHeader::MergeFrom(
        from._internal_header());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void SendVerificationRequest::CopyFrom(const SendVerificationRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:kservice.SendVerificationRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SendVerificationRequest::IsInitialized() const {
  return true;
}

void SendVerificationRequest::InternalSwap(SendVerificationRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.email_, lhs_arena,
      &other->_impl_.email_, rhs_arena
  );
  swap(_impl_.header_, other->_impl_.header_);
}

std::string SendVerificationRequest::GetTypeName() const {
  return "kservice.SendVerificationRequest";
}


// ===================================================================

class SendVerificationResponse::_Internal {
 public:
  static const ::kservice::ResponseHeader& header(const SendVerificationResponse* msg);
};

const ::kservice::ResponseHeader&
SendVerificationResponse::_Internal::header(const SendVerificationResponse* msg) {
  return *msg->_impl_.header_;
}
SendVerificationResponse::SendVerificationResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:kservice.SendVerificationResponse)
}
SendVerificationResponse::SendVerificationResponse(const SendVerificationResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  SendVerificationResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.header_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_header()) {
    _this->_impl_.header_ = new ::kservice::ResponseHeader(*from._impl_.header_);
  }
  // @@protoc_insertion_point(copy_constructor:kservice.SendVerificationResponse)
}

inline void SendVerificationResponse::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.header_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

SendVerificationResponse::~SendVerificationResponse() {
  // @@protoc_insertion_point(destructor:kservice.SendVerificationResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SendVerificationResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.header_;
}

void SendVerificationResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SendVerificationResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:kservice.SendVerificationResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.header_ != nullptr) {
    delete _impl_.header_;
  }
  _impl_.header_ = nullptr;
  _internal_metadata_.Clear<std::string>();
}

const char* SendVerificationResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .kservice.ResponseHeader header = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_header(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SendVerificationResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:kservice.SendVerificationResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .kservice.ResponseHeader header = 1;
  if (this->_internal_has_header()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::header(this),
        _Internal::header(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:kservice.SendVerificationResponse)
  return target;
}

size_t SendVerificationResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:kservice.SendVerificationResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .kservice.ResponseHeader header = 1;
  if (this->_internal_has_header()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.header_);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void SendVerificationResponse::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const SendVerificationResponse*>(
      &from));
}

void SendVerificationResponse::MergeFrom(const SendVerificationResponse& from) {
  SendVerificationResponse* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:kservice.SendVerificationResponse)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_header()) {
    _this->_internal_mutable_header()->::kservice::ResponseHeader::MergeFrom(
        from._internal_header());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void SendVerificationResponse::CopyFrom(const SendVerificationResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:kservice.SendVerificationResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SendVerificationResponse::IsInitialized() const {
  return true;
}

void SendVerificationResponse::InternalSwap(SendVerificationResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.header_, other->_impl_.header_);
}

std::string SendVerificationResponse::GetTypeName() const {
  return "kservice.SendVerificationResponse";
}


// ===================================================================

class UVEvent_StepTime::_Internal {
 public:
};

UVEvent_StepTime::UVEvent_StepTime(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:kservice.UVEvent.StepTime)
}
UVEvent_StepTime::UVEvent_StepTime(const UVEvent_StepTime& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  UVEvent_StepTime* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.step_){}
    , decltype(_impl_.time_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.step_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.step_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_step().empty()) {
    _this->_impl_.step_.Set(from._internal_step(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.time_ = from._impl_.time_;
  // @@protoc_insertion_point(copy_constructor:kservice.UVEvent.StepTime)
}

inline void UVEvent_StepTime::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.step_){}
    , decltype(_impl_.time_){int64_t{0}}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.step_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.step_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

UVEvent_StepTime::~UVEvent_StepTime() {
  // @@protoc_insertion_point(destructor:kservice.UVEvent.StepTime)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void UVEvent_StepTime::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.step_.Destroy();
}

void UVEvent_StepTime::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void UVEvent_StepTime::Clear() {
// @@protoc_insertion_point(message_clear_start:kservice.UVEvent.StepTime)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.step_.ClearToEmpty();
  _impl_.time_ = int64_t{0};
  _internal_metadata_.Clear<std::string>();
}

const char* UVEvent_StepTime::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string step = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_step();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else
          goto handle_unusual;
        continue;
      // int64 time = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.time_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* UVEvent_StepTime::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:kservice.UVEvent.StepTime)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string step = 1;
  if (!this->_internal_step().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_step().data(), static_cast<int>(this->_internal_step().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "kservice.UVEvent.StepTime.step");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_step(), target);
  }

  // int64 time = 2;
  if (this->_internal_time() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(2, this->_internal_time(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:kservice.UVEvent.StepTime)
  return target;
}

size_t UVEvent_StepTime::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:kservice.UVEvent.StepTime)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string step = 1;
  if (!this->_internal_step().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_step());
  }

  // int64 time = 2;
  if (this->_internal_time() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_time());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void UVEvent_StepTime::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const UVEvent_StepTime*>(
      &from));
}

void UVEvent_StepTime::MergeFrom(const UVEvent_StepTime& from) {
  UVEvent_StepTime* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:kservice.UVEvent.StepTime)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_step().empty()) {
    _this->_internal_set_step(from._internal_step());
  }
  if (from._internal_time() != 0) {
    _this->_internal_set_time(from._internal_time());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void UVEvent_StepTime::CopyFrom(const UVEvent_StepTime& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:kservice.UVEvent.StepTime)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UVEvent_StepTime::IsInitialized() const {
  return true;
}

void UVEvent_StepTime::InternalSwap(UVEvent_StepTime* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.step_, lhs_arena,
      &other->_impl_.step_, rhs_arena
  );
  swap(_impl_.time_, other->_impl_.time_);
}

std::string UVEvent_StepTime::GetTypeName() const {
  return "kservice.UVEvent.StepTime";
}


// ===================================================================

class UVEvent::_Internal {
 public:
  static const ::kservice::EventHeader& header(const UVEvent* msg);
};

const ::kservice::EventHeader&
UVEvent::_Internal::header(const UVEvent* msg) {
  return *msg->_impl_.header_;
}
UVEvent::UVEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:kservice.UVEvent)
}
UVEvent::UVEvent(const UVEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  UVEvent* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.steptimes_){from._impl_.steptimes_}
    , decltype(_impl_.header_){nullptr}
    , decltype(_impl_.startupts_){}
    , decltype(_impl_.isstartup_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_header()) {
    _this->_impl_.header_ = new ::kservice::EventHeader(*from._impl_.header_);
  }
  ::memcpy(&_impl_.startupts_, &from._impl_.startupts_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.isstartup_) -
    reinterpret_cast<char*>(&_impl_.startupts_)) + sizeof(_impl_.isstartup_));
  // @@protoc_insertion_point(copy_constructor:kservice.UVEvent)
}

inline void UVEvent::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.steptimes_){arena}
    , decltype(_impl_.header_){nullptr}
    , decltype(_impl_.startupts_){int64_t{0}}
    , decltype(_impl_.isstartup_){false}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

UVEvent::~UVEvent() {
  // @@protoc_insertion_point(destructor:kservice.UVEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void UVEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.steptimes_.~RepeatedPtrField();
  if (this != internal_default_instance()) delete _impl_.header_;
}

void UVEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void UVEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:kservice.UVEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.steptimes_.Clear();
  if (GetArenaForAllocation() == nullptr && _impl_.header_ != nullptr) {
    delete _impl_.header_;
  }
  _impl_.header_ = nullptr;
  ::memset(&_impl_.startupts_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.isstartup_) -
      reinterpret_cast<char*>(&_impl_.startupts_)) + sizeof(_impl_.isstartup_));
  _internal_metadata_.Clear<std::string>();
}

const char* UVEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .kservice.EventHeader header = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_header(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool isStartup = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.isstartup_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int64 startupTs = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _impl_.startupts_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .kservice.UVEvent.StepTime stepTimes = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_steptimes(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* UVEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:kservice.UVEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .kservice.EventHeader header = 1;
  if (this->_internal_has_header()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::header(this),
        _Internal::header(this).GetCachedSize(), target, stream);
  }

  // bool isStartup = 2;
  if (this->_internal_isstartup() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(2, this->_internal_isstartup(), target);
  }

  // int64 startupTs = 3;
  if (this->_internal_startupts() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(3, this->_internal_startupts(), target);
  }

  // repeated .kservice.UVEvent.StepTime stepTimes = 4;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_steptimes_size()); i < n; i++) {
    const auto& repfield = this->_internal_steptimes(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(4, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:kservice.UVEvent)
  return target;
}

size_t UVEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:kservice.UVEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .kservice.UVEvent.StepTime stepTimes = 4;
  total_size += 1UL * this->_internal_steptimes_size();
  for (const auto& msg : this->_impl_.steptimes_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // .kservice.EventHeader header = 1;
  if (this->_internal_has_header()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.header_);
  }

  // int64 startupTs = 3;
  if (this->_internal_startupts() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_startupts());
  }

  // bool isStartup = 2;
  if (this->_internal_isstartup() != 0) {
    total_size += 1 + 1;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void UVEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const UVEvent*>(
      &from));
}

void UVEvent::MergeFrom(const UVEvent& from) {
  UVEvent* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:kservice.UVEvent)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.steptimes_.MergeFrom(from._impl_.steptimes_);
  if (from._internal_has_header()) {
    _this->_internal_mutable_header()->::kservice::EventHeader::MergeFrom(
        from._internal_header());
  }
  if (from._internal_startupts() != 0) {
    _this->_internal_set_startupts(from._internal_startupts());
  }
  if (from._internal_isstartup() != 0) {
    _this->_internal_set_isstartup(from._internal_isstartup());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void UVEvent::CopyFrom(const UVEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:kservice.UVEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UVEvent::IsInitialized() const {
  return true;
}

void UVEvent::InternalSwap(UVEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.steptimes_.InternalSwap(&other->_impl_.steptimes_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(UVEvent, _impl_.isstartup_)
      + sizeof(UVEvent::_impl_.isstartup_)
      - PROTOBUF_FIELD_OFFSET(UVEvent, _impl_.header_)>(
          reinterpret_cast<char*>(&_impl_.header_),
          reinterpret_cast<char*>(&other->_impl_.header_));
}

std::string UVEvent::GetTypeName() const {
  return "kservice.UVEvent";
}


// ===================================================================

class UVEventResponse_LatestVersion::_Internal {
 public:
};

UVEventResponse_LatestVersion::UVEventResponse_LatestVersion(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:kservice.UVEventResponse.LatestVersion)
}
UVEventResponse_LatestVersion::UVEventResponse_LatestVersion(const UVEventResponse_LatestVersion& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  UVEventResponse_LatestVersion* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.url_){}
    , decltype(_impl_.info_){}
    , decltype(_impl_.version_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.url_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.url_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_url().empty()) {
    _this->_impl_.url_.Set(from._internal_url(), 
      _this->GetArenaForAllocation());
  }
  _impl_.info_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.info_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_info().empty()) {
    _this->_impl_.info_.Set(from._internal_info(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.version_ = from._impl_.version_;
  // @@protoc_insertion_point(copy_constructor:kservice.UVEventResponse.LatestVersion)
}

inline void UVEventResponse_LatestVersion::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.url_){}
    , decltype(_impl_.info_){}
    , decltype(_impl_.version_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.url_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.url_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.info_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.info_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

UVEventResponse_LatestVersion::~UVEventResponse_LatestVersion() {
  // @@protoc_insertion_point(destructor:kservice.UVEventResponse.LatestVersion)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void UVEventResponse_LatestVersion::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.url_.Destroy();
  _impl_.info_.Destroy();
}

void UVEventResponse_LatestVersion::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void UVEventResponse_LatestVersion::Clear() {
// @@protoc_insertion_point(message_clear_start:kservice.UVEventResponse.LatestVersion)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.url_.ClearToEmpty();
  _impl_.info_.ClearToEmpty();
  _impl_.version_ = 0;
  _internal_metadata_.Clear<std::string>();
}

const char* UVEventResponse_LatestVersion::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int32 version = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.version_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string url = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_url();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else
          goto handle_unusual;
        continue;
      // string info = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_info();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* UVEventResponse_LatestVersion::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:kservice.UVEventResponse.LatestVersion)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // int32 version = 1;
  if (this->_internal_version() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_version(), target);
  }

  // string url = 2;
  if (!this->_internal_url().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_url().data(), static_cast<int>(this->_internal_url().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "kservice.UVEventResponse.LatestVersion.url");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_url(), target);
  }

  // string info = 3;
  if (!this->_internal_info().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_info().data(), static_cast<int>(this->_internal_info().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "kservice.UVEventResponse.LatestVersion.info");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_info(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:kservice.UVEventResponse.LatestVersion)
  return target;
}

size_t UVEventResponse_LatestVersion::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:kservice.UVEventResponse.LatestVersion)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string url = 2;
  if (!this->_internal_url().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_url());
  }

  // string info = 3;
  if (!this->_internal_info().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_info());
  }

  // int32 version = 1;
  if (this->_internal_version() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_version());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void UVEventResponse_LatestVersion::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const UVEventResponse_LatestVersion*>(
      &from));
}

void UVEventResponse_LatestVersion::MergeFrom(const UVEventResponse_LatestVersion& from) {
  UVEventResponse_LatestVersion* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:kservice.UVEventResponse.LatestVersion)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_url().empty()) {
    _this->_internal_set_url(from._internal_url());
  }
  if (!from._internal_info().empty()) {
    _this->_internal_set_info(from._internal_info());
  }
  if (from._internal_version() != 0) {
    _this->_internal_set_version(from._internal_version());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void UVEventResponse_LatestVersion::CopyFrom(const UVEventResponse_LatestVersion& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:kservice.UVEventResponse.LatestVersion)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UVEventResponse_LatestVersion::IsInitialized() const {
  return true;
}

void UVEventResponse_LatestVersion::InternalSwap(UVEventResponse_LatestVersion* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.url_, lhs_arena,
      &other->_impl_.url_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.info_, lhs_arena,
      &other->_impl_.info_, rhs_arena
  );
  swap(_impl_.version_, other->_impl_.version_);
}

std::string UVEventResponse_LatestVersion::GetTypeName() const {
  return "kservice.UVEventResponse.LatestVersion";
}


// ===================================================================

class UVEventResponse::_Internal {
 public:
  static const ::kservice::ResponseHeader& header(const UVEventResponse* msg);
  static const ::kservice::UVEventResponse_LatestVersion& latestversioninfo(const UVEventResponse* msg);
};

const ::kservice::ResponseHeader&
UVEventResponse::_Internal::header(const UVEventResponse* msg) {
  return *msg->_impl_.header_;
}
const ::kservice::UVEventResponse_LatestVersion&
UVEventResponse::_Internal::latestversioninfo(const UVEventResponse* msg) {
  return *msg->_impl_.latestversioninfo_;
}
UVEventResponse::UVEventResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:kservice.UVEventResponse)
}
UVEventResponse::UVEventResponse(const UVEventResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  UVEventResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.header_){nullptr}
    , decltype(_impl_.latestversioninfo_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_header()) {
    _this->_impl_.header_ = new ::kservice::ResponseHeader(*from._impl_.header_);
  }
  if (from._internal_has_latestversioninfo()) {
    _this->_impl_.latestversioninfo_ = new ::kservice::UVEventResponse_LatestVersion(*from._impl_.latestversioninfo_);
  }
  // @@protoc_insertion_point(copy_constructor:kservice.UVEventResponse)
}

inline void UVEventResponse::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.header_){nullptr}
    , decltype(_impl_.latestversioninfo_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

UVEventResponse::~UVEventResponse() {
  // @@protoc_insertion_point(destructor:kservice.UVEventResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void UVEventResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.header_;
  if (this != internal_default_instance()) delete _impl_.latestversioninfo_;
}

void UVEventResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void UVEventResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:kservice.UVEventResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.header_ != nullptr) {
    delete _impl_.header_;
  }
  _impl_.header_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.latestversioninfo_ != nullptr) {
    delete _impl_.latestversioninfo_;
  }
  _impl_.latestversioninfo_ = nullptr;
  _internal_metadata_.Clear<std::string>();
}

const char* UVEventResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .kservice.ResponseHeader header = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_header(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .kservice.UVEventResponse.LatestVersion latestVersionInfo = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_latestversioninfo(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* UVEventResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:kservice.UVEventResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .kservice.ResponseHeader header = 1;
  if (this->_internal_has_header()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::header(this),
        _Internal::header(this).GetCachedSize(), target, stream);
  }

  // .kservice.UVEventResponse.LatestVersion latestVersionInfo = 2;
  if (this->_internal_has_latestversioninfo()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::latestversioninfo(this),
        _Internal::latestversioninfo(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:kservice.UVEventResponse)
  return target;
}

size_t UVEventResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:kservice.UVEventResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .kservice.ResponseHeader header = 1;
  if (this->_internal_has_header()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.header_);
  }

  // .kservice.UVEventResponse.LatestVersion latestVersionInfo = 2;
  if (this->_internal_has_latestversioninfo()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.latestversioninfo_);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void UVEventResponse::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const UVEventResponse*>(
      &from));
}

void UVEventResponse::MergeFrom(const UVEventResponse& from) {
  UVEventResponse* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:kservice.UVEventResponse)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_header()) {
    _this->_internal_mutable_header()->::kservice::ResponseHeader::MergeFrom(
        from._internal_header());
  }
  if (from._internal_has_latestversioninfo()) {
    _this->_internal_mutable_latestversioninfo()->::kservice::UVEventResponse_LatestVersion::MergeFrom(
        from._internal_latestversioninfo());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void UVEventResponse::CopyFrom(const UVEventResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:kservice.UVEventResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UVEventResponse::IsInitialized() const {
  return true;
}

void UVEventResponse::InternalSwap(UVEventResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(UVEventResponse, _impl_.latestversioninfo_)
      + sizeof(UVEventResponse::_impl_.latestversioninfo_)
      - PROTOBUF_FIELD_OFFSET(UVEventResponse, _impl_.header_)>(
          reinterpret_cast<char*>(&_impl_.header_),
          reinterpret_cast<char*>(&other->_impl_.header_));
}

std::string UVEventResponse::GetTypeName() const {
  return "kservice.UVEventResponse";
}


// ===================================================================

class KFileInfo::_Internal {
 public:
};

KFileInfo::KFileInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:kservice.KFileInfo)
}
KFileInfo::KFileInfo(const KFileInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  KFileInfo* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.filename_){}
    , decltype(_impl_.fullpath_){}
    , decltype(_impl_.hash32_){}
    , decltype(_impl_.torrenthash_){}
    , decltype(_impl_.url_){}
    , decltype(_impl_.durationms_){}
    , decltype(_impl_.filesize_){}
    , decltype(_impl_.islocal_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.filename_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.filename_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_filename().empty()) {
    _this->_impl_.filename_.Set(from._internal_filename(), 
      _this->GetArenaForAllocation());
  }
  _impl_.fullpath_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.fullpath_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_fullpath().empty()) {
    _this->_impl_.fullpath_.Set(from._internal_fullpath(), 
      _this->GetArenaForAllocation());
  }
  _impl_.hash32_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.hash32_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_hash32().empty()) {
    _this->_impl_.hash32_.Set(from._internal_hash32(), 
      _this->GetArenaForAllocation());
  }
  _impl_.torrenthash_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.torrenthash_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_torrenthash().empty()) {
    _this->_impl_.torrenthash_.Set(from._internal_torrenthash(), 
      _this->GetArenaForAllocation());
  }
  _impl_.url_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.url_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_url().empty()) {
    _this->_impl_.url_.Set(from._internal_url(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.durationms_, &from._impl_.durationms_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.islocal_) -
    reinterpret_cast<char*>(&_impl_.durationms_)) + sizeof(_impl_.islocal_));
  // @@protoc_insertion_point(copy_constructor:kservice.KFileInfo)
}

inline void KFileInfo::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.filename_){}
    , decltype(_impl_.fullpath_){}
    , decltype(_impl_.hash32_){}
    , decltype(_impl_.torrenthash_){}
    , decltype(_impl_.url_){}
    , decltype(_impl_.durationms_){int64_t{0}}
    , decltype(_impl_.filesize_){int64_t{0}}
    , decltype(_impl_.islocal_){false}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.filename_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.filename_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.fullpath_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.fullpath_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.hash32_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.hash32_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.torrenthash_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.torrenthash_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.url_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.url_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

KFileInfo::~KFileInfo() {
  // @@protoc_insertion_point(destructor:kservice.KFileInfo)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void KFileInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.filename_.Destroy();
  _impl_.fullpath_.Destroy();
  _impl_.hash32_.Destroy();
  _impl_.torrenthash_.Destroy();
  _impl_.url_.Destroy();
}

void KFileInfo::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void KFileInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:kservice.KFileInfo)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.filename_.ClearToEmpty();
  _impl_.fullpath_.ClearToEmpty();
  _impl_.hash32_.ClearToEmpty();
  _impl_.torrenthash_.ClearToEmpty();
  _impl_.url_.ClearToEmpty();
  ::memset(&_impl_.durationms_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.islocal_) -
      reinterpret_cast<char*>(&_impl_.durationms_)) + sizeof(_impl_.islocal_));
  _internal_metadata_.Clear<std::string>();
}

const char* KFileInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string fileName = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_filename();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else
          goto handle_unusual;
        continue;
      // string fullPath = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_fullpath();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else
          goto handle_unusual;
        continue;
      // string hash32 = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_hash32();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else
          goto handle_unusual;
        continue;
      // string torrentHash = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_torrenthash();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else
          goto handle_unusual;
        continue;
      // string url = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_url();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else
          goto handle_unusual;
        continue;
      // int64 durationMs = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _impl_.durationms_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int64 fileSize = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _impl_.filesize_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool isLocal = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _impl_.islocal_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* KFileInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:kservice.KFileInfo)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string fileName = 1;
  if (!this->_internal_filename().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_filename().data(), static_cast<int>(this->_internal_filename().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "kservice.KFileInfo.fileName");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_filename(), target);
  }

  // string fullPath = 2;
  if (!this->_internal_fullpath().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_fullpath().data(), static_cast<int>(this->_internal_fullpath().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "kservice.KFileInfo.fullPath");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_fullpath(), target);
  }

  // string hash32 = 3;
  if (!this->_internal_hash32().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_hash32().data(), static_cast<int>(this->_internal_hash32().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "kservice.KFileInfo.hash32");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_hash32(), target);
  }

  // string torrentHash = 4;
  if (!this->_internal_torrenthash().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_torrenthash().data(), static_cast<int>(this->_internal_torrenthash().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "kservice.KFileInfo.torrentHash");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_torrenthash(), target);
  }

  // string url = 5;
  if (!this->_internal_url().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_url().data(), static_cast<int>(this->_internal_url().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "kservice.KFileInfo.url");
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_url(), target);
  }

  // int64 durationMs = 6;
  if (this->_internal_durationms() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(6, this->_internal_durationms(), target);
  }

  // int64 fileSize = 7;
  if (this->_internal_filesize() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(7, this->_internal_filesize(), target);
  }

  // bool isLocal = 8;
  if (this->_internal_islocal() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(8, this->_internal_islocal(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:kservice.KFileInfo)
  return target;
}

size_t KFileInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:kservice.KFileInfo)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string fileName = 1;
  if (!this->_internal_filename().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_filename());
  }

  // string fullPath = 2;
  if (!this->_internal_fullpath().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_fullpath());
  }

  // string hash32 = 3;
  if (!this->_internal_hash32().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_hash32());
  }

  // string torrentHash = 4;
  if (!this->_internal_torrenthash().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_torrenthash());
  }

  // string url = 5;
  if (!this->_internal_url().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_url());
  }

  // int64 durationMs = 6;
  if (this->_internal_durationms() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_durationms());
  }

  // int64 fileSize = 7;
  if (this->_internal_filesize() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_filesize());
  }

  // bool isLocal = 8;
  if (this->_internal_islocal() != 0) {
    total_size += 1 + 1;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void KFileInfo::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const KFileInfo*>(
      &from));
}

void KFileInfo::MergeFrom(const KFileInfo& from) {
  KFileInfo* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:kservice.KFileInfo)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_filename().empty()) {
    _this->_internal_set_filename(from._internal_filename());
  }
  if (!from._internal_fullpath().empty()) {
    _this->_internal_set_fullpath(from._internal_fullpath());
  }
  if (!from._internal_hash32().empty()) {
    _this->_internal_set_hash32(from._internal_hash32());
  }
  if (!from._internal_torrenthash().empty()) {
    _this->_internal_set_torrenthash(from._internal_torrenthash());
  }
  if (!from._internal_url().empty()) {
    _this->_internal_set_url(from._internal_url());
  }
  if (from._internal_durationms() != 0) {
    _this->_internal_set_durationms(from._internal_durationms());
  }
  if (from._internal_filesize() != 0) {
    _this->_internal_set_filesize(from._internal_filesize());
  }
  if (from._internal_islocal() != 0) {
    _this->_internal_set_islocal(from._internal_islocal());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void KFileInfo::CopyFrom(const KFileInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:kservice.KFileInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool KFileInfo::IsInitialized() const {
  return true;
}

void KFileInfo::InternalSwap(KFileInfo* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.filename_, lhs_arena,
      &other->_impl_.filename_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.fullpath_, lhs_arena,
      &other->_impl_.fullpath_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.hash32_, lhs_arena,
      &other->_impl_.hash32_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.torrenthash_, lhs_arena,
      &other->_impl_.torrenthash_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.url_, lhs_arena,
      &other->_impl_.url_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(KFileInfo, _impl_.islocal_)
      + sizeof(KFileInfo::_impl_.islocal_)
      - PROTOBUF_FIELD_OFFSET(KFileInfo, _impl_.durationms_)>(
          reinterpret_cast<char*>(&_impl_.durationms_),
          reinterpret_cast<char*>(&other->_impl_.durationms_));
}

std::string KFileInfo::GetTypeName() const {
  return "kservice.KFileInfo";
}


// ===================================================================

class RecoRequest::_Internal {
 public:
  static const ::kservice::EventHeader& header(const RecoRequest* msg);
  static const ::kservice::KFileInfo& fileinfo(const RecoRequest* msg);
};

const ::kservice::EventHeader&
RecoRequest::_Internal::header(const RecoRequest* msg) {
  return *msg->_impl_.header_;
}
const ::kservice::KFileInfo&
RecoRequest::_Internal::fileinfo(const RecoRequest* msg) {
  return *msg->_impl_.fileinfo_;
}
RecoRequest::RecoRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:kservice.RecoRequest)
}
RecoRequest::RecoRequest(const RecoRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  RecoRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.header_){nullptr}
    , decltype(_impl_.fileinfo_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_header()) {
    _this->_impl_.header_ = new ::kservice::EventHeader(*from._impl_.header_);
  }
  if (from._internal_has_fileinfo()) {
    _this->_impl_.fileinfo_ = new ::kservice::KFileInfo(*from._impl_.fileinfo_);
  }
  // @@protoc_insertion_point(copy_constructor:kservice.RecoRequest)
}

inline void RecoRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.header_){nullptr}
    , decltype(_impl_.fileinfo_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

RecoRequest::~RecoRequest() {
  // @@protoc_insertion_point(destructor:kservice.RecoRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void RecoRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.header_;
  if (this != internal_default_instance()) delete _impl_.fileinfo_;
}

void RecoRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void RecoRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:kservice.RecoRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.header_ != nullptr) {
    delete _impl_.header_;
  }
  _impl_.header_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.fileinfo_ != nullptr) {
    delete _impl_.fileinfo_;
  }
  _impl_.fileinfo_ = nullptr;
  _internal_metadata_.Clear<std::string>();
}

const char* RecoRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .kservice.EventHeader header = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_header(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .kservice.KFileInfo fileInfo = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_fileinfo(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* RecoRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:kservice.RecoRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .kservice.EventHeader header = 1;
  if (this->_internal_has_header()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::header(this),
        _Internal::header(this).GetCachedSize(), target, stream);
  }

  // .kservice.KFileInfo fileInfo = 2;
  if (this->_internal_has_fileinfo()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::fileinfo(this),
        _Internal::fileinfo(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:kservice.RecoRequest)
  return target;
}

size_t RecoRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:kservice.RecoRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .kservice.EventHeader header = 1;
  if (this->_internal_has_header()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.header_);
  }

  // .kservice.KFileInfo fileInfo = 2;
  if (this->_internal_has_fileinfo()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.fileinfo_);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void RecoRequest::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const RecoRequest*>(
      &from));
}

void RecoRequest::MergeFrom(const RecoRequest& from) {
  RecoRequest* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:kservice.RecoRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_header()) {
    _this->_internal_mutable_header()->::kservice::EventHeader::MergeFrom(
        from._internal_header());
  }
  if (from._internal_has_fileinfo()) {
    _this->_internal_mutable_fileinfo()->::kservice::KFileInfo::MergeFrom(
        from._internal_fileinfo());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void RecoRequest::CopyFrom(const RecoRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:kservice.RecoRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RecoRequest::IsInitialized() const {
  return true;
}

void RecoRequest::InternalSwap(RecoRequest* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(RecoRequest, _impl_.fileinfo_)
      + sizeof(RecoRequest::_impl_.fileinfo_)
      - PROTOBUF_FIELD_OFFSET(RecoRequest, _impl_.header_)>(
          reinterpret_cast<char*>(&_impl_.header_),
          reinterpret_cast<char*>(&other->_impl_.header_));
}

std::string RecoRequest::GetTypeName() const {
  return "kservice.RecoRequest";
}


// ===================================================================

class DanmuSource::_Internal {
 public:
};

DanmuSource::DanmuSource(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:kservice.DanmuSource)
}
DanmuSource::DanmuSource(const DanmuSource& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  DanmuSource* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.title_){}
    , decltype(_impl_.scriptid_){}
    , decltype(_impl_.scriptdata_){}
    , decltype(_impl_.type_){}
    , decltype(_impl_.durationseconds_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.title_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.title_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_title().empty()) {
    _this->_impl_.title_.Set(from._internal_title(), 
      _this->GetArenaForAllocation());
  }
  _impl_.scriptid_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.scriptid_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_scriptid().empty()) {
    _this->_impl_.scriptid_.Set(from._internal_scriptid(), 
      _this->GetArenaForAllocation());
  }
  _impl_.scriptdata_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.scriptdata_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_scriptdata().empty()) {
    _this->_impl_.scriptdata_.Set(from._internal_scriptdata(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.type_, &from._impl_.type_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.durationseconds_) -
    reinterpret_cast<char*>(&_impl_.type_)) + sizeof(_impl_.durationseconds_));
  // @@protoc_insertion_point(copy_constructor:kservice.DanmuSource)
}

inline void DanmuSource::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.title_){}
    , decltype(_impl_.scriptid_){}
    , decltype(_impl_.scriptdata_){}
    , decltype(_impl_.type_){0}
    , decltype(_impl_.durationseconds_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.title_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.title_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.scriptid_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.scriptid_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.scriptdata_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.scriptdata_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

DanmuSource::~DanmuSource() {
  // @@protoc_insertion_point(destructor:kservice.DanmuSource)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DanmuSource::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.title_.Destroy();
  _impl_.scriptid_.Destroy();
  _impl_.scriptdata_.Destroy();
}

void DanmuSource::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void DanmuSource::Clear() {
// @@protoc_insertion_point(message_clear_start:kservice.DanmuSource)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.title_.ClearToEmpty();
  _impl_.scriptid_.ClearToEmpty();
  _impl_.scriptdata_.ClearToEmpty();
  ::memset(&_impl_.type_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.durationseconds_) -
      reinterpret_cast<char*>(&_impl_.type_)) + sizeof(_impl_.durationseconds_));
  _internal_metadata_.Clear<std::string>();
}

const char* DanmuSource::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .kservice.DanmuSourceType type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_type(static_cast<::kservice::DanmuSourceType>(val));
        } else
          goto handle_unusual;
        continue;
      // string title = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_title();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else
          goto handle_unusual;
        continue;
      // string scriptId = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_scriptid();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else
          goto handle_unusual;
        continue;
      // string scriptData = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_scriptdata();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else
          goto handle_unusual;
        continue;
      // int32 durationSeconds = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _impl_.durationseconds_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DanmuSource::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:kservice.DanmuSource)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .kservice.DanmuSourceType type = 1;
  if (this->_internal_type() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_type(), target);
  }

  // string title = 2;
  if (!this->_internal_title().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_title().data(), static_cast<int>(this->_internal_title().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "kservice.DanmuSource.title");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_title(), target);
  }

  // string scriptId = 3;
  if (!this->_internal_scriptid().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_scriptid().data(), static_cast<int>(this->_internal_scriptid().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "kservice.DanmuSource.scriptId");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_scriptid(), target);
  }

  // string scriptData = 4;
  if (!this->_internal_scriptdata().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_scriptdata().data(), static_cast<int>(this->_internal_scriptdata().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "kservice.DanmuSource.scriptData");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_scriptdata(), target);
  }

  // int32 durationSeconds = 5;
  if (this->_internal_durationseconds() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(5, this->_internal_durationseconds(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:kservice.DanmuSource)
  return target;
}

size_t DanmuSource::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:kservice.DanmuSource)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string title = 2;
  if (!this->_internal_title().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_title());
  }

  // string scriptId = 3;
  if (!this->_internal_scriptid().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_scriptid());
  }

  // string scriptData = 4;
  if (!this->_internal_scriptdata().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_scriptdata());
  }

  // .kservice.DanmuSourceType type = 1;
  if (this->_internal_type() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_type());
  }

  // int32 durationSeconds = 5;
  if (this->_internal_durationseconds() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_durationseconds());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void DanmuSource::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const DanmuSource*>(
      &from));
}

void DanmuSource::MergeFrom(const DanmuSource& from) {
  DanmuSource* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:kservice.DanmuSource)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_title().empty()) {
    _this->_internal_set_title(from._internal_title());
  }
  if (!from._internal_scriptid().empty()) {
    _this->_internal_set_scriptid(from._internal_scriptid());
  }
  if (!from._internal_scriptdata().empty()) {
    _this->_internal_set_scriptdata(from._internal_scriptdata());
  }
  if (from._internal_type() != 0) {
    _this->_internal_set_type(from._internal_type());
  }
  if (from._internal_durationseconds() != 0) {
    _this->_internal_set_durationseconds(from._internal_durationseconds());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void DanmuSource::CopyFrom(const DanmuSource& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:kservice.DanmuSource)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DanmuSource::IsInitialized() const {
  return true;
}

void DanmuSource::InternalSwap(DanmuSource* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.title_, lhs_arena,
      &other->_impl_.title_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.scriptid_, lhs_arena,
      &other->_impl_.scriptid_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.scriptdata_, lhs_arena,
      &other->_impl_.scriptdata_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(DanmuSource, _impl_.durationseconds_)
      + sizeof(DanmuSource::_impl_.durationseconds_)
      - PROTOBUF_FIELD_OFFSET(DanmuSource, _impl_.type_)>(
          reinterpret_cast<char*>(&_impl_.type_),
          reinterpret_cast<char*>(&other->_impl_.type_));
}

std::string DanmuSource::GetTypeName() const {
  return "kservice.DanmuSource";
}


// ===================================================================

class InfoSource::_Internal {
 public:
};

InfoSource::InfoSource(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:kservice.InfoSource)
}
InfoSource::InfoSource(const InfoSource& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  InfoSource* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.scriptid_){}
    , decltype(_impl_.scriptdata_){}
    , decltype(_impl_.type_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.scriptid_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.scriptid_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_scriptid().empty()) {
    _this->_impl_.scriptid_.Set(from._internal_scriptid(), 
      _this->GetArenaForAllocation());
  }
  _impl_.scriptdata_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.scriptdata_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_scriptdata().empty()) {
    _this->_impl_.scriptdata_.Set(from._internal_scriptdata(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.type_ = from._impl_.type_;
  // @@protoc_insertion_point(copy_constructor:kservice.InfoSource)
}

inline void InfoSource::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.scriptid_){}
    , decltype(_impl_.scriptdata_){}
    , decltype(_impl_.type_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.scriptid_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.scriptid_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.scriptdata_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.scriptdata_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

InfoSource::~InfoSource() {
  // @@protoc_insertion_point(destructor:kservice.InfoSource)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void InfoSource::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.scriptid_.Destroy();
  _impl_.scriptdata_.Destroy();
}

void InfoSource::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void InfoSource::Clear() {
// @@protoc_insertion_point(message_clear_start:kservice.InfoSource)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.scriptid_.ClearToEmpty();
  _impl_.scriptdata_.ClearToEmpty();
  _impl_.type_ = 0;
  _internal_metadata_.Clear<std::string>();
}

const char* InfoSource::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .kservice.InfoSourceType type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_type(static_cast<::kservice::InfoSourceType>(val));
        } else
          goto handle_unusual;
        continue;
      // string scriptId = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_scriptid();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else
          goto handle_unusual;
        continue;
      // string scriptData = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_scriptdata();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* InfoSource::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:kservice.InfoSource)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .kservice.InfoSourceType type = 1;
  if (this->_internal_type() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_type(), target);
  }

  // string scriptId = 2;
  if (!this->_internal_scriptid().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_scriptid().data(), static_cast<int>(this->_internal_scriptid().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "kservice.InfoSource.scriptId");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_scriptid(), target);
  }

  // string scriptData = 3;
  if (!this->_internal_scriptdata().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_scriptdata().data(), static_cast<int>(this->_internal_scriptdata().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "kservice.InfoSource.scriptData");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_scriptdata(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:kservice.InfoSource)
  return target;
}

size_t InfoSource::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:kservice.InfoSource)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string scriptId = 2;
  if (!this->_internal_scriptid().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_scriptid());
  }

  // string scriptData = 3;
  if (!this->_internal_scriptdata().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_scriptdata());
  }

  // .kservice.InfoSourceType type = 1;
  if (this->_internal_type() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_type());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void InfoSource::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const InfoSource*>(
      &from));
}

void InfoSource::MergeFrom(const InfoSource& from) {
  InfoSource* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:kservice.InfoSource)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_scriptid().empty()) {
    _this->_internal_set_scriptid(from._internal_scriptid());
  }
  if (!from._internal_scriptdata().empty()) {
    _this->_internal_set_scriptdata(from._internal_scriptdata());
  }
  if (from._internal_type() != 0) {
    _this->_internal_set_type(from._internal_type());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void InfoSource::CopyFrom(const InfoSource& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:kservice.InfoSource)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool InfoSource::IsInitialized() const {
  return true;
}

void InfoSource::InternalSwap(InfoSource* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.scriptid_, lhs_arena,
      &other->_impl_.scriptid_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.scriptdata_, lhs_arena,
      &other->_impl_.scriptdata_, rhs_arena
  );
  swap(_impl_.type_, other->_impl_.type_);
}

std::string InfoSource::GetTypeName() const {
  return "kservice.InfoSource";
}


// ===================================================================

class Pool::_Internal {
 public:
};

Pool::Pool(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:kservice.Pool)
}
Pool::Pool(const Pool& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  Pool* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.name_){}
    , decltype(_impl_.epname_){}
    , decltype(_impl_.poolid_){}
    , decltype(_impl_.epindex_){}
    , decltype(_impl_.eptype_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_name().empty()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  _impl_.epname_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.epname_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_epname().empty()) {
    _this->_impl_.epname_.Set(from._internal_epname(), 
      _this->GetArenaForAllocation());
  }
  _impl_.poolid_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.poolid_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_poolid().empty()) {
    _this->_impl_.poolid_.Set(from._internal_poolid(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.epindex_, &from._impl_.epindex_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.eptype_) -
    reinterpret_cast<char*>(&_impl_.epindex_)) + sizeof(_impl_.eptype_));
  // @@protoc_insertion_point(copy_constructor:kservice.Pool)
}

inline void Pool::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.name_){}
    , decltype(_impl_.epname_){}
    , decltype(_impl_.poolid_){}
    , decltype(_impl_.epindex_){0}
    , decltype(_impl_.eptype_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.epname_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.epname_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.poolid_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.poolid_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

Pool::~Pool() {
  // @@protoc_insertion_point(destructor:kservice.Pool)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Pool::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.name_.Destroy();
  _impl_.epname_.Destroy();
  _impl_.poolid_.Destroy();
}

void Pool::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Pool::Clear() {
// @@protoc_insertion_point(message_clear_start:kservice.Pool)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.name_.ClearToEmpty();
  _impl_.epname_.ClearToEmpty();
  _impl_.poolid_.ClearToEmpty();
  ::memset(&_impl_.epindex_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.eptype_) -
      reinterpret_cast<char*>(&_impl_.epindex_)) + sizeof(_impl_.eptype_));
  _internal_metadata_.Clear<std::string>();
}

const char* Pool::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else
          goto handle_unusual;
        continue;
      // .kservice.EpType epType = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_eptype(static_cast<::kservice::EpType>(val));
        } else
          goto handle_unusual;
        continue;
      // string epName = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_epname();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else
          goto handle_unusual;
        continue;
      // double epIndex = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 33)) {
          _impl_.epindex_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // string poolid = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_poolid();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Pool::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:kservice.Pool)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string name = 1;
  if (!this->_internal_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "kservice.Pool.name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  // .kservice.EpType epType = 2;
  if (this->_internal_eptype() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      2, this->_internal_eptype(), target);
  }

  // string epName = 3;
  if (!this->_internal_epname().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_epname().data(), static_cast<int>(this->_internal_epname().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "kservice.Pool.epName");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_epname(), target);
  }

  // double epIndex = 4;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_epindex = this->_internal_epindex();
  uint64_t raw_epindex;
  memcpy(&raw_epindex, &tmp_epindex, sizeof(tmp_epindex));
  if (raw_epindex != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(4, this->_internal_epindex(), target);
  }

  // string poolid = 5;
  if (!this->_internal_poolid().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_poolid().data(), static_cast<int>(this->_internal_poolid().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "kservice.Pool.poolid");
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_poolid(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:kservice.Pool)
  return target;
}

size_t Pool::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:kservice.Pool)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string name = 1;
  if (!this->_internal_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }

  // string epName = 3;
  if (!this->_internal_epname().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_epname());
  }

  // string poolid = 5;
  if (!this->_internal_poolid().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_poolid());
  }

  // double epIndex = 4;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_epindex = this->_internal_epindex();
  uint64_t raw_epindex;
  memcpy(&raw_epindex, &tmp_epindex, sizeof(tmp_epindex));
  if (raw_epindex != 0) {
    total_size += 1 + 8;
  }

  // .kservice.EpType epType = 2;
  if (this->_internal_eptype() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_eptype());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Pool::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const Pool*>(
      &from));
}

void Pool::MergeFrom(const Pool& from) {
  Pool* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:kservice.Pool)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_name().empty()) {
    _this->_internal_set_name(from._internal_name());
  }
  if (!from._internal_epname().empty()) {
    _this->_internal_set_epname(from._internal_epname());
  }
  if (!from._internal_poolid().empty()) {
    _this->_internal_set_poolid(from._internal_poolid());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_epindex = from._internal_epindex();
  uint64_t raw_epindex;
  memcpy(&raw_epindex, &tmp_epindex, sizeof(tmp_epindex));
  if (raw_epindex != 0) {
    _this->_internal_set_epindex(from._internal_epindex());
  }
  if (from._internal_eptype() != 0) {
    _this->_internal_set_eptype(from._internal_eptype());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Pool::CopyFrom(const Pool& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:kservice.Pool)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Pool::IsInitialized() const {
  return true;
}

void Pool::InternalSwap(Pool* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.epname_, lhs_arena,
      &other->_impl_.epname_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.poolid_, lhs_arena,
      &other->_impl_.poolid_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Pool, _impl_.eptype_)
      + sizeof(Pool::_impl_.eptype_)
      - PROTOBUF_FIELD_OFFSET(Pool, _impl_.epindex_)>(
          reinterpret_cast<char*>(&_impl_.epindex_),
          reinterpret_cast<char*>(&other->_impl_.epindex_));
}

std::string Pool::GetTypeName() const {
  return "kservice.Pool";
}


// ===================================================================

class RecoResponse::_Internal {
 public:
  static const ::kservice::ResponseHeader& header(const RecoResponse* msg);
  static const ::kservice::Pool& matchresult(const RecoResponse* msg);
};

const ::kservice::ResponseHeader&
RecoResponse::_Internal::header(const RecoResponse* msg) {
  return *msg->_impl_.header_;
}
const ::kservice::Pool&
RecoResponse::_Internal::matchresult(const RecoResponse* msg) {
  return *msg->_impl_.matchresult_;
}
RecoResponse::RecoResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:kservice.RecoResponse)
}
RecoResponse::RecoResponse(const RecoResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  RecoResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.infosources_){from._impl_.infosources_}
    , decltype(_impl_.danmusources_){from._impl_.danmusources_}
    , decltype(_impl_.header_){nullptr}
    , decltype(_impl_.matchresult_){nullptr}
    , decltype(_impl_.recoby_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_header()) {
    _this->_impl_.header_ = new ::kservice::ResponseHeader(*from._impl_.header_);
  }
  if (from._internal_has_matchresult()) {
    _this->_impl_.matchresult_ = new ::kservice::Pool(*from._impl_.matchresult_);
  }
  _this->_impl_.recoby_ = from._impl_.recoby_;
  // @@protoc_insertion_point(copy_constructor:kservice.RecoResponse)
}

inline void RecoResponse::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.infosources_){arena}
    , decltype(_impl_.danmusources_){arena}
    , decltype(_impl_.header_){nullptr}
    , decltype(_impl_.matchresult_){nullptr}
    , decltype(_impl_.recoby_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

RecoResponse::~RecoResponse() {
  // @@protoc_insertion_point(destructor:kservice.RecoResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void RecoResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.infosources_.~RepeatedPtrField();
  _impl_.danmusources_.~RepeatedPtrField();
  if (this != internal_default_instance()) delete _impl_.header_;
  if (this != internal_default_instance()) delete _impl_.matchresult_;
}

void RecoResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void RecoResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:kservice.RecoResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.infosources_.Clear();
  _impl_.danmusources_.Clear();
  if (GetArenaForAllocation() == nullptr && _impl_.header_ != nullptr) {
    delete _impl_.header_;
  }
  _impl_.header_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.matchresult_ != nullptr) {
    delete _impl_.matchresult_;
  }
  _impl_.matchresult_ = nullptr;
  _impl_.recoby_ = 0;
  _internal_metadata_.Clear<std::string>();
}

const char* RecoResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .kservice.ResponseHeader header = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_header(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .kservice.Pool matchResult = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_matchresult(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .kservice.InfoSource infoSources = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_infosources(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .kservice.DanmuSource danmuSources = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_danmusources(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
        } else
          goto handle_unusual;
        continue;
      // .kservice.RecoBy recoBy = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_recoby(static_cast<::kservice::RecoBy>(val));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* RecoResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:kservice.RecoResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .kservice.ResponseHeader header = 1;
  if (this->_internal_has_header()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::header(this),
        _Internal::header(this).GetCachedSize(), target, stream);
  }

  // .kservice.Pool matchResult = 2;
  if (this->_internal_has_matchresult()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::matchresult(this),
        _Internal::matchresult(this).GetCachedSize(), target, stream);
  }

  // repeated .kservice.InfoSource infoSources = 3;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_infosources_size()); i < n; i++) {
    const auto& repfield = this->_internal_infosources(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .kservice.DanmuSource danmuSources = 4;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_danmusources_size()); i < n; i++) {
    const auto& repfield = this->_internal_danmusources(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(4, repfield, repfield.GetCachedSize(), target, stream);
  }

  // .kservice.RecoBy recoBy = 5;
  if (this->_internal_recoby() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      5, this->_internal_recoby(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:kservice.RecoResponse)
  return target;
}

size_t RecoResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:kservice.RecoResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .kservice.InfoSource infoSources = 3;
  total_size += 1UL * this->_internal_infosources_size();
  for (const auto& msg : this->_impl_.infosources_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .kservice.DanmuSource danmuSources = 4;
  total_size += 1UL * this->_internal_danmusources_size();
  for (const auto& msg : this->_impl_.danmusources_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // .kservice.ResponseHeader header = 1;
  if (this->_internal_has_header()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.header_);
  }

  // .kservice.Pool matchResult = 2;
  if (this->_internal_has_matchresult()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.matchresult_);
  }

  // .kservice.RecoBy recoBy = 5;
  if (this->_internal_recoby() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_recoby());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void RecoResponse::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const RecoResponse*>(
      &from));
}

void RecoResponse::MergeFrom(const RecoResponse& from) {
  RecoResponse* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:kservice.RecoResponse)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.infosources_.MergeFrom(from._impl_.infosources_);
  _this->_impl_.danmusources_.MergeFrom(from._impl_.danmusources_);
  if (from._internal_has_header()) {
    _this->_internal_mutable_header()->::kservice::ResponseHeader::MergeFrom(
        from._internal_header());
  }
  if (from._internal_has_matchresult()) {
    _this->_internal_mutable_matchresult()->::kservice::Pool::MergeFrom(
        from._internal_matchresult());
  }
  if (from._internal_recoby() != 0) {
    _this->_internal_set_recoby(from._internal_recoby());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void RecoResponse::CopyFrom(const RecoResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:kservice.RecoResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RecoResponse::IsInitialized() const {
  return true;
}

void RecoResponse::InternalSwap(RecoResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.infosources_.InternalSwap(&other->_impl_.infosources_);
  _impl_.danmusources_.InternalSwap(&other->_impl_.danmusources_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(RecoResponse, _impl_.recoby_)
      + sizeof(RecoResponse::_impl_.recoby_)
      - PROTOBUF_FIELD_OFFSET(RecoResponse, _impl_.header_)>(
          reinterpret_cast<char*>(&_impl_.header_),
          reinterpret_cast<char*>(&other->_impl_.header_));
}

std::string RecoResponse::GetTypeName() const {
  return "kservice.RecoResponse";
}


// ===================================================================

class MatchEvent_Match::_Internal {
 public:
  static const ::kservice::KFileInfo& fileinfo(const MatchEvent_Match* msg);
  static const ::kservice::Pool& poolinfo(const MatchEvent_Match* msg);
};

const ::kservice::KFileInfo&
MatchEvent_Match::_Internal::fileinfo(const MatchEvent_Match* msg) {
  return *msg->_impl_.fileinfo_;
}
const ::kservice::Pool&
MatchEvent_Match::_Internal::poolinfo(const MatchEvent_Match* msg) {
  return *msg->_impl_.poolinfo_;
}
MatchEvent_Match::MatchEvent_Match(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:kservice.MatchEvent.Match)
}
MatchEvent_Match::MatchEvent_Match(const MatchEvent_Match& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  MatchEvent_Match* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.infosources_){from._impl_.infosources_}
    , decltype(_impl_.fileinfo_){nullptr}
    , decltype(_impl_.poolinfo_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_fileinfo()) {
    _this->_impl_.fileinfo_ = new ::kservice::KFileInfo(*from._impl_.fileinfo_);
  }
  if (from._internal_has_poolinfo()) {
    _this->_impl_.poolinfo_ = new ::kservice::Pool(*from._impl_.poolinfo_);
  }
  // @@protoc_insertion_point(copy_constructor:kservice.MatchEvent.Match)
}

inline void MatchEvent_Match::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.infosources_){arena}
    , decltype(_impl_.fileinfo_){nullptr}
    , decltype(_impl_.poolinfo_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

MatchEvent_Match::~MatchEvent_Match() {
  // @@protoc_insertion_point(destructor:kservice.MatchEvent.Match)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void MatchEvent_Match::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.infosources_.~RepeatedPtrField();
  if (this != internal_default_instance()) delete _impl_.fileinfo_;
  if (this != internal_default_instance()) delete _impl_.poolinfo_;
}

void MatchEvent_Match::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void MatchEvent_Match::Clear() {
// @@protoc_insertion_point(message_clear_start:kservice.MatchEvent.Match)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.infosources_.Clear();
  if (GetArenaForAllocation() == nullptr && _impl_.fileinfo_ != nullptr) {
    delete _impl_.fileinfo_;
  }
  _impl_.fileinfo_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.poolinfo_ != nullptr) {
    delete _impl_.poolinfo_;
  }
  _impl_.poolinfo_ = nullptr;
  _internal_metadata_.Clear<std::string>();
}

const char* MatchEvent_Match::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .kservice.KFileInfo fileInfo = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_fileinfo(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .kservice.Pool poolInfo = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_poolinfo(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .kservice.InfoSource infoSources = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_infosources(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* MatchEvent_Match::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:kservice.MatchEvent.Match)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .kservice.KFileInfo fileInfo = 1;
  if (this->_internal_has_fileinfo()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::fileinfo(this),
        _Internal::fileinfo(this).GetCachedSize(), target, stream);
  }

  // .kservice.Pool poolInfo = 2;
  if (this->_internal_has_poolinfo()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::poolinfo(this),
        _Internal::poolinfo(this).GetCachedSize(), target, stream);
  }

  // repeated .kservice.InfoSource infoSources = 3;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_infosources_size()); i < n; i++) {
    const auto& repfield = this->_internal_infosources(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:kservice.MatchEvent.Match)
  return target;
}

size_t MatchEvent_Match::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:kservice.MatchEvent.Match)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .kservice.InfoSource infoSources = 3;
  total_size += 1UL * this->_internal_infosources_size();
  for (const auto& msg : this->_impl_.infosources_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // .kservice.KFileInfo fileInfo = 1;
  if (this->_internal_has_fileinfo()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.fileinfo_);
  }

  // .kservice.Pool poolInfo = 2;
  if (this->_internal_has_poolinfo()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.poolinfo_);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void MatchEvent_Match::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const MatchEvent_Match*>(
      &from));
}

void MatchEvent_Match::MergeFrom(const MatchEvent_Match& from) {
  MatchEvent_Match* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:kservice.MatchEvent.Match)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.infosources_.MergeFrom(from._impl_.infosources_);
  if (from._internal_has_fileinfo()) {
    _this->_internal_mutable_fileinfo()->::kservice::KFileInfo::MergeFrom(
        from._internal_fileinfo());
  }
  if (from._internal_has_poolinfo()) {
    _this->_internal_mutable_poolinfo()->::kservice::Pool::MergeFrom(
        from._internal_poolinfo());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void MatchEvent_Match::CopyFrom(const MatchEvent_Match& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:kservice.MatchEvent.Match)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MatchEvent_Match::IsInitialized() const {
  return true;
}

void MatchEvent_Match::InternalSwap(MatchEvent_Match* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.infosources_.InternalSwap(&other->_impl_.infosources_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(MatchEvent_Match, _impl_.poolinfo_)
      + sizeof(MatchEvent_Match::_impl_.poolinfo_)
      - PROTOBUF_FIELD_OFFSET(MatchEvent_Match, _impl_.fileinfo_)>(
          reinterpret_cast<char*>(&_impl_.fileinfo_),
          reinterpret_cast<char*>(&other->_impl_.fileinfo_));
}

std::string MatchEvent_Match::GetTypeName() const {
  return "kservice.MatchEvent.Match";
}


// ===================================================================

class MatchEvent::_Internal {
 public:
  static const ::kservice::EventHeader& header(const MatchEvent* msg);
};

const ::kservice::EventHeader&
MatchEvent::_Internal::header(const MatchEvent* msg) {
  return *msg->_impl_.header_;
}
MatchEvent::MatchEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:kservice.MatchEvent)
}
MatchEvent::MatchEvent(const MatchEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  MatchEvent* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.matches_){from._impl_.matches_}
    , decltype(_impl_.header_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_header()) {
    _this->_impl_.header_ = new ::kservice::EventHeader(*from._impl_.header_);
  }
  // @@protoc_insertion_point(copy_constructor:kservice.MatchEvent)
}

inline void MatchEvent::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.matches_){arena}
    , decltype(_impl_.header_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

MatchEvent::~MatchEvent() {
  // @@protoc_insertion_point(destructor:kservice.MatchEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void MatchEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.matches_.~RepeatedPtrField();
  if (this != internal_default_instance()) delete _impl_.header_;
}

void MatchEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void MatchEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:kservice.MatchEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.matches_.Clear();
  if (GetArenaForAllocation() == nullptr && _impl_.header_ != nullptr) {
    delete _impl_.header_;
  }
  _impl_.header_ = nullptr;
  _internal_metadata_.Clear<std::string>();
}

const char* MatchEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .kservice.EventHeader header = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_header(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .kservice.MatchEvent.Match matches = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_matches(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* MatchEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:kservice.MatchEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .kservice.EventHeader header = 1;
  if (this->_internal_has_header()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::header(this),
        _Internal::header(this).GetCachedSize(), target, stream);
  }

  // repeated .kservice.MatchEvent.Match matches = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_matches_size()); i < n; i++) {
    const auto& repfield = this->_internal_matches(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:kservice.MatchEvent)
  return target;
}

size_t MatchEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:kservice.MatchEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .kservice.MatchEvent.Match matches = 2;
  total_size += 1UL * this->_internal_matches_size();
  for (const auto& msg : this->_impl_.matches_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // .kservice.EventHeader header = 1;
  if (this->_internal_has_header()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.header_);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void MatchEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const MatchEvent*>(
      &from));
}

void MatchEvent::MergeFrom(const MatchEvent& from) {
  MatchEvent* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:kservice.MatchEvent)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.matches_.MergeFrom(from._impl_.matches_);
  if (from._internal_has_header()) {
    _this->_internal_mutable_header()->::kservice::EventHeader::MergeFrom(
        from._internal_header());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void MatchEvent::CopyFrom(const MatchEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:kservice.MatchEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MatchEvent::IsInitialized() const {
  return true;
}

void MatchEvent::InternalSwap(MatchEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.matches_.InternalSwap(&other->_impl_.matches_);
  swap(_impl_.header_, other->_impl_.header_);
}

std::string MatchEvent::GetTypeName() const {
  return "kservice.MatchEvent";
}


// ===================================================================

class AddDanmuSourceEvent_DanmuPoolSource::_Internal {
 public:
  static const ::kservice::Pool& poolinfo(const AddDanmuSourceEvent_DanmuPoolSource* msg);
  static const ::kservice::KFileInfo& fileinfo(const AddDanmuSourceEvent_DanmuPoolSource* msg);
};

const ::kservice::Pool&
AddDanmuSourceEvent_DanmuPoolSource::_Internal::poolinfo(const AddDanmuSourceEvent_DanmuPoolSource* msg) {
  return *msg->_impl_.poolinfo_;
}
const ::kservice::KFileInfo&
AddDanmuSourceEvent_DanmuPoolSource::_Internal::fileinfo(const AddDanmuSourceEvent_DanmuPoolSource* msg) {
  return *msg->_impl_.fileinfo_;
}
AddDanmuSourceEvent_DanmuPoolSource::AddDanmuSourceEvent_DanmuPoolSource(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:kservice.AddDanmuSourceEvent.DanmuPoolSource)
}
AddDanmuSourceEvent_DanmuPoolSource::AddDanmuSourceEvent_DanmuPoolSource(const AddDanmuSourceEvent_DanmuPoolSource& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  AddDanmuSourceEvent_DanmuPoolSource* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.danmusources_){from._impl_.danmusources_}
    , decltype(_impl_.infosources_){from._impl_.infosources_}
    , decltype(_impl_.poolinfo_){nullptr}
    , decltype(_impl_.fileinfo_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_poolinfo()) {
    _this->_impl_.poolinfo_ = new ::kservice::Pool(*from._impl_.poolinfo_);
  }
  if (from._internal_has_fileinfo()) {
    _this->_impl_.fileinfo_ = new ::kservice::KFileInfo(*from._impl_.fileinfo_);
  }
  // @@protoc_insertion_point(copy_constructor:kservice.AddDanmuSourceEvent.DanmuPoolSource)
}

inline void AddDanmuSourceEvent_DanmuPoolSource::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.danmusources_){arena}
    , decltype(_impl_.infosources_){arena}
    , decltype(_impl_.poolinfo_){nullptr}
    , decltype(_impl_.fileinfo_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

AddDanmuSourceEvent_DanmuPoolSource::~AddDanmuSourceEvent_DanmuPoolSource() {
  // @@protoc_insertion_point(destructor:kservice.AddDanmuSourceEvent.DanmuPoolSource)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void AddDanmuSourceEvent_DanmuPoolSource::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.danmusources_.~RepeatedPtrField();
  _impl_.infosources_.~RepeatedPtrField();
  if (this != internal_default_instance()) delete _impl_.poolinfo_;
  if (this != internal_default_instance()) delete _impl_.fileinfo_;
}

void AddDanmuSourceEvent_DanmuPoolSource::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void AddDanmuSourceEvent_DanmuPoolSource::Clear() {
// @@protoc_insertion_point(message_clear_start:kservice.AddDanmuSourceEvent.DanmuPoolSource)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.danmusources_.Clear();
  _impl_.infosources_.Clear();
  if (GetArenaForAllocation() == nullptr && _impl_.poolinfo_ != nullptr) {
    delete _impl_.poolinfo_;
  }
  _impl_.poolinfo_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.fileinfo_ != nullptr) {
    delete _impl_.fileinfo_;
  }
  _impl_.fileinfo_ = nullptr;
  _internal_metadata_.Clear<std::string>();
}

const char* AddDanmuSourceEvent_DanmuPoolSource::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .kservice.Pool poolInfo = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_poolinfo(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .kservice.DanmuSource danmuSources = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_danmusources(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      // .kservice.KFileInfo fileInfo = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_fileinfo(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .kservice.InfoSource infoSources = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_infosources(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* AddDanmuSourceEvent_DanmuPoolSource::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:kservice.AddDanmuSourceEvent.DanmuPoolSource)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .kservice.Pool poolInfo = 1;
  if (this->_internal_has_poolinfo()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::poolinfo(this),
        _Internal::poolinfo(this).GetCachedSize(), target, stream);
  }

  // repeated .kservice.DanmuSource danmuSources = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_danmusources_size()); i < n; i++) {
    const auto& repfield = this->_internal_danmusources(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  // .kservice.KFileInfo fileInfo = 3;
  if (this->_internal_has_fileinfo()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::fileinfo(this),
        _Internal::fileinfo(this).GetCachedSize(), target, stream);
  }

  // repeated .kservice.InfoSource infoSources = 4;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_infosources_size()); i < n; i++) {
    const auto& repfield = this->_internal_infosources(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(4, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:kservice.AddDanmuSourceEvent.DanmuPoolSource)
  return target;
}

size_t AddDanmuSourceEvent_DanmuPoolSource::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:kservice.AddDanmuSourceEvent.DanmuPoolSource)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .kservice.DanmuSource danmuSources = 2;
  total_size += 1UL * this->_internal_danmusources_size();
  for (const auto& msg : this->_impl_.danmusources_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .kservice.InfoSource infoSources = 4;
  total_size += 1UL * this->_internal_infosources_size();
  for (const auto& msg : this->_impl_.infosources_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // .kservice.Pool poolInfo = 1;
  if (this->_internal_has_poolinfo()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.poolinfo_);
  }

  // .kservice.KFileInfo fileInfo = 3;
  if (this->_internal_has_fileinfo()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.fileinfo_);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void AddDanmuSourceEvent_DanmuPoolSource::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const AddDanmuSourceEvent_DanmuPoolSource*>(
      &from));
}

void AddDanmuSourceEvent_DanmuPoolSource::MergeFrom(const AddDanmuSourceEvent_DanmuPoolSource& from) {
  AddDanmuSourceEvent_DanmuPoolSource* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:kservice.AddDanmuSourceEvent.DanmuPoolSource)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.danmusources_.MergeFrom(from._impl_.danmusources_);
  _this->_impl_.infosources_.MergeFrom(from._impl_.infosources_);
  if (from._internal_has_poolinfo()) {
    _this->_internal_mutable_poolinfo()->::kservice::Pool::MergeFrom(
        from._internal_poolinfo());
  }
  if (from._internal_has_fileinfo()) {
    _this->_internal_mutable_fileinfo()->::kservice::KFileInfo::MergeFrom(
        from._internal_fileinfo());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void AddDanmuSourceEvent_DanmuPoolSource::CopyFrom(const AddDanmuSourceEvent_DanmuPoolSource& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:kservice.AddDanmuSourceEvent.DanmuPoolSource)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AddDanmuSourceEvent_DanmuPoolSource::IsInitialized() const {
  return true;
}

void AddDanmuSourceEvent_DanmuPoolSource::InternalSwap(AddDanmuSourceEvent_DanmuPoolSource* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.danmusources_.InternalSwap(&other->_impl_.danmusources_);
  _impl_.infosources_.InternalSwap(&other->_impl_.infosources_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(AddDanmuSourceEvent_DanmuPoolSource, _impl_.fileinfo_)
      + sizeof(AddDanmuSourceEvent_DanmuPoolSource::_impl_.fileinfo_)
      - PROTOBUF_FIELD_OFFSET(AddDanmuSourceEvent_DanmuPoolSource, _impl_.poolinfo_)>(
          reinterpret_cast<char*>(&_impl_.poolinfo_),
          reinterpret_cast<char*>(&other->_impl_.poolinfo_));
}

std::string AddDanmuSourceEvent_DanmuPoolSource::GetTypeName() const {
  return "kservice.AddDanmuSourceEvent.DanmuPoolSource";
}


// ===================================================================

class AddDanmuSourceEvent::_Internal {
 public:
  static const ::kservice::EventHeader& header(const AddDanmuSourceEvent* msg);
};

const ::kservice::EventHeader&
AddDanmuSourceEvent::_Internal::header(const AddDanmuSourceEvent* msg) {
  return *msg->_impl_.header_;
}
AddDanmuSourceEvent::AddDanmuSourceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:kservice.AddDanmuSourceEvent)
}
AddDanmuSourceEvent::AddDanmuSourceEvent(const AddDanmuSourceEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  AddDanmuSourceEvent* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.danmupoolsources_){from._impl_.danmupoolsources_}
    , decltype(_impl_.header_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_header()) {
    _this->_impl_.header_ = new ::kservice::EventHeader(*from._impl_.header_);
  }
  // @@protoc_insertion_point(copy_constructor:kservice.AddDanmuSourceEvent)
}

inline void AddDanmuSourceEvent::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.danmupoolsources_){arena}
    , decltype(_impl_.header_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

AddDanmuSourceEvent::~AddDanmuSourceEvent() {
  // @@protoc_insertion_point(destructor:kservice.AddDanmuSourceEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void AddDanmuSourceEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.danmupoolsources_.~RepeatedPtrField();
  if (this != internal_default_instance()) delete _impl_.header_;
}

void AddDanmuSourceEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void AddDanmuSourceEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:kservice.AddDanmuSourceEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.danmupoolsources_.Clear();
  if (GetArenaForAllocation() == nullptr && _impl_.header_ != nullptr) {
    delete _impl_.header_;
  }
  _impl_.header_ = nullptr;
  _internal_metadata_.Clear<std::string>();
}

const char* AddDanmuSourceEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .kservice.EventHeader header = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_header(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .kservice.AddDanmuSourceEvent.DanmuPoolSource danmuPoolSources = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_danmupoolsources(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* AddDanmuSourceEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:kservice.AddDanmuSourceEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .kservice.EventHeader header = 1;
  if (this->_internal_has_header()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::header(this),
        _Internal::header(this).GetCachedSize(), target, stream);
  }

  // repeated .kservice.AddDanmuSourceEvent.DanmuPoolSource danmuPoolSources = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_danmupoolsources_size()); i < n; i++) {
    const auto& repfield = this->_internal_danmupoolsources(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:kservice.AddDanmuSourceEvent)
  return target;
}

size_t AddDanmuSourceEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:kservice.AddDanmuSourceEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .kservice.AddDanmuSourceEvent.DanmuPoolSource danmuPoolSources = 2;
  total_size += 1UL * this->_internal_danmupoolsources_size();
  for (const auto& msg : this->_impl_.danmupoolsources_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // .kservice.EventHeader header = 1;
  if (this->_internal_has_header()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.header_);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void AddDanmuSourceEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const AddDanmuSourceEvent*>(
      &from));
}

void AddDanmuSourceEvent::MergeFrom(const AddDanmuSourceEvent& from) {
  AddDanmuSourceEvent* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:kservice.AddDanmuSourceEvent)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.danmupoolsources_.MergeFrom(from._impl_.danmupoolsources_);
  if (from._internal_has_header()) {
    _this->_internal_mutable_header()->::kservice::EventHeader::MergeFrom(
        from._internal_header());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void AddDanmuSourceEvent::CopyFrom(const AddDanmuSourceEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:kservice.AddDanmuSourceEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AddDanmuSourceEvent::IsInitialized() const {
  return true;
}

void AddDanmuSourceEvent::InternalSwap(AddDanmuSourceEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.danmupoolsources_.InternalSwap(&other->_impl_.danmupoolsources_);
  swap(_impl_.header_, other->_impl_.header_);
}

std::string AddDanmuSourceEvent::GetTypeName() const {
  return "kservice.AddDanmuSourceEvent";
}


// ===================================================================

class DanmuComment::_Internal {
 public:
};

DanmuComment::DanmuComment(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:kservice.DanmuComment)
}
DanmuComment::DanmuComment(const DanmuComment& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  DanmuComment* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.senderid_){}
    , decltype(_impl_.text_){}
    , decltype(_impl_.color_){}
    , decltype(_impl_.time_){}
    , decltype(_impl_.mode_){}
    , decltype(_impl_.size_){}
    , decltype(_impl_.timestamp_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.senderid_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.senderid_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_senderid().empty()) {
    _this->_impl_.senderid_.Set(from._internal_senderid(), 
      _this->GetArenaForAllocation());
  }
  _impl_.text_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.text_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_text().empty()) {
    _this->_impl_.text_.Set(from._internal_text(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.color_, &from._impl_.color_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.timestamp_) -
    reinterpret_cast<char*>(&_impl_.color_)) + sizeof(_impl_.timestamp_));
  // @@protoc_insertion_point(copy_constructor:kservice.DanmuComment)
}

inline void DanmuComment::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.senderid_){}
    , decltype(_impl_.text_){}
    , decltype(_impl_.color_){0}
    , decltype(_impl_.time_){0}
    , decltype(_impl_.mode_){0}
    , decltype(_impl_.size_){0}
    , decltype(_impl_.timestamp_){int64_t{0}}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.senderid_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.senderid_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.text_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.text_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

DanmuComment::~DanmuComment() {
  // @@protoc_insertion_point(destructor:kservice.DanmuComment)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DanmuComment::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.senderid_.Destroy();
  _impl_.text_.Destroy();
}

void DanmuComment::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void DanmuComment::Clear() {
// @@protoc_insertion_point(message_clear_start:kservice.DanmuComment)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.senderid_.ClearToEmpty();
  _impl_.text_.ClearToEmpty();
  ::memset(&_impl_.color_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.timestamp_) -
      reinterpret_cast<char*>(&_impl_.color_)) + sizeof(_impl_.timestamp_));
  _internal_metadata_.Clear<std::string>();
}

const char* DanmuComment::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string senderId = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_senderid();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else
          goto handle_unusual;
        continue;
      // string text = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_text();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else
          goto handle_unusual;
        continue;
      // int32 color = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _impl_.color_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 time = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _impl_.time_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 mode = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _impl_.mode_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 size = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _impl_.size_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int64 timestamp = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _impl_.timestamp_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DanmuComment::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:kservice.DanmuComment)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string senderId = 1;
  if (!this->_internal_senderid().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_senderid().data(), static_cast<int>(this->_internal_senderid().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "kservice.DanmuComment.senderId");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_senderid(), target);
  }

  // string text = 2;
  if (!this->_internal_text().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_text().data(), static_cast<int>(this->_internal_text().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "kservice.DanmuComment.text");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_text(), target);
  }

  // int32 color = 3;
  if (this->_internal_color() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_color(), target);
  }

  // int32 time = 4;
  if (this->_internal_time() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(4, this->_internal_time(), target);
  }

  // int32 mode = 5;
  if (this->_internal_mode() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(5, this->_internal_mode(), target);
  }

  // int32 size = 6;
  if (this->_internal_size() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(6, this->_internal_size(), target);
  }

  // int64 timestamp = 7;
  if (this->_internal_timestamp() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(7, this->_internal_timestamp(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:kservice.DanmuComment)
  return target;
}

size_t DanmuComment::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:kservice.DanmuComment)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string senderId = 1;
  if (!this->_internal_senderid().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_senderid());
  }

  // string text = 2;
  if (!this->_internal_text().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_text());
  }

  // int32 color = 3;
  if (this->_internal_color() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_color());
  }

  // int32 time = 4;
  if (this->_internal_time() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_time());
  }

  // int32 mode = 5;
  if (this->_internal_mode() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_mode());
  }

  // int32 size = 6;
  if (this->_internal_size() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_size());
  }

  // int64 timestamp = 7;
  if (this->_internal_timestamp() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_timestamp());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void DanmuComment::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const DanmuComment*>(
      &from));
}

void DanmuComment::MergeFrom(const DanmuComment& from) {
  DanmuComment* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:kservice.DanmuComment)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_senderid().empty()) {
    _this->_internal_set_senderid(from._internal_senderid());
  }
  if (!from._internal_text().empty()) {
    _this->_internal_set_text(from._internal_text());
  }
  if (from._internal_color() != 0) {
    _this->_internal_set_color(from._internal_color());
  }
  if (from._internal_time() != 0) {
    _this->_internal_set_time(from._internal_time());
  }
  if (from._internal_mode() != 0) {
    _this->_internal_set_mode(from._internal_mode());
  }
  if (from._internal_size() != 0) {
    _this->_internal_set_size(from._internal_size());
  }
  if (from._internal_timestamp() != 0) {
    _this->_internal_set_timestamp(from._internal_timestamp());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void DanmuComment::CopyFrom(const DanmuComment& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:kservice.DanmuComment)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DanmuComment::IsInitialized() const {
  return true;
}

void DanmuComment::InternalSwap(DanmuComment* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.senderid_, lhs_arena,
      &other->_impl_.senderid_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.text_, lhs_arena,
      &other->_impl_.text_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(DanmuComment, _impl_.timestamp_)
      + sizeof(DanmuComment::_impl_.timestamp_)
      - PROTOBUF_FIELD_OFFSET(DanmuComment, _impl_.color_)>(
          reinterpret_cast<char*>(&_impl_.color_),
          reinterpret_cast<char*>(&other->_impl_.color_));
}

std::string DanmuComment::GetTypeName() const {
  return "kservice.DanmuComment";
}


// ===================================================================

class LaunchRequest::_Internal {
 public:
  static const ::kservice::EventHeader& header(const LaunchRequest* msg);
  static const ::kservice::Pool& poolinfo(const LaunchRequest* msg);
  static const ::kservice::KFileInfo& fileinfo(const LaunchRequest* msg);
  static const ::kservice::DanmuComment& comment(const LaunchRequest* msg);
};

const ::kservice::EventHeader&
LaunchRequest::_Internal::header(const LaunchRequest* msg) {
  return *msg->_impl_.header_;
}
const ::kservice::Pool&
LaunchRequest::_Internal::poolinfo(const LaunchRequest* msg) {
  return *msg->_impl_.poolinfo_;
}
const ::kservice::KFileInfo&
LaunchRequest::_Internal::fileinfo(const LaunchRequest* msg) {
  return *msg->_impl_.fileinfo_;
}
const ::kservice::DanmuComment&
LaunchRequest::_Internal::comment(const LaunchRequest* msg) {
  return *msg->_impl_.comment_;
}
LaunchRequest::LaunchRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:kservice.LaunchRequest)
}
LaunchRequest::LaunchRequest(const LaunchRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  LaunchRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.header_){nullptr}
    , decltype(_impl_.poolinfo_){nullptr}
    , decltype(_impl_.fileinfo_){nullptr}
    , decltype(_impl_.comment_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_header()) {
    _this->_impl_.header_ = new ::kservice::EventHeader(*from._impl_.header_);
  }
  if (from._internal_has_poolinfo()) {
    _this->_impl_.poolinfo_ = new ::kservice::Pool(*from._impl_.poolinfo_);
  }
  if (from._internal_has_fileinfo()) {
    _this->_impl_.fileinfo_ = new ::kservice::KFileInfo(*from._impl_.fileinfo_);
  }
  if (from._internal_has_comment()) {
    _this->_impl_.comment_ = new ::kservice::DanmuComment(*from._impl_.comment_);
  }
  // @@protoc_insertion_point(copy_constructor:kservice.LaunchRequest)
}

inline void LaunchRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.header_){nullptr}
    , decltype(_impl_.poolinfo_){nullptr}
    , decltype(_impl_.fileinfo_){nullptr}
    , decltype(_impl_.comment_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

LaunchRequest::~LaunchRequest() {
  // @@protoc_insertion_point(destructor:kservice.LaunchRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void LaunchRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.header_;
  if (this != internal_default_instance()) delete _impl_.poolinfo_;
  if (this != internal_default_instance()) delete _impl_.fileinfo_;
  if (this != internal_default_instance()) delete _impl_.comment_;
}

void LaunchRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void LaunchRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:kservice.LaunchRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.header_ != nullptr) {
    delete _impl_.header_;
  }
  _impl_.header_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.poolinfo_ != nullptr) {
    delete _impl_.poolinfo_;
  }
  _impl_.poolinfo_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.fileinfo_ != nullptr) {
    delete _impl_.fileinfo_;
  }
  _impl_.fileinfo_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.comment_ != nullptr) {
    delete _impl_.comment_;
  }
  _impl_.comment_ = nullptr;
  _internal_metadata_.Clear<std::string>();
}

const char* LaunchRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .kservice.EventHeader header = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_header(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .kservice.Pool poolInfo = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_poolinfo(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .kservice.KFileInfo fileInfo = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_fileinfo(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .kservice.DanmuComment comment = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_comment(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* LaunchRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:kservice.LaunchRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .kservice.EventHeader header = 1;
  if (this->_internal_has_header()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::header(this),
        _Internal::header(this).GetCachedSize(), target, stream);
  }

  // .kservice.Pool poolInfo = 2;
  if (this->_internal_has_poolinfo()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::poolinfo(this),
        _Internal::poolinfo(this).GetCachedSize(), target, stream);
  }

  // .kservice.KFileInfo fileInfo = 3;
  if (this->_internal_has_fileinfo()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::fileinfo(this),
        _Internal::fileinfo(this).GetCachedSize(), target, stream);
  }

  // .kservice.DanmuComment comment = 4;
  if (this->_internal_has_comment()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::comment(this),
        _Internal::comment(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:kservice.LaunchRequest)
  return target;
}

size_t LaunchRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:kservice.LaunchRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .kservice.EventHeader header = 1;
  if (this->_internal_has_header()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.header_);
  }

  // .kservice.Pool poolInfo = 2;
  if (this->_internal_has_poolinfo()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.poolinfo_);
  }

  // .kservice.KFileInfo fileInfo = 3;
  if (this->_internal_has_fileinfo()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.fileinfo_);
  }

  // .kservice.DanmuComment comment = 4;
  if (this->_internal_has_comment()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.comment_);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void LaunchRequest::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const LaunchRequest*>(
      &from));
}

void LaunchRequest::MergeFrom(const LaunchRequest& from) {
  LaunchRequest* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:kservice.LaunchRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_header()) {
    _this->_internal_mutable_header()->::kservice::EventHeader::MergeFrom(
        from._internal_header());
  }
  if (from._internal_has_poolinfo()) {
    _this->_internal_mutable_poolinfo()->::kservice::Pool::MergeFrom(
        from._internal_poolinfo());
  }
  if (from._internal_has_fileinfo()) {
    _this->_internal_mutable_fileinfo()->::kservice::KFileInfo::MergeFrom(
        from._internal_fileinfo());
  }
  if (from._internal_has_comment()) {
    _this->_internal_mutable_comment()->::kservice::DanmuComment::MergeFrom(
        from._internal_comment());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void LaunchRequest::CopyFrom(const LaunchRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:kservice.LaunchRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LaunchRequest::IsInitialized() const {
  return true;
}

void LaunchRequest::InternalSwap(LaunchRequest* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(LaunchRequest, _impl_.comment_)
      + sizeof(LaunchRequest::_impl_.comment_)
      - PROTOBUF_FIELD_OFFSET(LaunchRequest, _impl_.header_)>(
          reinterpret_cast<char*>(&_impl_.header_),
          reinterpret_cast<char*>(&other->_impl_.header_));
}

std::string LaunchRequest::GetTypeName() const {
  return "kservice.LaunchRequest";
}


// ===================================================================

class LaunchResponse::_Internal {
 public:
  static const ::kservice::ResponseHeader& header(const LaunchResponse* msg);
  static const ::kservice::DanmuSource& danmusource(const LaunchResponse* msg);
  static const ::kservice::DanmuComment& comment(const LaunchResponse* msg);
};

const ::kservice::ResponseHeader&
LaunchResponse::_Internal::header(const LaunchResponse* msg) {
  return *msg->_impl_.header_;
}
const ::kservice::DanmuSource&
LaunchResponse::_Internal::danmusource(const LaunchResponse* msg) {
  return *msg->_impl_.danmusource_;
}
const ::kservice::DanmuComment&
LaunchResponse::_Internal::comment(const LaunchResponse* msg) {
  return *msg->_impl_.comment_;
}
LaunchResponse::LaunchResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:kservice.LaunchResponse)
}
LaunchResponse::LaunchResponse(const LaunchResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  LaunchResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.poolid_){}
    , decltype(_impl_.header_){nullptr}
    , decltype(_impl_.danmusource_){nullptr}
    , decltype(_impl_.comment_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.poolid_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.poolid_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_poolid().empty()) {
    _this->_impl_.poolid_.Set(from._internal_poolid(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_header()) {
    _this->_impl_.header_ = new ::kservice::ResponseHeader(*from._impl_.header_);
  }
  if (from._internal_has_danmusource()) {
    _this->_impl_.danmusource_ = new ::kservice::DanmuSource(*from._impl_.danmusource_);
  }
  if (from._internal_has_comment()) {
    _this->_impl_.comment_ = new ::kservice::DanmuComment(*from._impl_.comment_);
  }
  // @@protoc_insertion_point(copy_constructor:kservice.LaunchResponse)
}

inline void LaunchResponse::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.poolid_){}
    , decltype(_impl_.header_){nullptr}
    , decltype(_impl_.danmusource_){nullptr}
    , decltype(_impl_.comment_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.poolid_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.poolid_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

LaunchResponse::~LaunchResponse() {
  // @@protoc_insertion_point(destructor:kservice.LaunchResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void LaunchResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.poolid_.Destroy();
  if (this != internal_default_instance()) delete _impl_.header_;
  if (this != internal_default_instance()) delete _impl_.danmusource_;
  if (this != internal_default_instance()) delete _impl_.comment_;
}

void LaunchResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void LaunchResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:kservice.LaunchResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.poolid_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && _impl_.header_ != nullptr) {
    delete _impl_.header_;
  }
  _impl_.header_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.danmusource_ != nullptr) {
    delete _impl_.danmusource_;
  }
  _impl_.danmusource_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.comment_ != nullptr) {
    delete _impl_.comment_;
  }
  _impl_.comment_ = nullptr;
  _internal_metadata_.Clear<std::string>();
}

const char* LaunchResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .kservice.ResponseHeader header = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_header(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string poolId = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_poolid();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else
          goto handle_unusual;
        continue;
      // .kservice.DanmuSource danmuSource = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_danmusource(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .kservice.DanmuComment comment = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_comment(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* LaunchResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:kservice.LaunchResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .kservice.ResponseHeader header = 1;
  if (this->_internal_has_header()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::header(this),
        _Internal::header(this).GetCachedSize(), target, stream);
  }

  // string poolId = 2;
  if (!this->_internal_poolid().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_poolid().data(), static_cast<int>(this->_internal_poolid().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "kservice.LaunchResponse.poolId");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_poolid(), target);
  }

  // .kservice.DanmuSource danmuSource = 3;
  if (this->_internal_has_danmusource()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::danmusource(this),
        _Internal::danmusource(this).GetCachedSize(), target, stream);
  }

  // .kservice.DanmuComment comment = 4;
  if (this->_internal_has_comment()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::comment(this),
        _Internal::comment(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:kservice.LaunchResponse)
  return target;
}

size_t LaunchResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:kservice.LaunchResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string poolId = 2;
  if (!this->_internal_poolid().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_poolid());
  }

  // .kservice.ResponseHeader header = 1;
  if (this->_internal_has_header()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.header_);
  }

  // .kservice.DanmuSource danmuSource = 3;
  if (this->_internal_has_danmusource()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.danmusource_);
  }

  // .kservice.DanmuComment comment = 4;
  if (this->_internal_has_comment()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.comment_);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void LaunchResponse::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const LaunchResponse*>(
      &from));
}

void LaunchResponse::MergeFrom(const LaunchResponse& from) {
  LaunchResponse* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:kservice.LaunchResponse)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_poolid().empty()) {
    _this->_internal_set_poolid(from._internal_poolid());
  }
  if (from._internal_has_header()) {
    _this->_internal_mutable_header()->::kservice::ResponseHeader::MergeFrom(
        from._internal_header());
  }
  if (from._internal_has_danmusource()) {
    _this->_internal_mutable_danmusource()->::kservice::DanmuSource::MergeFrom(
        from._internal_danmusource());
  }
  if (from._internal_has_comment()) {
    _this->_internal_mutable_comment()->::kservice::DanmuComment::MergeFrom(
        from._internal_comment());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void LaunchResponse::CopyFrom(const LaunchResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:kservice.LaunchResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LaunchResponse::IsInitialized() const {
  return true;
}

void LaunchResponse::InternalSwap(LaunchResponse* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.poolid_, lhs_arena,
      &other->_impl_.poolid_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(LaunchResponse, _impl_.comment_)
      + sizeof(LaunchResponse::_impl_.comment_)
      - PROTOBUF_FIELD_OFFSET(LaunchResponse, _impl_.header_)>(
          reinterpret_cast<char*>(&_impl_.header_),
          reinterpret_cast<char*>(&other->_impl_.header_));
}

std::string LaunchResponse::GetTypeName() const {
  return "kservice.LaunchResponse";
}


// ===================================================================

class KikoDanmuRequest::_Internal {
 public:
  static const ::kservice::EventHeader& header(const KikoDanmuRequest* msg);
  static const ::kservice::Pool& poolinfo(const KikoDanmuRequest* msg);
};

const ::kservice::EventHeader&
KikoDanmuRequest::_Internal::header(const KikoDanmuRequest* msg) {
  return *msg->_impl_.header_;
}
const ::kservice::Pool&
KikoDanmuRequest::_Internal::poolinfo(const KikoDanmuRequest* msg) {
  return *msg->_impl_.poolinfo_;
}
KikoDanmuRequest::KikoDanmuRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:kservice.KikoDanmuRequest)
}
KikoDanmuRequest::KikoDanmuRequest(const KikoDanmuRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  KikoDanmuRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.header_){nullptr}
    , decltype(_impl_.poolinfo_){nullptr}
    , decltype(_impl_.duration_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_header()) {
    _this->_impl_.header_ = new ::kservice::EventHeader(*from._impl_.header_);
  }
  if (from._internal_has_poolinfo()) {
    _this->_impl_.poolinfo_ = new ::kservice::Pool(*from._impl_.poolinfo_);
  }
  _this->_impl_.duration_ = from._impl_.duration_;
  // @@protoc_insertion_point(copy_constructor:kservice.KikoDanmuRequest)
}

inline void KikoDanmuRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.header_){nullptr}
    , decltype(_impl_.poolinfo_){nullptr}
    , decltype(_impl_.duration_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

KikoDanmuRequest::~KikoDanmuRequest() {
  // @@protoc_insertion_point(destructor:kservice.KikoDanmuRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void KikoDanmuRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.header_;
  if (this != internal_default_instance()) delete _impl_.poolinfo_;
}

void KikoDanmuRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void KikoDanmuRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:kservice.KikoDanmuRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.header_ != nullptr) {
    delete _impl_.header_;
  }
  _impl_.header_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.poolinfo_ != nullptr) {
    delete _impl_.poolinfo_;
  }
  _impl_.poolinfo_ = nullptr;
  _impl_.duration_ = 0;
  _internal_metadata_.Clear<std::string>();
}

const char* KikoDanmuRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .kservice.EventHeader header = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_header(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .kservice.Pool poolInfo = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_poolinfo(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 duration = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _impl_.duration_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* KikoDanmuRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:kservice.KikoDanmuRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .kservice.EventHeader header = 1;
  if (this->_internal_has_header()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::header(this),
        _Internal::header(this).GetCachedSize(), target, stream);
  }

  // .kservice.Pool poolInfo = 2;
  if (this->_internal_has_poolinfo()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::poolinfo(this),
        _Internal::poolinfo(this).GetCachedSize(), target, stream);
  }

  // int32 duration = 3;
  if (this->_internal_duration() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_duration(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:kservice.KikoDanmuRequest)
  return target;
}

size_t KikoDanmuRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:kservice.KikoDanmuRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .kservice.EventHeader header = 1;
  if (this->_internal_has_header()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.header_);
  }

  // .kservice.Pool poolInfo = 2;
  if (this->_internal_has_poolinfo()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.poolinfo_);
  }

  // int32 duration = 3;
  if (this->_internal_duration() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_duration());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void KikoDanmuRequest::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const KikoDanmuRequest*>(
      &from));
}

void KikoDanmuRequest::MergeFrom(const KikoDanmuRequest& from) {
  KikoDanmuRequest* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:kservice.KikoDanmuRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_header()) {
    _this->_internal_mutable_header()->::kservice::EventHeader::MergeFrom(
        from._internal_header());
  }
  if (from._internal_has_poolinfo()) {
    _this->_internal_mutable_poolinfo()->::kservice::Pool::MergeFrom(
        from._internal_poolinfo());
  }
  if (from._internal_duration() != 0) {
    _this->_internal_set_duration(from._internal_duration());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void KikoDanmuRequest::CopyFrom(const KikoDanmuRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:kservice.KikoDanmuRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool KikoDanmuRequest::IsInitialized() const {
  return true;
}

void KikoDanmuRequest::InternalSwap(KikoDanmuRequest* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(KikoDanmuRequest, _impl_.duration_)
      + sizeof(KikoDanmuRequest::_impl_.duration_)
      - PROTOBUF_FIELD_OFFSET(KikoDanmuRequest, _impl_.header_)>(
          reinterpret_cast<char*>(&_impl_.header_),
          reinterpret_cast<char*>(&other->_impl_.header_));
}

std::string KikoDanmuRequest::GetTypeName() const {
  return "kservice.KikoDanmuRequest";
}


// ===================================================================

class KikoDanmuResponse_DanmuSourceComments::_Internal {
 public:
  static const ::kservice::DanmuSource& source(const KikoDanmuResponse_DanmuSourceComments* msg);
};

const ::kservice::DanmuSource&
KikoDanmuResponse_DanmuSourceComments::_Internal::source(const KikoDanmuResponse_DanmuSourceComments* msg) {
  return *msg->_impl_.source_;
}
KikoDanmuResponse_DanmuSourceComments::KikoDanmuResponse_DanmuSourceComments(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:kservice.KikoDanmuResponse.DanmuSourceComments)
}
KikoDanmuResponse_DanmuSourceComments::KikoDanmuResponse_DanmuSourceComments(const KikoDanmuResponse_DanmuSourceComments& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  KikoDanmuResponse_DanmuSourceComments* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.danmucomments_){from._impl_.danmucomments_}
    , decltype(_impl_.source_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_source()) {
    _this->_impl_.source_ = new ::kservice::DanmuSource(*from._impl_.source_);
  }
  // @@protoc_insertion_point(copy_constructor:kservice.KikoDanmuResponse.DanmuSourceComments)
}

inline void KikoDanmuResponse_DanmuSourceComments::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.danmucomments_){arena}
    , decltype(_impl_.source_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

KikoDanmuResponse_DanmuSourceComments::~KikoDanmuResponse_DanmuSourceComments() {
  // @@protoc_insertion_point(destructor:kservice.KikoDanmuResponse.DanmuSourceComments)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void KikoDanmuResponse_DanmuSourceComments::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.danmucomments_.~RepeatedPtrField();
  if (this != internal_default_instance()) delete _impl_.source_;
}

void KikoDanmuResponse_DanmuSourceComments::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void KikoDanmuResponse_DanmuSourceComments::Clear() {
// @@protoc_insertion_point(message_clear_start:kservice.KikoDanmuResponse.DanmuSourceComments)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.danmucomments_.Clear();
  if (GetArenaForAllocation() == nullptr && _impl_.source_ != nullptr) {
    delete _impl_.source_;
  }
  _impl_.source_ = nullptr;
  _internal_metadata_.Clear<std::string>();
}

const char* KikoDanmuResponse_DanmuSourceComments::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .kservice.DanmuSource source = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_source(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .kservice.DanmuComment danmuComments = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_danmucomments(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* KikoDanmuResponse_DanmuSourceComments::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:kservice.KikoDanmuResponse.DanmuSourceComments)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .kservice.DanmuSource source = 1;
  if (this->_internal_has_source()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::source(this),
        _Internal::source(this).GetCachedSize(), target, stream);
  }

  // repeated .kservice.DanmuComment danmuComments = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_danmucomments_size()); i < n; i++) {
    const auto& repfield = this->_internal_danmucomments(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:kservice.KikoDanmuResponse.DanmuSourceComments)
  return target;
}

size_t KikoDanmuResponse_DanmuSourceComments::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:kservice.KikoDanmuResponse.DanmuSourceComments)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .kservice.DanmuComment danmuComments = 2;
  total_size += 1UL * this->_internal_danmucomments_size();
  for (const auto& msg : this->_impl_.danmucomments_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // .kservice.DanmuSource source = 1;
  if (this->_internal_has_source()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.source_);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void KikoDanmuResponse_DanmuSourceComments::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const KikoDanmuResponse_DanmuSourceComments*>(
      &from));
}

void KikoDanmuResponse_DanmuSourceComments::MergeFrom(const KikoDanmuResponse_DanmuSourceComments& from) {
  KikoDanmuResponse_DanmuSourceComments* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:kservice.KikoDanmuResponse.DanmuSourceComments)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.danmucomments_.MergeFrom(from._impl_.danmucomments_);
  if (from._internal_has_source()) {
    _this->_internal_mutable_source()->::kservice::DanmuSource::MergeFrom(
        from._internal_source());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void KikoDanmuResponse_DanmuSourceComments::CopyFrom(const KikoDanmuResponse_DanmuSourceComments& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:kservice.KikoDanmuResponse.DanmuSourceComments)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool KikoDanmuResponse_DanmuSourceComments::IsInitialized() const {
  return true;
}

void KikoDanmuResponse_DanmuSourceComments::InternalSwap(KikoDanmuResponse_DanmuSourceComments* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.danmucomments_.InternalSwap(&other->_impl_.danmucomments_);
  swap(_impl_.source_, other->_impl_.source_);
}

std::string KikoDanmuResponse_DanmuSourceComments::GetTypeName() const {
  return "kservice.KikoDanmuResponse.DanmuSourceComments";
}


// ===================================================================

class KikoDanmuResponse::_Internal {
 public:
  static const ::kservice::ResponseHeader& header(const KikoDanmuResponse* msg);
  static const ::kservice::Pool& poolinfo(const KikoDanmuResponse* msg);
};

const ::kservice::ResponseHeader&
KikoDanmuResponse::_Internal::header(const KikoDanmuResponse* msg) {
  return *msg->_impl_.header_;
}
const ::kservice::Pool&
KikoDanmuResponse::_Internal::poolinfo(const KikoDanmuResponse* msg) {
  return *msg->_impl_.poolinfo_;
}
KikoDanmuResponse::KikoDanmuResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:kservice.KikoDanmuResponse)
}
KikoDanmuResponse::KikoDanmuResponse(const KikoDanmuResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  KikoDanmuResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.danmusources_){from._impl_.danmusources_}
    , decltype(_impl_.header_){nullptr}
    , decltype(_impl_.poolinfo_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_header()) {
    _this->_impl_.header_ = new ::kservice::ResponseHeader(*from._impl_.header_);
  }
  if (from._internal_has_poolinfo()) {
    _this->_impl_.poolinfo_ = new ::kservice::Pool(*from._impl_.poolinfo_);
  }
  // @@protoc_insertion_point(copy_constructor:kservice.KikoDanmuResponse)
}

inline void KikoDanmuResponse::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.danmusources_){arena}
    , decltype(_impl_.header_){nullptr}
    , decltype(_impl_.poolinfo_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

KikoDanmuResponse::~KikoDanmuResponse() {
  // @@protoc_insertion_point(destructor:kservice.KikoDanmuResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void KikoDanmuResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.danmusources_.~RepeatedPtrField();
  if (this != internal_default_instance()) delete _impl_.header_;
  if (this != internal_default_instance()) delete _impl_.poolinfo_;
}

void KikoDanmuResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void KikoDanmuResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:kservice.KikoDanmuResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.danmusources_.Clear();
  if (GetArenaForAllocation() == nullptr && _impl_.header_ != nullptr) {
    delete _impl_.header_;
  }
  _impl_.header_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.poolinfo_ != nullptr) {
    delete _impl_.poolinfo_;
  }
  _impl_.poolinfo_ = nullptr;
  _internal_metadata_.Clear<std::string>();
}

const char* KikoDanmuResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .kservice.ResponseHeader header = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_header(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .kservice.Pool poolInfo = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_poolinfo(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .kservice.KikoDanmuResponse.DanmuSourceComments danmuSources = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_danmusources(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* KikoDanmuResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:kservice.KikoDanmuResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .kservice.ResponseHeader header = 1;
  if (this->_internal_has_header()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::header(this),
        _Internal::header(this).GetCachedSize(), target, stream);
  }

  // .kservice.Pool poolInfo = 2;
  if (this->_internal_has_poolinfo()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::poolinfo(this),
        _Internal::poolinfo(this).GetCachedSize(), target, stream);
  }

  // repeated .kservice.KikoDanmuResponse.DanmuSourceComments danmuSources = 3;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_danmusources_size()); i < n; i++) {
    const auto& repfield = this->_internal_danmusources(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:kservice.KikoDanmuResponse)
  return target;
}

size_t KikoDanmuResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:kservice.KikoDanmuResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .kservice.KikoDanmuResponse.DanmuSourceComments danmuSources = 3;
  total_size += 1UL * this->_internal_danmusources_size();
  for (const auto& msg : this->_impl_.danmusources_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // .kservice.ResponseHeader header = 1;
  if (this->_internal_has_header()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.header_);
  }

  // .kservice.Pool poolInfo = 2;
  if (this->_internal_has_poolinfo()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.poolinfo_);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void KikoDanmuResponse::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const KikoDanmuResponse*>(
      &from));
}

void KikoDanmuResponse::MergeFrom(const KikoDanmuResponse& from) {
  KikoDanmuResponse* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:kservice.KikoDanmuResponse)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.danmusources_.MergeFrom(from._impl_.danmusources_);
  if (from._internal_has_header()) {
    _this->_internal_mutable_header()->::kservice::ResponseHeader::MergeFrom(
        from._internal_header());
  }
  if (from._internal_has_poolinfo()) {
    _this->_internal_mutable_poolinfo()->::kservice::Pool::MergeFrom(
        from._internal_poolinfo());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void KikoDanmuResponse::CopyFrom(const KikoDanmuResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:kservice.KikoDanmuResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool KikoDanmuResponse::IsInitialized() const {
  return true;
}

void KikoDanmuResponse::InternalSwap(KikoDanmuResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.danmusources_.InternalSwap(&other->_impl_.danmusources_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(KikoDanmuResponse, _impl_.poolinfo_)
      + sizeof(KikoDanmuResponse::_impl_.poolinfo_)
      - PROTOBUF_FIELD_OFFSET(KikoDanmuResponse, _impl_.header_)>(
          reinterpret_cast<char*>(&_impl_.header_),
          reinterpret_cast<char*>(&other->_impl_.header_));
}

std::string KikoDanmuResponse::GetTypeName() const {
  return "kservice.KikoDanmuResponse";
}


// @@protoc_insertion_point(namespace_scope)
}  // namespace kservice
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::kservice::EventHeader*
Arena::CreateMaybeMessage< ::kservice::EventHeader >(Arena* arena) {
  return Arena::CreateMessageInternal< ::kservice::EventHeader >(arena);
}
template<> PROTOBUF_NOINLINE ::kservice::CommonEvent*
Arena::CreateMaybeMessage< ::kservice::CommonEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::kservice::CommonEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::kservice::ResponseHeader*
Arena::CreateMaybeMessage< ::kservice::ResponseHeader >(Arena* arena) {
  return Arena::CreateMessageInternal< ::kservice::ResponseHeader >(arena);
}
template<> PROTOBUF_NOINLINE ::kservice::RegisterRequest*
Arena::CreateMaybeMessage< ::kservice::RegisterRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::kservice::RegisterRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::kservice::RegisterResponse*
Arena::CreateMaybeMessage< ::kservice::RegisterResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::kservice::RegisterResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::kservice::LoginRequest*
Arena::CreateMaybeMessage< ::kservice::LoginRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::kservice::LoginRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::kservice::LoginResponse*
Arena::CreateMaybeMessage< ::kservice::LoginResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::kservice::LoginResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::kservice::RefreshRequest*
Arena::CreateMaybeMessage< ::kservice::RefreshRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::kservice::RefreshRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::kservice::RefreshResponse*
Arena::CreateMaybeMessage< ::kservice::RefreshResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::kservice::RefreshResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::kservice::SendVerificationRequest*
Arena::CreateMaybeMessage< ::kservice::SendVerificationRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::kservice::SendVerificationRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::kservice::SendVerificationResponse*
Arena::CreateMaybeMessage< ::kservice::SendVerificationResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::kservice::SendVerificationResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::kservice::UVEvent_StepTime*
Arena::CreateMaybeMessage< ::kservice::UVEvent_StepTime >(Arena* arena) {
  return Arena::CreateMessageInternal< ::kservice::UVEvent_StepTime >(arena);
}
template<> PROTOBUF_NOINLINE ::kservice::UVEvent*
Arena::CreateMaybeMessage< ::kservice::UVEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::kservice::UVEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::kservice::UVEventResponse_LatestVersion*
Arena::CreateMaybeMessage< ::kservice::UVEventResponse_LatestVersion >(Arena* arena) {
  return Arena::CreateMessageInternal< ::kservice::UVEventResponse_LatestVersion >(arena);
}
template<> PROTOBUF_NOINLINE ::kservice::UVEventResponse*
Arena::CreateMaybeMessage< ::kservice::UVEventResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::kservice::UVEventResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::kservice::KFileInfo*
Arena::CreateMaybeMessage< ::kservice::KFileInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::kservice::KFileInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::kservice::RecoRequest*
Arena::CreateMaybeMessage< ::kservice::RecoRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::kservice::RecoRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::kservice::DanmuSource*
Arena::CreateMaybeMessage< ::kservice::DanmuSource >(Arena* arena) {
  return Arena::CreateMessageInternal< ::kservice::DanmuSource >(arena);
}
template<> PROTOBUF_NOINLINE ::kservice::InfoSource*
Arena::CreateMaybeMessage< ::kservice::InfoSource >(Arena* arena) {
  return Arena::CreateMessageInternal< ::kservice::InfoSource >(arena);
}
template<> PROTOBUF_NOINLINE ::kservice::Pool*
Arena::CreateMaybeMessage< ::kservice::Pool >(Arena* arena) {
  return Arena::CreateMessageInternal< ::kservice::Pool >(arena);
}
template<> PROTOBUF_NOINLINE ::kservice::RecoResponse*
Arena::CreateMaybeMessage< ::kservice::RecoResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::kservice::RecoResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::kservice::MatchEvent_Match*
Arena::CreateMaybeMessage< ::kservice::MatchEvent_Match >(Arena* arena) {
  return Arena::CreateMessageInternal< ::kservice::MatchEvent_Match >(arena);
}
template<> PROTOBUF_NOINLINE ::kservice::MatchEvent*
Arena::CreateMaybeMessage< ::kservice::MatchEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::kservice::MatchEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::kservice::AddDanmuSourceEvent_DanmuPoolSource*
Arena::CreateMaybeMessage< ::kservice::AddDanmuSourceEvent_DanmuPoolSource >(Arena* arena) {
  return Arena::CreateMessageInternal< ::kservice::AddDanmuSourceEvent_DanmuPoolSource >(arena);
}
template<> PROTOBUF_NOINLINE ::kservice::AddDanmuSourceEvent*
Arena::CreateMaybeMessage< ::kservice::AddDanmuSourceEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::kservice::AddDanmuSourceEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::kservice::DanmuComment*
Arena::CreateMaybeMessage< ::kservice::DanmuComment >(Arena* arena) {
  return Arena::CreateMessageInternal< ::kservice::DanmuComment >(arena);
}
template<> PROTOBUF_NOINLINE ::kservice::LaunchRequest*
Arena::CreateMaybeMessage< ::kservice::LaunchRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::kservice::LaunchRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::kservice::LaunchResponse*
Arena::CreateMaybeMessage< ::kservice::LaunchResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::kservice::LaunchResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::kservice::KikoDanmuRequest*
Arena::CreateMaybeMessage< ::kservice::KikoDanmuRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::kservice::KikoDanmuRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::kservice::KikoDanmuResponse_DanmuSourceComments*
Arena::CreateMaybeMessage< ::kservice::KikoDanmuResponse_DanmuSourceComments >(Arena* arena) {
  return Arena::CreateMessageInternal< ::kservice::KikoDanmuResponse_DanmuSourceComments >(arena);
}
template<> PROTOBUF_NOINLINE ::kservice::KikoDanmuResponse*
Arena::CreateMaybeMessage< ::kservice::KikoDanmuResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::kservice::KikoDanmuResponse >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
